{"version":3,"mappings":"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","names":["localSearchIndex","root","__vitePreload","import","__VITE_PRELOAD__","candidateSelectors","candidateSelector","join","NoElement","Element","matches","prototype","msMatchesSelector","webkitMatchesSelector","getRootNode","element","_element$getRootNode","call","ownerDocument","isInert","node","lookUp","_node$getAttribute","inertAtt","getAttribute","parentNode","getCandidates","el","includeContainer","filter","candidates","Array","slice","apply","querySelectorAll","unshift","getCandidatesIteratively","elements","options","elementsToCheck","from","length","shift","tagName","assigned","assignedElements","nestedCandidates","children","flatten","push","scopeParent","includes","shadowRoot","getShadowRoot","validShadowRoot","shadowRootFilter","_nestedCandidates","hasTabIndex","isNaN","parseInt","getTabIndex","Error","tabIndex","test","_node$getAttribute2","attValue","isContentEditable","sortOrderedTabbables","a","b","documentOrder","isInput","isNonTabbableRadio","type","isRadio","name","radioSet","radioScope","form","queryRadios","window","CSS","escape","err","checked","nodes","i","getCheckedRadio","isTabbableRadio","isZeroArea","_node$getBoundingClie","getBoundingClientRect","width","height","isHidden","_ref","displayCheck","getComputedStyle","visibility","nodeUnderDetails","parentElement","originalNode","rootNode","assignedSlot","host","_nodeRoot","_nodeRootHost","_nodeRootHost$ownerDo","_node$ownerDocument","nodeRoot","nodeRootHost","attached","contains","_nodeRoot2","_nodeRootHost2","_nodeRootHost2$ownerD","isNodeAttached","getClientRects","isNodeMatchingSelectorFocusable","disabled","isHiddenInput","some","child","isDetailsWithSummary","item","isDisabledFromFieldset","isNodeMatchingSelectorTabbable","isValidShadowRootTabbable","shadowHostNode","sortByOrder","regularTabbables","orderedTabbables","forEach","isScope","candidateTabindex","getSortOrderTabIndex","content","sort","reduce","acc","sortable","concat","isTabbable","focusableCandidateSelector","isFocusable","_arrayLikeToArray","r","e","n","_defineProperty","t","Symbol","toPrimitive","TypeError","String","Number","_toPrimitive","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","ownKeys","keys","getOwnPropertySymbols","o","getOwnPropertyDescriptor","_objectSpread2","arguments","getOwnPropertyDescriptors","defineProperties","_toConsumableArray","isArray","_arrayWithoutHoles","iterator","_iterableToArray","toString","constructor","_unsupportedIterableToArray","_nonIterableSpread","activeFocusTraps","trapStack","trap","activeTrap","_setPausedState","trapIndex","indexOf","splice","_isManuallyPaused","isTabEvent","key","keyCode","isKeyForward","shiftKey","isKeyBackward","delay","fn","setTimeout","valueOrHandler","_len","params","_key","getActualTarget","event","target","composedPath","internalTrapStack","createFocusTrap","userOptions","doc","document","config","returnFocusOnDeactivate","escapeDeactivates","delayInitialFocus","state","containers","containerGroups","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","manuallyPaused","delayInitialFocusTimer","recentNavEvent","getOption","configOverrideOptions","optionName","configOptionName","findContainerIndex","findIndex","container","tabbableNodes","find","getNodeForOption","_ref2","_ref2$hasFallback","hasFallback","_ref2$params","optionValue","querySelector","message","getInitialFocusNode","tabbableOptions","activeElement","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","map","bind","tabbable","focusableNodes","focusable","lastTabbableNode","firstDomTabbableNode","lastDomTabbableNode","reverse","posTabIndexesFound","nextTabbableNode","forward","nodeIdx","group","g","_getActiveElement","_tryFocus","focus","preventScroll","toLowerCase","select","isSelectableInput","getReturnFocusNode","previousActiveElement","findNextNavNode","_ref3","_ref3$isBackward","isBackward","destinationNode","containerIndex","containerGroup","startOfGroupIndex","_ref4","destinationGroupIndex","destinationGroup","lastOfGroupIndex","_ref5","_destinationGroupIndex","_destinationGroup","checkPointerDown","clickOutsideDeactivates","deactivate","returnFocus","allowOutsideClick","preventDefault","checkFocusIn","targetContained","Document","nextNode","stopImmediatePropagation","navAcrossContainers","mruContainerIdx","mruTabIdx","checkTabKey","checkKeyNav","checkEscapeKey","checkClick","addListeners","addEventListener","capture","passive","removeListeners","removeEventListener","mutationObserver","MutationObserver","mutations","mutation","removedNodes","updateObservedNodes","disconnect","observe","subtree","childList","activate","activateOptions","this","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","then","deactivateOptions","onDeactivate","onPostDeactivate","checkCanReturnFocus","clearTimeout","finishDeactivation","pause","pauseOptions","unpause","unpauseOptions","updateContainerElements","containerElements","elementsAsArray","Boolean","onPause","onPostPause","onUnpause","onPostUnpause","DOMIterator","ctx","iframes","exclude","iframesTimeout","selector","selectors","matchesSelector","mozMatchesSelector","oMatchesSelector","match","every","sel","getContexts","filteredCtx","NodeList","isPrototypeOf","isDescendant","contexts","getIframeContents","ifr","successFn","errorFn","ifrWin","contentWindow","isIframeBlank","bl","src","trim","location","href","observeIframeLoad","called","tout","listener","onIframeReady","readyState","waitForIframes","done","eachCalled","forEachIframe","handled","each","end","open","checkEnd","con","createIterator","whatToShow","createNodeIterator","createInstanceOnIframe","contents","compareNodeIframe","prevNode","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","getIteratorNode","itr","previousNode","checkIframeFilter","currIfr","ifrDict","val","handleOpenIframes","eCb","fCb","forEachNode","iterateThroughNodes","eachCb","filterCb","doneCb","retrieveNodes","ifrNode","ready","Mark$1","ie","ua","navigator","userAgent","opt","_opt","assign","className","separateWordSearch","diacritics","synonyms","accuracy","acrossElements","caseSensitive","ignoreJoiners","ignoreGroups","ignorePunctuation","wildcards","noMatch","debug","log","console","msg","level","escapeStr","str","replace","createRegExp","setupWildcardsRegExp","createSynonymsRegExp","setupIgnoreJoinersRegExp","createDiacriticsRegExp","createMergedBlanksRegExp","createJoinersRegExp","createWildcardsRegExp","createAccuracyRegExp","syn","sens","joinerPlaceholder","index","hasOwnProperty","k1","k2","RegExp","processSynomyms","charAt","spaces","indx","original","nextChar","joiner","split","dct","ch","ls","limiters","lsJoin","limiter","getSeparatedKeywords","sv","stack","kw","kwSplitted","keywords","isNumeric","parseFloat","checkRanges","array","last","start","valid","callNoMatchOnInvalidRanges","range","JSON","stringify","checkWhitespaceRanges","originalLength","string","max","offset","substring","getTextNodes","cb","NodeFilter","SHOW_TEXT","textContent","matchesExclude","FILTER_REJECT","FILTER_ACCEPT","wrapRangeInTextNode","hEl","startNode","splitText","ret","repl","createElement","setAttribute","replaceChild","wrapRangeInMappedTextNode","dict","sibl","s","startStr","substr","endStr","k","j","previousSibling","wrapMatches","regex","endCb","matchIdx","exec","pos","lastIndex","wrapMatchesAcrossElements","wrapRangeFromIndex","ranges","counter","unwrapMatches","parent","docFrag","createDocumentFragment","firstChild","appendChild","removeChild","normalizeTextNode","normalize","nodeType","nextSibling","nodeValue","markRegExp","regexp","totalMatches","mark","kwArr","kwArrLen","handler","term","markRanges","rawRanges","unmark","SHOW_ELEMENT","matchesSel","Mark","instance","MarkJS","KEYS","VALUES","LEAF","TreeIterator","set","_tree","_type","_path","next","dive","backtrack","last$1","result","get","pop","_prefix","recurse","query","maxDistance","results","matrix","m","prefix","distance","char","thisRowOffset","prevRowOffset","minDistance","jmin","Math","jmax","min","different","rpl","del","ins","dist","SearchableMap","tree","Map","_size","atPrefix","startsWith","path","trackDown","clear","remove","entries","fuzzyGet","maxEditDistance","Uint8Array","fill","fuzzySearch","lookup","has","createPath","size","iter","update","fetch","initial","values","fromObject","object","keyLength","outer","len","intermediate","delete","cleanup","merge","nodeKey","OR","AND","AND_NOT","MiniSearch","fields","autoVacuum","defaultAutoVacuumOptions","_options","defaultOptions","searchOptions","defaultSearchOptions","autoSuggestOptions","defaultAutoSuggestOptions","_index","_documentCount","_documentIds","_idToShortId","_fieldIds","_fieldLength","_avgFieldLength","_nextId","_storedFields","_dirtCount","_currentVacuum","_enqueuedVacuum","_enqueuedVacuumConditions","defaultVacuumConditions","addFields","add","extractField","tokenize","processTerm","idField","id","shortDocumentId","addDocumentId","saveStoredFields","field","fieldValue","tokens","fieldId","uniqueTerms","Set","addFieldLength","processedTerm","addTerm","addAll","documents","addAllAsync","chunkSize","chunk","promise","Promise","resolve","shortId","removeFieldLength","removeTerm","removeAll","discard","fieldLength","maybeAutoVacuum","minDirtFactor","minDirtCount","batchSize","batchWait","conditionalVacuum","discardAll","ids","updatedDocument","vacuum","conditions","performVacuuming","vacuumConditionsMet","initialDirtCount","defaultVacuumOptions","fieldsData","fieldIndex","dirtCount","dirtFactor","isVacuuming","getStoredFields","search","globalSearchOptions","searchOptionsWithDefaults","rawResults","executeQuery","docId","score","terms","quality","queryTerms","wildcard","boostDocument","byScore","autoSuggest","queryString","suggestions","phrase","suggestion","count","documentCount","termCount","loadJSON","json","loadJS","parse","loadJSONAsync","loadJSAsync","getDefault","getOwnProperty","js","documentIds","storedFields","serializationVersion","miniSearch","instantiateMiniSearch","objectToNumericMap","data","dataMap","indexEntry","ds","objectToNumericMapAsync","wait","nextId","fieldIds","averageFieldLength","executeWildcardQuery","queries","subquery","combineResults","combineWith","searchTokenize","searchProcessTerm","flatMap","termToQuerySpec","executeQuerySpec","boosts","boost","weights","maxFuzzy","bm25","bm25params","fuzzy","fuzzyWeight","prefixWeight","termResults","termBoost","prefixMatches","fuzzyMatches","round","weight","operator","combinator","combinators","toJSON","freqs","fromEntries","sourceTerm","derivedTerm","termWeight","fieldTermData","fieldBoosts","boostDocumentFn","fieldBoost","fieldTermFreqs","matchingFields","avgFieldLength","docBoost","termFreq","weightedScore","calcBM25Score","assignUniqueTerm","documentId","indexData","createMap","docs","warnDocumentChanged","fieldName","logger","fieldLengths","totalFieldLength","storeFields","documentFields","property","existing","assignUniqueTerms","combined","matchingCount","totalCount","d","boostTerm","text","SPACE_OR_PUNCTUATION","source","async","ms","LRUCache","__publicField","cache","first","emit","__emit","shallowRef","resultsEl","searchIndexData","vitePressData","useData","immediate","focusTrapOptions","hasFocus","isPaused","opts","targets","computed","_targets","toValue","toArray","_el","unrefElement","notNullish","watch","els","flush","tryOnScopeDispose","useFocusTrap","localeIndex","theme","searchIndex","computedAsync","markRaw","_c","_b","_a","default","title","titles","_d","provider","_f","_e","_g","_i","_h","filterText","disableQueryPersistence","ref","useSessionStorage","showDetailedList","useLocalStorage","detailedView","disableDetailedView","buttonText","algolia","locales","translations","button","watchEffect","enableNoResults","debouncedWatch","filterTextValue","showDetailedListValue","old","onCleanup","canceled","mods","all","file","pathToFile","mod","fetchExcerpt","mapId","comp","render","setup","app","createApp","warnHandler","provide","dataSymbol","globalProperties","$frontmatter","frontmatter","$params","page","div","mount","anchor","html","nextElementSibling","outerHTML","unmount","nextTick","escapeRegExp","formMarkRegex","excerpts","excerpt","scrollIntoView","block","firstElementChild","debounce","searchInput","disableReset","focusSearchInput","onMounted","selectedIndex","disableMouseOver","scrollToSelectedResult","selectedEl","onKeyStroke","router","useRouter","isComposing","HTMLButtonElement","selectedPackage","HTMLInputElement","go","translate","createSearchTranslate","modal","displayDetails","resetButtonTitle","backButtonTitle","noResultsText","footer","selectText","selectKeyAriaLabel","navigateText","navigateUpKeyAriaLabel","navigateDownKeyAriaLabel","closeText","closeKeyAriaLabel","history","pushState","useEventListener","isLocked","useScrollLock","inBrowser","body","resetSearch","onMouseMove","closest","dataset","onBeforeUnmount","_createBlock","_Teleport","to","_createElementVNode","role","class","onClick","$emit","_hoisted_2","onPointerup","_cache","$event","pointerType","onSubmit","for","_hoisted_4","_unref","autocapitalize","autocomplete","autocorrect","enterkeyhint","maxlength","placeholder","spellcheck","_hoisted_7","_createElementBlock","_normalizeClass","onMousemove","_openBlock","_Fragment","_renderList","p","selected","onMouseenter","onFocusin","_hoisted_13","innerHTML","_hoisted_15","_hoisted_17","_hoisted_18","_hoisted_20","_createTextVNode","_toDisplayString","_hoisted_21","_hoisted_25"],"ignoreList":[1,2,3,4,5,6,7,8,9],"sources":["../../../../../../../../@localSearchIndex","../../../node_modules/.pnpm/tabbable@6.2.0/node_modules/tabbable/dist/index.esm.js","../../../node_modules/.pnpm/focus-trap@7.6.5/node_modules/focus-trap/dist/focus-trap.esm.js","../../../node_modules/.pnpm/mark.js@8.11.1/node_modules/mark.js/src/lib/domiterator.js","../../../node_modules/.pnpm/mark.js@8.11.1/node_modules/mark.js/src/lib/mark.js","../../../node_modules/.pnpm/mark.js@8.11.1/node_modules/mark.js/src/vanilla.js","../../../node_modules/.pnpm/minisearch@7.1.2/node_modules/minisearch/dist/es/index.js","../../../node_modules/.pnpm/vitepress@1.6.3_@algolia+client-search@5.35.0_@types+node@24.1.0_@types+react@19.1.9_markdown_h7mioo7s3v2perar7e3d2uzxeu/node_modules/vitepress/dist/client/theme-default/support/lru.js","../../../node_modules/.pnpm/vitepress@1.6.3_@algolia+client-search@5.35.0_@types+node@24.1.0_@types+react@19.1.9_markdown_h7mioo7s3v2perar7e3d2uzxeu/node_modules/vitepress/dist/client/theme-default/components/VPLocalSearchBox.vue","../../../node_modules/.pnpm/@vueuse+integrations@12.8.2_focus-trap@7.6.5_typescript@5.9.2/node_modules/@vueuse/integrations/useFocusTrap.mjs"],"sourcesContent":["export default {\"root\": () => import('@localSearchIndexroot')}","/*!\n* tabbable 6.2.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\n// NOTE: separate `:not()` selectors has broader browser support than the newer\n//  `:not([inert], [inert] *)` (Feb 2023)\n// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\n//  the entire query to fail, resulting in no nodes found, which will break a lot\n//  of things... so we have to rely on JS to identify nodes inside an inert container\nvar candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable=\"false\"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  var _element$getRootNode;\n  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\n} : function (element) {\n  return element === null || element === void 0 ? void 0 : element.ownerDocument;\n};\n\n/**\n * Determines if a node is inert or in an inert ancestor.\n * @param {Element} [node]\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n *  see if any of them are inert. If false, only `node` itself is considered.\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n *  False if `node` is falsy.\n */\nvar isInert = function isInert(node, lookUp) {\n  var _node$getAttribute;\n  if (lookUp === void 0) {\n    lookUp = true;\n  }\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's an active element\n  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');\n  var inert = inertAtt === '' || inertAtt === 'true';\n\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\n  //  code works for any kind of node\n  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\n  //  so it likely would not support `:is([inert] *)` either...\n  var result = inert || lookUp && node && isInert(node.parentNode); // recursive\n\n  return result;\n};\n\n/**\n * Determines if a node's content is editable.\n * @param {Element} [node]\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\n */\nvar isContentEditable = function isContentEditable(node) {\n  var _node$getAttribute2;\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\n  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');\n  return attValue === '' || attValue === 'true';\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  // even if `includeContainer=false`, we still have to check it for inertness because\n  //  if it's inert, all its children are inert\n  if (isInert(el)) {\n    return [];\n  }\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n    if (isInert(element, false)) {\n      // no need to look up since we're drilling down\n      // anything inside this container will also be inert\n      continue;\n    }\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      var shadowRoot = element.shadowRoot ||\n      // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n\n      // no inert look up because we're already drilling down and checking for inertness\n      //  on the way down, so all containers to this root node should have already been\n      //  vetted as non-inert\n      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\n/**\n * @private\n * Determines if the node has an explicitly specified `tabindex` attribute.\n * @param {HTMLElement} node\n * @returns {boolean} True if so; false if not.\n */\nvar hasTabIndex = function hasTabIndex(node) {\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\n};\n\n/**\n * Determine the tab index of a given node.\n * @param {HTMLElement} node\n * @returns {number} Tab order (negative, 0, or positive number).\n * @throws {Error} If `node` is falsy.\n */\nvar getTabIndex = function getTabIndex(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n};\n\n/**\n * Determine the tab index of a given node __for sort order purposes__.\n * @param {HTMLElement} node\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n *  inserted into the correct sort position.\n * @returns {number} Tab order (negative, 0, or positive number).\n */\nvar getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {\n  var tabIndex = getTabIndex(node);\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n    return 0;\n  }\n  return tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  var radioScope = node.form || getRootNode(node);\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n  var radioSet;\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nvar isNodeAttached = function isNodeAttached(node) {\n  var _nodeRoot;\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\n  var nodeRoot = node && getRootNode(node);\n  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\n\n  // in some cases, a detached node will return itself as the root instead of a document or\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\n  var attached = false;\n  if (nodeRoot && nodeRoot !== node) {\n    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\n    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\n    while (!attached && nodeRootHost) {\n      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n      //  which means we need to get the host's host and check if that parent host is contained\n      //  in (i.e. attached to) the document\n      nodeRoot = getRootNode(nodeRootHost);\n      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\n      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\n    }\n  }\n  return attached;\n};\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    width = _node$getBoundingClie.width,\n    height = _node$getBoundingClie.height;\n  return width === 0 && height === 0;\n};\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n    getShadowRoot = _ref.getShadowRoot;\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled ||\n  // we must do an inert look up to filter out any elements inside an inert ancestor\n  //  because we're limited in the type of selectors we can use in JSDom (see related\n  //  note related to `candidateSelectors`)\n  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||\n  // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n  return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n  return true;\n};\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scopeParent;\n    var element = isScope ? item.scopeParent : item;\n    var candidateTabindex = getSortOrderTabIndex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n  return sortByOrder(candidates);\n};\nvar focusable = function focusable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n  return candidates;\n};\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, getTabIndex, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","/*!\n* focus-trap 7.6.5\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { tabbable, focusable, isTabbable, getTabIndex, isFocusable } from 'tabbable';\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), true).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r);\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nvar activeFocusTraps = {\n  activateTrap: function activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      var activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap._setPausedState(true);\n      }\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0 && !trapStack[trapStack.length - 1]._isManuallyPaused()) {\n      trapStack[trapStack.length - 1]._setPausedState(false);\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   posTabIndexesFound: boolean,\n    //   firstTabbableNode: HTMLElement|undefined,\n    //   lastTabbableNode: HTMLElement|undefined,\n    //   firstDomTabbableNode: HTMLElement|undefined,\n    //   lastDomTabbableNode: HTMLElement|undefined,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    manuallyPaused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any\n    recentNavEvent: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @param {Event} [event] If available, and `element` isn't directly found in any container,\n   *  the event's composed path is used to see if includes any known trap containers in the\n   *  case where the element is inside a Shadow DOM.\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element, event) {\n    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || (// fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @param {Object} options\n   * @param {boolean} [options.hasFallback] True if the option could be a selector string\n   *  and the option allows for a fallback scenario in the case where the selector is\n   *  valid but does not match a node (i.e. the queried node doesn't exist in the DOM).\n   * @param {Array} [options.params] Params to pass to the option if it's a function.\n   * @returns {undefined | null | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `null` if the option didn't resolve\n   *  to a node but `options.hasFallback=true`, `false` if the option resolved to `false`\n   *  (node explicitly not given); otherwise, the resolved DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node, unless the option is a selector string and `options.hasFallback=true`.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$hasFallback = _ref2.hasFallback,\n      hasFallback = _ref2$hasFallback === void 0 ? false : _ref2$hasFallback,\n      _ref2$params = _ref2.params,\n      params = _ref2$params === void 0 ? [] : _ref2$params;\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      optionValue = optionValue.apply(void 0, _toConsumableArray(params));\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      try {\n        node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      } catch (err) {\n        throw new Error(\"`\".concat(optionName, \"` appears to be an invalid selector; error=\\\"\").concat(err.message, \"\\\"\"));\n      }\n      if (!node) {\n        if (!hasFallback) {\n          throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n        }\n        // else, `node` MUST be `null` because that's what `Document.querySelector()` returns\n        //  if the selector is valid but doesn't match anything\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus', {\n      hasFallback: true\n    });\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined || node && !isFocusable(node, config.tabbableOptions)) {\n      // option not specified nor focusable: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    } else if (node === null) {\n      // option is a VALID selector string that doesn't yield a node: use the `fallbackFocus`\n      //  option instead of the default behavior when the option isn't specified at all\n      node = getNodeForOption('fallbackFocus');\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes\n      //  are focusable but not tabbable\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;\n      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;\n      var firstDomTabbableNode = focusableNodes.find(function (node) {\n        return isTabbable(node);\n      });\n      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {\n        return isTabbable(node);\n      });\n      var posTabIndexesFound = !!tabbableNodes.find(function (node) {\n        return getTabIndex(node) > 0;\n      });\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        /** True if at least one node with positive `tabindex` was found in this container. */\n        posTabIndexesFound: posTabIndexesFound,\n        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */\n        firstTabbableNode: firstTabbableNode,\n        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */\n        lastTabbableNode: lastTabbableNode,\n        // NOTE: DOM order is NOT NECESSARILY \"document position\" order, but figuring that out\n        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        //  because that API doesn't work with Shadow DOM as well as it should (@see\n        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,\n        //  to address an edge case related to positive tabindex support, this seems like a much easier,\n        //  \"close enough most of the time\" alternative for positive tabindexes which should generally\n        //  be avoided anyway...\n        /** First tabbable node in container, __DOM__ order; `undefined` if none. */\n        firstDomTabbableNode: firstDomTabbableNode,\n        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */\n        lastDomTabbableNode: lastDomTabbableNode,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          var nodeIdx = tabbableNodes.indexOf(node);\n          if (nodeIdx < 0) {\n            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):\n            //  since `node` should at least have been focusable, we assume that's the case and mimic\n            //  what browsers do, which is set focus to the next node in __document position order__,\n            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE\n            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to\n            //  basic DOM order\n            if (forward) {\n              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {\n                return isTabbable(el);\n              });\n            }\n            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {\n              return isTabbable(el);\n            });\n          }\n          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n\n    // NOTE: Positive tabindexes are only properly supported in single-container traps because\n    //  doing it across multiple containers where tabindexes could be all over the place\n    //  would require Tabbable to support multiple containers, would require additional\n    //  specialized Shadow DOM support, and would require Tabbable's multi-container support\n    //  to look at those containers in document position order rather than user-provided\n    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on\n    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.\n    if (state.containerGroups.find(function (g) {\n      return g.posTabIndexesFound;\n    }) && state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  };\n\n  /**\n   * Gets the current activeElement. If it's a web-component and has open shadow-root\n   * it will recursively search inside shadow roots for the \"true\" activeElement.\n   *\n   * @param {Document | ShadowRoot} el\n   *\n   * @returns {HTMLElement} The element that currently has the focus\n   **/\n  var _getActiveElement = function getActiveElement(el) {\n    var activeElement = el.activeElement;\n    if (!activeElement) {\n      return;\n    }\n    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {\n      return _getActiveElement(activeElement.shadowRoot);\n    }\n    return activeElement;\n  };\n  var _tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === _getActiveElement(document)) {\n      return;\n    }\n    if (!node || !node.focus) {\n      _tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    // NOTE: focus() API does not trigger focusIn event so set MRU node manually\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', {\n      params: [previousActiveElement]\n    });\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  /**\n   * Finds the next node (in either direction) where focus should move according to a\n   *  keyboard focus-in event.\n   * @param {Object} params\n   * @param {Node} [params.target] Known target __from which__ to navigate, if any.\n   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event\n   *  will be used to determine the `target`). Ignored if `target` is specified.\n   * @param {boolean} [params.isBackward] True if focus should move backward.\n   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be\n   *  determined given the current state of the trap.\n   */\n  var findNextNavNode = function findNextNavNode(_ref3) {\n    var target = _ref3.target,\n      event = _ref3.event,\n      _ref3$isBackward = _ref3.isBackward,\n      isBackward = _ref3$isBackward === void 0 ? false : _ref3$isBackward;\n    target = target || getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target, event);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = state.tabbableGroups.findIndex(function (_ref4) {\n          var firstTabbableNode = _ref4.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = state.tabbableGroups.findIndex(function (_ref5) {\n          var lastTabbableNode = _ref5.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    return destinationNode;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked (and if not focusable, to \"nothing\"); by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node), whether the\n        //  outside click was on a focusable node or not\n        returnFocus: config.returnFocusOnDeactivate\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected\n  //  scrolling if the node that got focused was out of view; there's nothing we can do to\n  //  prevent that from happening by the time we discover that focus escaped\n  var checkFocusIn = function checkFocusIn(event) {\n    var target = getActualTarget(event);\n    var targetContained = findContainerIndex(target, event) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      event.stopImmediatePropagation();\n\n      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;\n      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward\n      //  toward a node with a positive tab index\n      var nextNode; // next node to focus, if we find one\n      var navAcrossContainers = true;\n      if (state.mostRecentlyFocusedNode) {\n        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {\n          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...\n          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);\n          // there MAY not be any tabbable nodes in the container if there are at least 2 containers\n          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container\n          //  with at least one tabbable node in order to function, so this could be the other container\n          //  with nothing tabbable in it)\n          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;\n          if (tabbableNodes.length > 0) {\n            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable\n            var mruTabIdx = tabbableNodes.findIndex(function (node) {\n              return node === state.mostRecentlyFocusedNode;\n            });\n            if (mruTabIdx >= 0) {\n              if (config.isKeyForward(state.recentNavEvent)) {\n                if (mruTabIdx + 1 < tabbableNodes.length) {\n                  nextNode = tabbableNodes[mruTabIdx + 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              } else {\n                if (mruTabIdx - 1 >= 0) {\n                  nextNode = tabbableNodes[mruTabIdx - 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              }\n              // else, don't find in container order without considering direction too\n            }\n          }\n          // else, no tabbable nodes in that container (which means we must have at least one other\n          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown\n          //  an error the last time updateTabbableNodes() was run): find next node among all known\n          //  containers\n        } else {\n          // check to see if there's at least one tabbable node with a positive tab index inside\n          //  the trap because focus seems to escape when navigating backward from a tabbable node\n          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with\n          //  the greatest positive tab index like it should)\n          if (!state.containerGroups.some(function (g) {\n            return g.tabbableNodes.some(function (n) {\n              return getTabIndex(n) > 0;\n            });\n          })) {\n            // no containers with tabbable nodes with positive tab indexes which means the focus\n            //  escaped for some other reason and we should just execute the fallback to the\n            //  MRU node or initial focus node, if any\n            navAcrossContainers = false;\n          }\n        }\n      } else {\n        // no MRU node means we're likely in some initial condition when the trap has just\n        //  been activated and initial focus hasn't been given yet, in which case we should\n        //  fall through to trying to focus the initial focus node, which is what should\n        //  happen below at this point in the logic\n        navAcrossContainers = false;\n      }\n      if (navAcrossContainers) {\n        nextNode = findNextNavNode({\n          // move FROM the MRU node, not event-related node (which will be the node that is\n          //  outside the trap causing the focus escape we're trying to fix)\n          target: state.mostRecentlyFocusedNode,\n          isBackward: config.isKeyBackward(state.recentNavEvent)\n        });\n      }\n      if (nextNode) {\n        _tryFocus(nextNode);\n      } else {\n        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n      }\n    }\n    state.recentNavEvent = undefined; // clear\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    state.recentNavEvent = event;\n    var destinationNode = findNextNavNode({\n      event: event,\n      isBackward: isBackward\n    });\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      _tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n  var checkTabKey = function checkTabKey(event) {\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n\n  // we use a different event phase for the Escape key to allow canceling the event and checking for this in escapeDeactivates\n  var checkEscapeKey = function checkEscapeKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      _tryFocus(getInitialFocusNode());\n    }) : _tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkTabKey, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkTabKey, true);\n    doc.removeEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n\n  //\n  // MUTATION OBSERVER\n  //\n\n  var checkDomRemoval = function checkDomRemoval(mutations) {\n    var isFocusedNodeRemoved = mutations.some(function (mutation) {\n      var removedNodes = Array.from(mutation.removedNodes);\n      return removedNodes.some(function (node) {\n        return node === state.mostRecentlyFocusedNode;\n      });\n    });\n\n    // If the currently focused is removed then browsers will move focus to the\n    // <body> element. If this happens, try to move focus back into the trap.\n    if (isFocusedNodeRemoved) {\n      _tryFocus(getInitialFocusNode());\n    }\n  };\n\n  // Use MutationObserver - if supported - to detect if focused node is removed\n  // from the DOM.\n  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;\n  var updateObservedNodes = function updateObservedNodes() {\n    if (!mutationObserver) {\n      return;\n    }\n    mutationObserver.disconnect();\n    if (state.active && !state.paused) {\n      state.containers.map(function (container) {\n        mutationObserver.observe(container, {\n          subtree: true,\n          childList: true\n        });\n      });\n    }\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = _getActiveElement(doc);\n      onActivate === null || onActivate === void 0 || onActivate();\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        updateObservedNodes();\n        onPostActivate === null || onPostActivate === void 0 || onPostActivate();\n      };\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      updateObservedNodes();\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      onDeactivate === null || onDeactivate === void 0 || onDeactivate();\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause(pauseOptions) {\n      if (!state.active) {\n        return this;\n      }\n      state.manuallyPaused = true;\n      return this._setPausedState(true, pauseOptions);\n    },\n    unpause: function unpause(unpauseOptions) {\n      if (!state.active) {\n        return this;\n      }\n      state.manuallyPaused = false;\n      if (trapStack[trapStack.length - 1] !== this) {\n        return this;\n      }\n      return this._setPausedState(false, unpauseOptions);\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (state.active) {\n        updateTabbableNodes();\n      }\n      updateObservedNodes();\n      return this;\n    }\n  };\n  Object.defineProperties(trap, {\n    _isManuallyPaused: {\n      value: function value() {\n        return state.manuallyPaused;\n      }\n    },\n    _setPausedState: {\n      value: function value(paused, options) {\n        if (state.paused === paused) {\n          return this;\n        }\n        state.paused = paused;\n        if (paused) {\n          var onPause = getOption(options, 'onPause');\n          var onPostPause = getOption(options, 'onPostPause');\n          onPause === null || onPause === void 0 || onPause();\n          removeListeners();\n          updateObservedNodes();\n          onPostPause === null || onPostPause === void 0 || onPostPause();\n        } else {\n          var onUnpause = getOption(options, 'onUnpause');\n          var onPostUnpause = getOption(options, 'onPostUnpause');\n          onUnpause === null || onUnpause === void 0 || onUnpause();\n          updateTabbableNodes();\n          addListeners();\n          updateObservedNodes();\n          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();\n        }\n        return this;\n      }\n    }\n  });\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","/**\n * A NodeIterator with iframes support and a method to check if an element is\n * matching a specified selector\n * @example\n * const iterator = new DOMIterator(\n *     document.querySelector(\"#context\"), true\n * );\n * iterator.forEachNode(NodeFilter.SHOW_TEXT, node => {\n *     console.log(node);\n * }, node => {\n *     if(DOMIterator.matches(node.parentNode, \".ignore\")){\n *         return NodeFilter.FILTER_REJECT;\n *     } else {\n *         return NodeFilter.FILTER_ACCEPT;\n *     }\n * }, () => {\n *     console.log(\"DONE\");\n * });\n * @todo Outsource into separate repository\n */\nexport default class DOMIterator {\n\n  /**\n   * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM\n   * element, an array of DOM elements, a NodeList or a selector\n   * @param {boolean} [iframes=true] - A boolean indicating if iframes should\n   * be handled\n   * @param {string[]} [exclude=[]] - An array containing exclusion selectors\n   * for iframes\n   * @param {number} [iframesTimeout=5000] - A number indicating the ms to\n   * wait before an iframe should be skipped, in case the load event isn't\n   * fired. This also applies if the user is offline and the resource of the\n   * iframe is online (either by the browsers \"offline\" mode or because\n   * there's no internet connection)\n   */\n  constructor(ctx, iframes = true, exclude = [], iframesTimeout = 5000) {\n    /**\n     * The context of the instance. Either a DOM element, an array of DOM\n     * elements, a NodeList or a selector\n     * @type {HTMLElement|HTMLElement[]|NodeList|string}\n     * @access protected\n     */\n    this.ctx = ctx;\n    /**\n     * Boolean indicating if iframe support is enabled\n     * @type {boolean}\n     * @access protected\n     */\n    this.iframes = iframes;\n    /**\n     * An array containing exclusion selectors for iframes\n     * @type {string[]}\n     */\n    this.exclude = exclude;\n    /**\n     * The maximum ms to wait for a load event before skipping an iframe\n     * @type {number}\n     */\n    this.iframesTimeout = iframesTimeout;\n  }\n\n  /**\n   * Checks if the specified DOM element matches the selector\n   * @param  {HTMLElement} element - The DOM element\n   * @param  {string|string[]} selector - The selector or an array with\n   * selectors\n   * @return {boolean}\n   * @access public\n   */\n  static matches(element, selector) {\n    const selectors = typeof selector === 'string' ? [selector] : selector,\n      fn = (\n        element.matches ||\n        element.matchesSelector ||\n        element.msMatchesSelector ||\n        element.mozMatchesSelector ||\n        element.oMatchesSelector ||\n        element.webkitMatchesSelector\n      );\n    if (fn) {\n      let match = false;\n      selectors.every(sel => {\n        if (fn.call(element, sel)) {\n          match = true;\n          return false;\n        }\n        return true;\n      });\n      return match;\n    } else { // may be false e.g. when el is a textNode\n      return false;\n    }\n  }\n\n  /**\n   * Returns all contexts filtered by duplicates (even nested)\n   * @return {HTMLElement[]} - An array containing DOM contexts\n   * @access protected\n   */\n  getContexts() {\n    let ctx,\n      filteredCtx = [];\n    if (typeof this.ctx === 'undefined' || !this.ctx) { // e.g. null\n      ctx = [];\n    } else if (NodeList.prototype.isPrototypeOf(this.ctx)) {\n      ctx = Array.prototype.slice.call(this.ctx);\n    } else if (Array.isArray(this.ctx)) {\n      ctx = this.ctx;\n    } else if (typeof this.ctx === 'string') {\n      ctx = Array.prototype.slice.call(\n        document.querySelectorAll(this.ctx)\n      );\n    } else { // e.g. HTMLElement or element inside iframe\n      ctx = [this.ctx];\n    }\n    // filter duplicate text nodes\n    ctx.forEach(ctx => {\n      const isDescendant = filteredCtx.filter(contexts => {\n        return contexts.contains(ctx);\n      }).length > 0;\n      if (filteredCtx.indexOf(ctx) === -1 && !isDescendant) {\n        filteredCtx.push(ctx);\n      }\n    });\n    return filteredCtx;\n  }\n\n  /**\n   * @callback DOMIterator~getIframeContentsSuccessCallback\n   * @param {HTMLDocument} contents - The contentDocument of the iframe\n   */\n  /**\n   * Calls the success callback function with the iframe document. If it can't\n   * be accessed it calls the error callback function\n   * @param {HTMLElement} ifr - The iframe DOM element\n   * @param {DOMIterator~getIframeContentsSuccessCallback} successFn\n   * @param {function} [errorFn]\n   * @access protected\n   */\n  getIframeContents(ifr, successFn, errorFn = () => {}) {\n    let doc;\n    try {\n      const ifrWin = ifr.contentWindow;\n      doc = ifrWin.document;\n      if (!ifrWin || !doc) { // no permission = null. Undefined in Phantom\n        throw new Error('iframe inaccessible');\n      }\n    } catch (e) {\n      errorFn();\n    }\n    if (doc) {\n      successFn(doc);\n    }\n  }\n\n  /**\n   * Checks if an iframe is empty (if about:blank is the shown page)\n   * @param {HTMLElement} ifr - The iframe DOM element\n   * @return {boolean}\n   * @access protected\n   */\n  isIframeBlank(ifr) {\n    const bl = 'about:blank',\n      src = ifr.getAttribute('src').trim(),\n      href = ifr.contentWindow.location.href;\n    return href === bl && src !== bl && src;\n  }\n\n  /**\n   * Observes the onload event of an iframe and calls the success callback or\n   * the error callback if the iframe is inaccessible. If the event isn't\n   * fired within the specified {@link DOMIterator#iframesTimeout}, then it'll\n   * call the error callback too\n   * @param {HTMLElement} ifr - The iframe DOM element\n   * @param {DOMIterator~getIframeContentsSuccessCallback} successFn\n   * @param {function} errorFn\n   * @access protected\n   */\n  observeIframeLoad(ifr, successFn, errorFn) {\n    let called = false,\n      tout = null;\n    const listener = () => {\n      if (called) {\n        return;\n      }\n      called = true;\n      clearTimeout(tout);\n      try {\n        if (!this.isIframeBlank(ifr)) {\n          ifr.removeEventListener('load', listener);\n          this.getIframeContents(ifr, successFn, errorFn);\n        }\n      } catch (e) { // isIframeBlank maybe throws throws an error\n        errorFn();\n      }\n    };\n    ifr.addEventListener('load', listener);\n    tout = setTimeout(listener, this.iframesTimeout);\n  }\n\n  /**\n   * Callback when the iframe is ready\n   * @callback DOMIterator~onIframeReadySuccessCallback\n   * @param {HTMLDocument} contents - The contentDocument of the iframe\n   */\n  /**\n   * Callback if the iframe can't be accessed\n   * @callback DOMIterator~onIframeReadyErrorCallback\n   */\n  /**\n   * Calls the callback if the specified iframe is ready for DOM access\n   * @param  {HTMLElement} ifr - The iframe DOM element\n   * @param  {DOMIterator~onIframeReadySuccessCallback} successFn - Success\n   * callback\n   * @param {DOMIterator~onIframeReadyErrorCallback} errorFn - Error callback\n   * @see {@link http://stackoverflow.com/a/36155560/3894981} for\n   * background information\n   * @access protected\n   */\n  onIframeReady(ifr, successFn, errorFn) {\n    try {\n      if (ifr.contentWindow.document.readyState === 'complete') {\n        if (this.isIframeBlank(ifr)) {\n          this.observeIframeLoad(ifr, successFn, errorFn);\n        } else {\n          this.getIframeContents(ifr, successFn, errorFn);\n        }\n      } else {\n        this.observeIframeLoad(ifr, successFn, errorFn);\n      }\n    } catch (e) { // accessing document failed\n      errorFn();\n    }\n  }\n\n  /**\n   * Callback when all iframes are ready for DOM access\n   * @callback DOMIterator~waitForIframesDoneCallback\n   */\n  /**\n   * Iterates over all iframes and calls the done callback when all of them\n   * are ready for DOM access (including nested ones)\n   * @param {HTMLElement} ctx - The context DOM element\n   * @param {DOMIterator~waitForIframesDoneCallback} done - Done callback\n   */\n  waitForIframes(ctx, done) {\n    let eachCalled = 0;\n    this.forEachIframe(ctx, () => true, ifr => {\n      eachCalled++;\n      this.waitForIframes(ifr.querySelector('html'), () => {\n        if (!(--eachCalled)) {\n          done();\n        }\n      });\n    }, handled => {\n      if (!handled) {\n        done();\n      }\n    });\n  }\n\n  /**\n   * Callback allowing to filter an iframe. Must return true when the element\n   * should remain, otherwise false\n   * @callback DOMIterator~forEachIframeFilterCallback\n   * @param {HTMLElement} iframe - The iframe DOM element\n   */\n  /**\n   * Callback for each iframe content\n   * @callback DOMIterator~forEachIframeEachCallback\n   * @param {HTMLElement} content - The iframe document\n   */\n  /**\n   * Callback if all iframes inside the context were handled\n   * @callback DOMIterator~forEachIframeEndCallback\n   * @param {number} handled - The number of handled iframes (those who\n   * wheren't filtered)\n   */\n  /**\n   * Iterates over all iframes inside the specified context and calls the\n   * callbacks when they're ready. Filters iframes based on the instance\n   * exclusion selectors\n   * @param {HTMLElement} ctx - The context DOM element\n   * @param {DOMIterator~forEachIframeFilterCallback} filter - Filter callback\n   * @param {DOMIterator~forEachIframeEachCallback} each - Each callback\n   * @param {DOMIterator~forEachIframeEndCallback} [end] - End callback\n   * @access protected\n   */\n  forEachIframe(ctx, filter, each, end = () => {}) {\n    let ifr = ctx.querySelectorAll('iframe'),\n      open = ifr.length,\n      handled = 0;\n    ifr = Array.prototype.slice.call(ifr);\n    const checkEnd = () => {\n      if (--open <= 0) {\n        end(handled);\n      }\n    };\n    if (!open) {\n      checkEnd();\n    }\n    ifr.forEach(ifr => {\n      if (DOMIterator.matches(ifr, this.exclude)) {\n        checkEnd();\n      } else {\n        this.onIframeReady(ifr, con => {\n          if (filter(ifr)) {\n            handled++;\n            each(con);\n          }\n          checkEnd();\n        }, checkEnd);\n      }\n    });\n  }\n\n  /**\n   * Creates a NodeIterator on the specified context\n   * @see {@link https://developer.mozilla.org/en/docs/Web/API/NodeIterator}\n   * @param {HTMLElement} ctx - The context DOM element\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param {DOMIterator~filterCb} filter\n   * @return {NodeIterator}\n   * @access protected\n   */\n  createIterator(ctx, whatToShow, filter) {\n    return document.createNodeIterator(ctx, whatToShow, filter, false);\n  }\n\n  /**\n   * Creates an instance of DOMIterator in an iframe\n   * @param {HTMLDocument} contents - Iframe document\n   * @return {DOMIterator}\n   * @access protected\n   */\n  createInstanceOnIframe(contents) {\n    return new DOMIterator(contents.querySelector('html'), this.iframes);\n  }\n\n  /**\n   * Checks if an iframe occurs between two nodes, more specifically if an\n   * iframe occurs before the specified node and after the specified prevNode\n   * @param {HTMLElement} node - The node that should occur after the iframe\n   * @param {HTMLElement} prevNode - The node that should occur before the\n   * iframe\n   * @param {HTMLElement} ifr - The iframe to check against\n   * @return {boolean}\n   * @access protected\n   */\n  compareNodeIframe(node, prevNode, ifr) {\n    const compCurr = node.compareDocumentPosition(ifr),\n      prev = Node.DOCUMENT_POSITION_PRECEDING;\n    if (compCurr & prev) {\n      if (prevNode !== null) {\n        const compPrev = prevNode.compareDocumentPosition(ifr),\n          after = Node.DOCUMENT_POSITION_FOLLOWING;\n        if (compPrev & after) {\n          return true;\n        }\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @typedef {DOMIterator~getIteratorNodeReturn}\n   * @type {object.<string>}\n   * @property {HTMLElement} prevNode - The previous node or null if there is\n   * no\n   * @property {HTMLElement} node - The current node\n   */\n  /**\n   * Returns the previous and current node of the specified iterator\n   * @param {NodeIterator} itr - The iterator\n   * @return {DOMIterator~getIteratorNodeReturn}\n   * @access protected\n   */\n  getIteratorNode(itr) {\n    const prevNode = itr.previousNode();\n    let node;\n    if (prevNode === null) {\n      node = itr.nextNode();\n    } else {\n      node = itr.nextNode() && itr.nextNode();\n    }\n    return {\n      prevNode,\n      node\n    };\n  }\n\n  /**\n   * An array containing objects. The object key \"val\" contains an iframe\n   * DOM element. The object key \"handled\" contains a boolean indicating if\n   * the iframe was handled already.\n   * It wouldn't be enough to save all open or all already handled iframes.\n   * The information of open iframes is necessary because they may occur after\n   * all other text nodes (and compareNodeIframe would never be true). The\n   * information of already handled iframes is necessary as otherwise they may\n   * be handled multiple times\n   * @typedef DOMIterator~checkIframeFilterIfr\n   * @type {object[]}\n   */\n  /**\n   * Checks if an iframe wasn't handled already and if so, calls\n   * {@link DOMIterator#compareNodeIframe} to check if it should be handled.\n   * Information wheter an iframe was or wasn't handled is given within the\n   * <code>ifr</code> dictionary\n   * @param {HTMLElement} node - The node that should occur after the iframe\n   * @param {HTMLElement} prevNode - The node that should occur before the\n   * iframe\n   * @param {HTMLElement} currIfr - The iframe to check\n   * @param {DOMIterator~checkIframeFilterIfr} ifr - The iframe dictionary.\n   * Will be manipulated (by reference)\n   * @return {boolean} Returns true when it should be handled, otherwise false\n   * @access protected\n   */\n  checkIframeFilter(node, prevNode, currIfr, ifr) {\n    let key = false, // false === doesn't exist\n      handled = false;\n    ifr.forEach((ifrDict, i) => {\n      if (ifrDict.val === currIfr) {\n        key = i;\n        handled = ifrDict.handled;\n      }\n    });\n    if (this.compareNodeIframe(node, prevNode, currIfr)) {\n      if (key === false && !handled) {\n        ifr.push({\n          val: currIfr,\n          handled: true\n        });\n      } else if (key !== false && !handled) {\n        ifr[key].handled = true;\n      }\n      return true;\n    }\n    if (key === false) {\n      ifr.push({\n        val: currIfr,\n        handled: false\n      });\n    }\n    return false;\n  }\n\n  /**\n   * Creates an iterator on all open iframes in the specified array and calls\n   * the end callback when finished\n   * @param {DOMIterator~checkIframeFilterIfr} ifr\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param  {DOMIterator~forEachNodeCallback} eCb - Each callback\n   * @param {DOMIterator~filterCb} fCb\n   * @access protected\n   */\n  handleOpenIframes(ifr, whatToShow, eCb, fCb) {\n    ifr.forEach(ifrDict => {\n      if (!ifrDict.handled) {\n        this.getIframeContents(ifrDict.val, con => {\n          this.createInstanceOnIframe(con).forEachNode(\n            whatToShow, eCb, fCb\n          );\n        });\n      }\n    });\n  }\n\n  /**\n   * Iterates through all nodes in the specified context and handles iframe\n   * nodes at the correct position\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param {HTMLElement} ctx - The context\n   * @param  {DOMIterator~forEachNodeCallback} eachCb - Each callback\n   * @param {DOMIterator~filterCb} filterCb - Filter callback\n   * @param {DOMIterator~forEachNodeEndCallback} doneCb - End callback\n   * @access protected\n   */\n  iterateThroughNodes(whatToShow, ctx, eachCb, filterCb, doneCb) {\n    const itr = this.createIterator(ctx, whatToShow, filterCb);\n    let ifr = [],\n      elements = [],\n      node, prevNode, retrieveNodes = () => {\n        ({\n          prevNode,\n          node\n        } = this.getIteratorNode(itr));\n        return node;\n      };\n    while (retrieveNodes()) {\n      if (this.iframes) {\n        this.forEachIframe(ctx, currIfr => {\n          // note that ifr will be manipulated here\n          return this.checkIframeFilter(node, prevNode, currIfr, ifr);\n        }, con => {\n          this.createInstanceOnIframe(con).forEachNode(\n            whatToShow, ifrNode => elements.push(ifrNode), filterCb\n          );\n        });\n      }\n      // it's faster to call the each callback in an array loop\n      // than in this while loop\n      elements.push(node);\n    }\n    elements.forEach(node => {\n      eachCb(node);\n    });\n    if (this.iframes) {\n      this.handleOpenIframes(ifr, whatToShow, eachCb, filterCb);\n    }\n    doneCb();\n  }\n\n  /**\n   * Callback for each node\n   * @callback DOMIterator~forEachNodeCallback\n   * @param {HTMLElement} node - The DOM text node element\n   */\n  /**\n   * Callback if all contexts were handled\n   * @callback DOMIterator~forEachNodeEndCallback\n   */\n  /**\n   * Iterates over all contexts and initializes\n   * {@link DOMIterator#iterateThroughNodes iterateThroughNodes} on them\n   * @param {DOMIterator~whatToShow} whatToShow\n   * @param  {DOMIterator~forEachNodeCallback} each - Each callback\n   * @param {DOMIterator~filterCb} filter - Filter callback\n   * @param {DOMIterator~forEachNodeEndCallback} done - End callback\n   * @access public\n   */\n  forEachNode(whatToShow, each, filter, done = () => {}) {\n    const contexts = this.getContexts();\n    let open = contexts.length;\n    if (!open) {\n      done();\n    }\n    contexts.forEach(ctx => {\n      const ready = () => {\n        this.iterateThroughNodes(whatToShow, ctx, each, filter, () => {\n          if (--open <= 0) { // call end all contexts were handled\n            done();\n          }\n        });\n      };\n      // wait for iframes to avoid recursive calls, otherwise this would\n      // perhaps reach the recursive function call limit with many nodes\n      if (this.iframes) {\n        this.waitForIframes(ctx, ready);\n      } else {\n        ready();\n      }\n    });\n  }\n\n  /**\n   * Callback to filter nodes. Can return e.g. NodeFilter.FILTER_ACCEPT or\n   * NodeFilter.FILTER_REJECT\n   * @see {@link http://tinyurl.com/zdczmm2}\n   * @callback DOMIterator~filterCb\n   * @param {HTMLElement} node - The node to filter\n   */\n  /**\n   * @typedef DOMIterator~whatToShow\n   * @see {@link http://tinyurl.com/zfqqkx2}\n   * @type {number}\n   */\n}\n","import DOMIterator from './domiterator';\n\n/**\n * Marks search terms in DOM elements\n * @example\n * new Mark(document.querySelector(\".context\")).mark(\"lorem ipsum\");\n * @example\n * new Mark(document.querySelector(\".context\")).markRegExp(/lorem/gmi);\n */\nexport default class Mark { // eslint-disable-line no-unused-vars\n\n  /**\n   * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM\n   * element, an array of DOM elements, a NodeList or a selector\n   */\n  constructor(ctx) {\n    /**\n     * The context of the instance. Either a DOM element, an array of DOM\n     * elements, a NodeList or a selector\n     * @type {HTMLElement|HTMLElement[]|NodeList|string}\n     * @access protected\n     */\n    this.ctx = ctx;\n    /**\n     * Specifies if the current browser is a IE (necessary for the node\n     * normalization bug workaround). See {@link Mark#unwrapMatches}\n     * @type {boolean}\n     * @access protected\n     */\n    this.ie = false;\n    const ua = window.navigator.userAgent;\n    if (ua.indexOf('MSIE') > -1 || ua.indexOf('Trident') > -1) {\n      this.ie = true;\n    }\n  }\n\n  /**\n   * Options defined by the user. They will be initialized from one of the\n   * public methods. See {@link Mark#mark}, {@link Mark#markRegExp},\n   * {@link Mark#markRanges} and {@link Mark#unmark} for option properties.\n   * @type {object}\n   * @param {object} [val] - An object that will be merged with defaults\n   * @access protected\n   */\n  set opt(val) {\n    this._opt = Object.assign({}, {\n      'element': '',\n      'className': '',\n      'exclude': [],\n      'iframes': false,\n      'iframesTimeout': 5000,\n      'separateWordSearch': true,\n      'diacritics': true,\n      'synonyms': {},\n      'accuracy': 'partially',\n      'acrossElements': false,\n      'caseSensitive': false,\n      'ignoreJoiners': false,\n      'ignoreGroups': 0,\n      'ignorePunctuation': [],\n      'wildcards': 'disabled',\n      'each': () => {},\n      'noMatch': () => {},\n      'filter': () => true,\n      'done': () => {},\n      'debug': false,\n      'log': window.console\n    }, val);\n  }\n\n  get opt() {\n    return this._opt;\n  }\n\n  /**\n   * An instance of DOMIterator\n   * @type {DOMIterator}\n   * @access protected\n   */\n  get iterator() {\n    // always return new instance in case there were option changes\n    return new DOMIterator(\n      this.ctx,\n      this.opt.iframes,\n      this.opt.exclude,\n      this.opt.iframesTimeout\n    );\n  }\n\n  /**\n   * Logs a message if log is enabled\n   * @param {string} msg - The message to log\n   * @param {string} [level=\"debug\"] - The log level, e.g. <code>warn</code>\n   * <code>error</code>, <code>debug</code>\n   * @access protected\n   */\n  log(msg, level = 'debug') {\n    const log = this.opt.log;\n    if (!this.opt.debug) {\n      return;\n    }\n    if (typeof log === 'object' && typeof log[level] === 'function') {\n      log[level](`mark.js: ${msg}`);\n    }\n  }\n\n  /**\n   * Escapes a string for usage within a regular expression\n   * @param {string} str - The string to escape\n   * @return {string}\n   * @access protected\n   */\n  escapeStr(str) {\n    // eslint-disable-next-line no-useless-escape\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n  }\n\n  /**\n   * Creates a regular expression string to match the specified search\n   * term including synonyms, diacritics and accuracy if defined\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createRegExp(str) {\n    if (this.opt.wildcards !== 'disabled') {\n      str = this.setupWildcardsRegExp(str);\n    }\n    str = this.escapeStr(str);\n    if (Object.keys(this.opt.synonyms).length) {\n      str = this.createSynonymsRegExp(str);\n    }\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n      str = this.setupIgnoreJoinersRegExp(str);\n    }\n    if (this.opt.diacritics) {\n      str = this.createDiacriticsRegExp(str);\n    }\n    str = this.createMergedBlanksRegExp(str);\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n      str = this.createJoinersRegExp(str);\n    }\n    if (this.opt.wildcards !== 'disabled') {\n      str = this.createWildcardsRegExp(str);\n    }\n    str = this.createAccuracyRegExp(str);\n    return str;\n  }\n\n  /**\n   * Creates a regular expression string to match the defined synonyms\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createSynonymsRegExp(str) {\n    const syn = this.opt.synonyms,\n      sens = this.opt.caseSensitive ? '' : 'i',\n      // add replacement character placeholder before and after the\n      // synonym group\n      joinerPlaceholder = this.opt.ignoreJoiners ||\n                this.opt.ignorePunctuation.length ? '\\u0000' : '';\n    for (let index in syn) {\n      if (syn.hasOwnProperty(index)) {\n        const value = syn[index],\n          k1 = this.opt.wildcards !== 'disabled' ?\n            this.setupWildcardsRegExp(index) :\n            this.escapeStr(index),\n          k2 = this.opt.wildcards !== 'disabled' ?\n            this.setupWildcardsRegExp(value) :\n            this.escapeStr(value);\n        if (k1 !== '' && k2 !== '') {\n          str = str.replace(\n            new RegExp(\n              `(${this.escapeStr(k1)}|${this.escapeStr(k2)})`,\n              `gm${sens}`\n            ),\n            joinerPlaceholder +\n            `(${this.processSynomyms(k1)}|` +\n            `${this.processSynomyms(k2)})` +\n            joinerPlaceholder\n          );\n        }\n      }\n    }\n    return str;\n  }\n\n  /**\n   * Setup synonyms to work with ignoreJoiners and or ignorePunctuation\n   * @param {string} str - synonym key or value to process\n   * @return {string} - processed synonym string\n   */\n  processSynomyms(str) {\n    if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\n      str = this.setupIgnoreJoinersRegExp(str);\n    }\n    return str;\n  }\n\n  /**\n   * Sets up the regular expression string to allow later insertion of\n   * wildcard regular expression matches\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  setupWildcardsRegExp(str) {\n    // replace single character wildcard with unicode 0001\n    str = str.replace(/(?:\\\\)*\\?/g, val => {\n      return val.charAt(0) === '\\\\' ? '?' : '\\u0001';\n    });\n    // replace multiple character wildcard with unicode 0002\n    return str.replace(/(?:\\\\)*\\*/g, val => {\n      return val.charAt(0) === '\\\\' ? '*' : '\\u0002';\n    });\n  }\n\n  /**\n   * Sets up the regular expression string to allow later insertion of\n   * wildcard regular expression matches\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createWildcardsRegExp(str) {\n    // default to \"enable\" (i.e. to not include spaces)\n    // \"withSpaces\" uses `[\\\\S\\\\s]` instead of `.` because the latter\n    // does not match new line characters\n    let spaces = this.opt.wildcards === 'withSpaces';\n    return str\n    // replace unicode 0001 with a RegExp class to match any single\n    // character, or any single non-whitespace character depending\n    // on the setting\n      .replace(/\\u0001/g, spaces ? '[\\\\S\\\\s]?' : '\\\\S?')\n    // replace unicode 0002 with a RegExp class to match zero or\n    // more characters, or zero or more non-whitespace characters\n    // depending on the setting\n      .replace(/\\u0002/g, spaces ? '[\\\\S\\\\s]*?' : '\\\\S*');\n  }\n\n  /**\n   * Sets up the regular expression string to allow later insertion of\n   * designated characters (soft hyphens & zero width characters)\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  setupIgnoreJoinersRegExp(str) {\n    // adding a \"null\" unicode character as it will not be modified by the\n    // other \"create\" regular expression functions\n    return str.replace(/[^(|)\\\\]/g, (val, indx, original) => {\n      // don't add a null after an opening \"(\", around a \"|\" or before\n      // a closing \"(\", or between an escapement (e.g. \\+)\n      let nextChar = original.charAt(indx + 1);\n      if (/[(|)\\\\]/.test(nextChar) || nextChar === '') {\n        return val;\n      } else {\n        return val + '\\u0000';\n      }\n    });\n  }\n\n  /**\n   * Creates a regular expression string to allow ignoring of designated\n   * characters (soft hyphens, zero width characters & punctuation) based on\n   * the specified option values of <code>ignorePunctuation</code> and\n   * <code>ignoreJoiners</code>\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createJoinersRegExp(str) {\n    let joiner = [];\n    const ignorePunctuation = this.opt.ignorePunctuation;\n    if (Array.isArray(ignorePunctuation) && ignorePunctuation.length) {\n      joiner.push(this.escapeStr(ignorePunctuation.join('')));\n    }\n    if (this.opt.ignoreJoiners) {\n      // u+00ad = soft hyphen\n      // u+200b = zero-width space\n      // u+200c = zero-width non-joiner\n      // u+200d = zero-width joiner\n      joiner.push('\\\\u00ad\\\\u200b\\\\u200c\\\\u200d');\n    }\n    return joiner.length ?\n      str.split(/\\u0000+/).join(`[${joiner.join('')}]*`) :\n      str;\n  }\n\n  /**\n   * Creates a regular expression string to match diacritics\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createDiacriticsRegExp(str) {\n    const sens = this.opt.caseSensitive ? '' : 'i',\n      dct = this.opt.caseSensitive ? [\n        'aàáảãạăằắẳẵặâầấẩẫậäåāą', 'AÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ',\n        'cçćč', 'CÇĆČ', 'dđď', 'DĐĎ',\n        'eèéẻẽẹêềếểễệëěēę', 'EÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ',\n        'iìíỉĩịîïī', 'IÌÍỈĨỊÎÏĪ', 'lł', 'LŁ', 'nñňń',\n        'NÑŇŃ', 'oòóỏõọôồốổỗộơởỡớờợöøō', 'OÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ',\n        'rř', 'RŘ', 'sšśșş', 'SŠŚȘŞ',\n        'tťțţ', 'TŤȚŢ', 'uùúủũụưừứửữựûüůū', 'UÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ',\n        'yýỳỷỹỵÿ', 'YÝỲỶỸỴŸ', 'zžżź', 'ZŽŻŹ'\n      ] : [\n        'aàáảãạăằắẳẵặâầấẩẫậäåāąAÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ', 'cçćčCÇĆČ',\n        'dđďDĐĎ', 'eèéẻẽẹêềếểễệëěēęEÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ',\n        'iìíỉĩịîïīIÌÍỈĨỊÎÏĪ', 'lłLŁ', 'nñňńNÑŇŃ',\n        'oòóỏõọôồốổỗộơởỡớờợöøōOÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ', 'rřRŘ',\n        'sšśșşSŠŚȘŞ', 'tťțţTŤȚŢ',\n        'uùúủũụưừứửữựûüůūUÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ', 'yýỳỷỹỵÿYÝỲỶỸỴŸ', 'zžżźZŽŻŹ'\n      ];\n    let handled = [];\n    str.split('').forEach(ch => {\n      dct.every(dct => {\n        // Check if the character is inside a diacritics list\n        if (dct.indexOf(ch) !== -1) {\n          // Check if the related diacritics list was not\n          // handled yet\n          if (handled.indexOf(dct) > -1) {\n            return false;\n          }\n          // Make sure that the character OR any other\n          // character in the diacritics list will be matched\n          str = str.replace(\n            new RegExp(`[${dct}]`, `gm${sens}`), `[${dct}]`\n          );\n          handled.push(dct);\n        }\n        return true;\n      });\n    });\n    return str;\n  }\n\n  /**\n   * Creates a regular expression string that merges whitespace characters\n   * including subsequent ones into a single pattern, one or multiple\n   * whitespaces\n   * @param  {string} str - The search term to be used\n   * @return {string}\n   * @access protected\n   */\n  createMergedBlanksRegExp(str) {\n    return str.replace(/[\\s]+/gmi, '[\\\\s]+');\n  }\n\n  /**\n   * Creates a regular expression string to match the specified string with\n   * the defined accuracy. As in the regular expression of \"exactly\" can be\n   * a group containing a blank at the beginning, all regular expressions will\n   * be created with two groups. The first group can be ignored (may contain\n   * the said blank), the second contains the actual match\n   * @param  {string} str - The searm term to be used\n   * @return {str}\n   * @access protected\n   */\n  createAccuracyRegExp(str) {\n    const chars = '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~¡¿';\n    let acc = this.opt.accuracy,\n      val = typeof acc === 'string' ? acc : acc.value,\n      ls = typeof acc === 'string' ? [] : acc.limiters,\n      lsJoin = '';\n    ls.forEach(limiter => {\n      lsJoin += `|${this.escapeStr(limiter)}`;\n    });\n    switch (val) {\n    case 'partially':\n    default:\n      return `()(${str})`;\n    case 'complementary':\n      lsJoin = '\\\\s' + (lsJoin ? lsJoin : this.escapeStr(chars));\n      return `()([^${lsJoin}]*${str}[^${lsJoin}]*)`;\n    case 'exactly':\n      return `(^|\\\\s${lsJoin})(${str})(?=$|\\\\s${lsJoin})`;\n    }\n  }\n\n  /**\n   * @typedef Mark~separatedKeywords\n   * @type {object.<string>}\n   * @property {array.<string>} keywords - The list of keywords\n   * @property {number} length - The length\n   */\n  /**\n   * Returns a list of keywords dependent on whether separate word search\n   * was defined. Also it filters empty keywords\n   * @param {array} sv - The array of keywords\n   * @return {Mark~separatedKeywords}\n   * @access protected\n   */\n  getSeparatedKeywords(sv) {\n    let stack = [];\n    sv.forEach(kw => {\n      if (!this.opt.separateWordSearch) {\n        if (kw.trim() && stack.indexOf(kw) === -1) {\n          stack.push(kw);\n        }\n      } else {\n        kw.split(' ').forEach(kwSplitted => {\n          if (kwSplitted.trim() && stack.indexOf(kwSplitted) === -1) {\n            stack.push(kwSplitted);\n          }\n        });\n      }\n    });\n    return {\n      // sort because of https://git.io/v6USg\n      'keywords': stack.sort((a, b) => {\n        return b.length - a.length;\n      }),\n      'length': stack.length\n    };\n  }\n\n  /**\n   * Check if a value is a number\n   * @param {number|string} value - the value to check;\n   * numeric strings allowed\n   * @return {boolean}\n   * @access protected\n   */\n  isNumeric(value) {\n    // http://stackoverflow.com/a/16655847/145346\n    // eslint-disable-next-line eqeqeq\n    return Number(parseFloat(value)) == value;\n  }\n\n  /**\n   * @typedef Mark~rangeObject\n   * @type {object}\n   * @property {number} start - The start position within the composite value\n   * @property {number} length - The length of the string to mark within the\n   * composite value.\n   */\n  /**\n   * @typedef Mark~setOfRanges\n   * @type {object[]}\n   * @property {Mark~rangeObject}\n   */\n  /**\n   * Returns a processed list of integer offset indexes that do not overlap\n   * each other, and remove any string values or additional elements\n   * @param {Mark~setOfRanges} array - unprocessed raw array\n   * @return {Mark~setOfRanges} - processed array with any invalid entries\n   * removed\n   * @throws Will throw an error if an array of objects is not passed\n   * @access protected\n   */\n  checkRanges(array) {\n    // start and length indexes are included in an array of objects\n    // [{start: 0, length: 1}, {start: 4, length: 5}]\n    // quick validity check of the first entry only\n    if (\n      !Array.isArray(array) ||\n      Object.prototype.toString.call( array[0] ) !== '[object Object]'\n    ) {\n      this.log('markRanges() will only accept an array of objects');\n      this.opt.noMatch(array);\n      return [];\n    }\n    const stack = [];\n    let last = 0;\n    array\n    // acending sort to ensure there is no overlap in start & end\n    // offsets\n      .sort((a, b) => {\n        return a.start - b.start;\n      })\n      .forEach(item => {\n        let {start, end, valid} = this.callNoMatchOnInvalidRanges(item, last);\n        if (valid) {\n          // preserve item in case there are extra key:values within\n          item.start = start;\n          item.length = end - start;\n          stack.push(item);\n          last = end;\n        }\n      });\n    return stack;\n  }\n\n  /**\n   * @typedef Mark~validObject\n   * @type {object}\n   * @property {number} start - The start position within the composite value\n   * @property {number} end - The calculated end position within the composite\n   * value.\n   * @property {boolean} valid - boolean value indicating that the start and\n   * calculated end range is valid\n   */\n  /**\n    * Initial validation of ranges for markRanges. Preliminary checks are done\n    * to ensure the start and length values exist and are not zero or non-\n    * numeric\n    * @param {Mark~rangeObject} range - the current range object\n    * @param {number} last - last index of range\n    * @return {Mark~validObject}\n    * @access protected\n    */\n  callNoMatchOnInvalidRanges(range, last) {\n    let start, end,\n      valid = false;\n    if (range && typeof range.start !== 'undefined') {\n      start = parseInt(range.start, 10);\n      end = start + parseInt(range.length, 10);\n      // ignore overlapping values & non-numeric entries\n      if (\n        this.isNumeric(range.start) &&\n        this.isNumeric(range.length) &&\n        end - last > 0 &&\n        end - start > 0\n      ) {\n        valid = true;\n      } else {\n        this.log(\n          'Ignoring invalid or overlapping range: ' +\n                    `${JSON.stringify(range)}`\n        );\n        this.opt.noMatch(range);\n      }\n    } else {\n      this.log(`Ignoring invalid range: ${JSON.stringify(range)}`);\n      this.opt.noMatch(range);\n    }\n    return {\n      start: start,\n      end: end,\n      valid: valid\n    };\n  }\n\n  /**\n   * Check valid range for markRanges. Check ranges with access to the context\n   * string. Range values are double checked, lengths that extend the mark\n   * beyond the string length are limitied and ranges containing only\n   * whitespace are ignored\n   * @param {Mark~rangeObject} range - the current range object\n   * @param {number} originalLength - original length of the context string\n   * @param {string} string - current content string\n   * @return {Mark~validObject}\n   * @access protected\n   */\n  checkWhitespaceRanges(range, originalLength, string) {\n    let end,\n      valid = true,\n      // the max value changes after the DOM is manipulated\n      max = string.length,\n      // adjust offset to account for wrapped text node\n      offset = originalLength - max,\n      start = parseInt(range.start, 10) - offset;\n    // make sure to stop at max\n    start = start > max ? max : start;\n    end = start + parseInt(range.length, 10);\n    if (end > max) {\n      end = max;\n      this.log(`End range automatically set to the max value of ${max}`);\n    }\n    if (start < 0 || end - start < 0 || start > max || end > max) {\n      valid = false;\n      this.log(`Invalid range: ${JSON.stringify(range)}`);\n      this.opt.noMatch(range);\n    } else if (string.substring(start, end).replace(/\\s+/g, '') === '') {\n      valid = false;\n      // whitespace only; even if wrapped it is not visible\n      this.log('Skipping whitespace only range: ' +JSON.stringify(range));\n      this.opt.noMatch(range);\n    }\n    return {\n      start: start,\n      end: end,\n      valid: valid\n    };\n  }\n\n  /**\n   * @typedef Mark~getTextNodesDict\n   * @type {object.<string>}\n   * @property {string} value - The composite value of all text nodes\n   * @property {object[]} nodes - An array of objects\n   * @property {number} nodes.start - The start position within the composite\n   * value\n   * @property {number} nodes.end - The end position within the composite\n   * value\n   * @property {HTMLElement} nodes.node - The DOM text node element\n   */\n  /**\n   * Callback\n   * @callback Mark~getTextNodesCallback\n   * @param {Mark~getTextNodesDict}\n   */\n  /**\n   * Calls the callback with an object containing all text nodes (including\n   * iframe text nodes) with start and end positions and the composite value\n   * of them (string)\n   * @param {Mark~getTextNodesCallback} cb - Callback\n   * @access protected\n   */\n  getTextNodes(cb) {\n    let val = '',\n      nodes = [];\n    this.iterator.forEachNode(NodeFilter.SHOW_TEXT, node => {\n      nodes.push({\n        start: val.length,\n        end: (val += node.textContent).length,\n        node\n      });\n    }, node => {\n      if (this.matchesExclude(node.parentNode)) {\n        return NodeFilter.FILTER_REJECT;\n      } else {\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }, () => {\n      cb({\n        value: val,\n        nodes: nodes\n      });\n    });\n  }\n\n  /**\n   * Checks if an element matches any of the specified exclude selectors. Also\n   * it checks for elements in which no marks should be performed (e.g.\n   * script and style tags) and optionally already marked elements\n   * @param  {HTMLElement} el - The element to check\n   * @return {boolean}\n   * @access protected\n   */\n  matchesExclude(el) {\n    return DOMIterator.matches(el, this.opt.exclude.concat([\n      // ignores the elements itself, not their childrens (selector *)\n      'script', 'style', 'title', 'head', 'html'\n    ]));\n  }\n\n  /**\n   * Wraps the instance element and class around matches that fit the start\n   * and end positions within the node\n   * @param  {HTMLElement} node - The DOM text node\n   * @param  {number} start - The position where to start wrapping\n   * @param  {number} end - The position where to end wrapping\n   * @return {HTMLElement} Returns the splitted text node that will appear\n   * after the wrapped text node\n   * @access protected\n   */\n  wrapRangeInTextNode(node, start, end) {\n    const hEl = !this.opt.element ? 'mark' : this.opt.element,\n      startNode = node.splitText(start),\n      ret = startNode.splitText(end - start);\n    let repl = document.createElement(hEl);\n    repl.setAttribute('data-markjs', 'true');\n    if (this.opt.className) {\n      repl.setAttribute('class', this.opt.className);\n    }\n    repl.textContent = startNode.textContent;\n    startNode.parentNode.replaceChild(repl, startNode);\n    return ret;\n  }\n\n  /**\n   * @typedef Mark~wrapRangeInMappedTextNodeDict\n   * @type {object.<string>}\n   * @property {string} value - The composite value of all text nodes\n   * @property {object[]} nodes - An array of objects\n   * @property {number} nodes.start - The start position within the composite\n   * value\n   * @property {number} nodes.end - The end position within the composite\n   * value\n   * @property {HTMLElement} nodes.node - The DOM text node element\n   */\n  /**\n   * Each callback\n   * @callback Mark~wrapMatchesEachCallback\n   * @param {HTMLElement} node - The wrapped DOM element\n   * @param {number} lastIndex - The last matching position within the\n   * composite value of text nodes\n   */\n  /**\n   * Filter callback\n   * @callback Mark~wrapMatchesFilterCallback\n   * @param {HTMLElement} node - The matching text node DOM element\n   */\n  /**\n   * Determines matches by start and end positions using the text node\n   * dictionary even across text nodes and calls\n   * {@link Mark#wrapRangeInTextNode} to wrap them\n   * @param  {Mark~wrapRangeInMappedTextNodeDict} dict - The dictionary\n   * @param  {number} start - The start position of the match\n   * @param  {number} end - The end position of the match\n   * @param  {Mark~wrapMatchesFilterCallback} filterCb - Filter callback\n   * @param  {Mark~wrapMatchesEachCallback} eachCb - Each callback\n   * @access protected\n   */\n  wrapRangeInMappedTextNode(dict, start, end, filterCb, eachCb) {\n    // iterate over all text nodes to find the one matching the positions\n    dict.nodes.every((n, i) => {\n      const sibl = dict.nodes[i + 1];\n      if (typeof sibl === 'undefined' || sibl.start > start) {\n        if (!filterCb(n.node)) {\n          return false;\n        }\n        // map range from dict.value to text node\n        const s = start - n.start,\n          e = (end > n.end ? n.end : end) - n.start,\n          startStr = dict.value.substr(0, n.start),\n          endStr = dict.value.substr(e + n.start);\n        n.node = this.wrapRangeInTextNode(n.node, s, e);\n        // recalculate positions to also find subsequent matches in the\n        // same text node. Necessary as the text node in dict now only\n        // contains the splitted part after the wrapped one\n        dict.value = startStr + endStr;\n        dict.nodes.forEach((k, j) => {\n          if (j >= i) {\n            if (dict.nodes[j].start > 0 && j !== i) {\n              dict.nodes[j].start -= e;\n            }\n            dict.nodes[j].end -= e;\n          }\n        });\n        end -= e;\n        eachCb(n.node.previousSibling, n.start);\n        if (end > n.end) {\n          start = n.end;\n        } else {\n          return false;\n        }\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Filter callback before each wrapping\n   * @callback Mark~wrapMatchesFilterCallback\n   * @param {string} match - The matching string\n   * @param {HTMLElement} node - The text node where the match occurs\n   */\n  /**\n   * Callback for each wrapped element\n   * @callback Mark~wrapMatchesEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Callback on end\n   * @callback Mark~wrapMatchesEndCallback\n   */\n  /**\n   * Wraps the instance element and class around matches within single HTML\n   * elements in all contexts\n   * @param {RegExp} regex - The regular expression to be searched for\n   * @param {number} ignoreGroups - A number indicating the amount of RegExp\n   * matching groups to ignore\n   * @param {Mark~wrapMatchesFilterCallback} filterCb\n   * @param {Mark~wrapMatchesEachCallback} eachCb\n   * @param {Mark~wrapMatchesEndCallback} endCb\n   * @access protected\n   */\n  wrapMatches(regex, ignoreGroups, filterCb, eachCb, endCb) {\n    const matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\n    this.getTextNodes(dict => {\n      dict.nodes.forEach(node => {\n        node = node.node;\n        let match;\n        while (\n          (match = regex.exec(node.textContent)) !== null &&\n          match[matchIdx] !== ''\n        ) {\n          if (!filterCb(match[matchIdx], node)) {\n            continue;\n          }\n          let pos = match.index;\n          if (matchIdx !== 0) {\n            for (let i = 1; i < matchIdx; i++) {\n              pos += match[i].length;\n            }\n          }\n          node = this.wrapRangeInTextNode(\n            node,\n            pos,\n            pos + match[matchIdx].length\n          );\n          eachCb(node.previousSibling);\n          // reset index of last match as the node changed and the\n          // index isn't valid anymore http://tinyurl.com/htsudjd\n          regex.lastIndex = 0;\n        }\n      });\n      endCb();\n    });\n  }\n\n  /**\n   * Callback for each wrapped element\n   * @callback Mark~wrapMatchesAcrossElementsEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Filter callback before each wrapping\n   * @callback Mark~wrapMatchesAcrossElementsFilterCallback\n   * @param {string} match - The matching string\n   * @param {HTMLElement} node - The text node where the match occurs\n   */\n  /**\n   * Callback on end\n   * @callback Mark~wrapMatchesAcrossElementsEndCallback\n   */\n  /**\n   * Wraps the instance element and class around matches across all HTML\n   * elements in all contexts\n   * @param {RegExp} regex - The regular expression to be searched for\n   * @param {number} ignoreGroups - A number indicating the amount of RegExp\n   * matching groups to ignore\n   * @param {Mark~wrapMatchesAcrossElementsFilterCallback} filterCb\n   * @param {Mark~wrapMatchesAcrossElementsEachCallback} eachCb\n   * @param {Mark~wrapMatchesAcrossElementsEndCallback} endCb\n   * @access protected\n   */\n  wrapMatchesAcrossElements(regex, ignoreGroups, filterCb, eachCb, endCb) {\n    const matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\n    this.getTextNodes(dict => {\n      let match;\n      while (\n        (match = regex.exec(dict.value)) !== null &&\n        match[matchIdx] !== ''\n      ) {\n        // calculate range inside dict.value\n        let start = match.index;\n        if (matchIdx !== 0) {\n          for (let i = 1; i < matchIdx; i++) {\n            start += match[i].length;\n          }\n        }\n        const end = start + match[matchIdx].length;\n        // note that dict will be updated automatically, as it'll change\n        // in the wrapping process, due to the fact that text\n        // nodes will be splitted\n        this.wrapRangeInMappedTextNode(dict, start, end, node => {\n          return filterCb(match[matchIdx], node);\n        }, (node, lastIndex) => {\n          regex.lastIndex = lastIndex;\n          eachCb(node);\n        });\n      }\n      endCb();\n    });\n  }\n\n  /**\n   * Callback for each wrapped element\n   * @callback Mark~wrapRangeFromIndexEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   * @param {Mark~rangeObject} range - the current range object; provided\n   * start and length values will be numeric integers modified from the\n   * provided original ranges.\n   */\n  /**\n   * Filter callback before each wrapping\n   * @callback Mark~wrapRangeFromIndexFilterCallback\n   * @param {HTMLElement} node - The text node which includes the range\n   * @param {Mark~rangeObject} range - the current range object\n   * @param {string} match - string extracted from the matching range\n   * @param {number} counter - A counter indicating the number of all marks\n   */\n  /**\n   * Callback on end\n   * @callback Mark~wrapRangeFromIndexEndCallback\n   */\n  /**\n   * Wraps the indicated ranges across all HTML elements in all contexts\n   * @param {Mark~setOfRanges} ranges\n   * @param {Mark~wrapRangeFromIndexFilterCallback} filterCb\n   * @param {Mark~wrapRangeFromIndexEachCallback} eachCb\n   * @param {Mark~wrapRangeFromIndexEndCallback} endCb\n   * @access protected\n   */\n  wrapRangeFromIndex(ranges, filterCb, eachCb, endCb) {\n    this.getTextNodes(dict => {\n      const originalLength = dict.value.length;\n      ranges.forEach((range, counter) => {\n        let {start, end, valid} = this.checkWhitespaceRanges(\n          range,\n          originalLength,\n          dict.value\n        );\n        if (valid) {\n          this.wrapRangeInMappedTextNode(dict, start, end, node => {\n            return filterCb(\n              node,\n              range,\n              dict.value.substring(start, end),\n              counter\n            );\n          }, node => {\n            eachCb(node, range);\n          });\n        }\n      });\n      endCb();\n    });\n  }\n\n  /**\n   * Unwraps the specified DOM node with its content (text nodes or HTML)\n   * without destroying possibly present events (using innerHTML) and\n   * normalizes the parent at the end (merge splitted text nodes)\n   * @param  {HTMLElement} node - The DOM node to unwrap\n   * @access protected\n   */\n  unwrapMatches(node) {\n    const parent = node.parentNode;\n    let docFrag = document.createDocumentFragment();\n    while (node.firstChild) {\n      docFrag.appendChild(node.removeChild(node.firstChild));\n    }\n    parent.replaceChild(docFrag, node);\n    if (!this.ie) { // use browser's normalize method\n      parent.normalize();\n    } else { // custom method (needs more time)\n      this.normalizeTextNode(parent);\n    }\n  }\n\n  /**\n   * Normalizes text nodes. It's a workaround for the native normalize method\n   * that has a bug in IE (see attached link). Should only be used in IE\n   * browsers as it's slower than the native method.\n   * @see {@link http://tinyurl.com/z5asa8c}\n   * @param {HTMLElement} node - The DOM node to normalize\n   * @access protected\n   */\n  normalizeTextNode(node) {\n    if (!node) {\n      return;\n    }\n    if (node.nodeType === 3) {\n      while (node.nextSibling && node.nextSibling.nodeType === 3) {\n        node.nodeValue += node.nextSibling.nodeValue;\n        node.parentNode.removeChild(node.nextSibling);\n      }\n    } else {\n      this.normalizeTextNode(node.firstChild);\n    }\n    this.normalizeTextNode(node.nextSibling);\n  }\n\n  /**\n   * Callback when finished\n   * @callback Mark~commonDoneCallback\n   * @param {number} totalMatches - The number of marked elements\n   */\n  /**\n   * @typedef Mark~commonOptions\n   * @type {object.<string>}\n   * @property {string} [element=\"mark\"] - HTML element tag name\n   * @property {string} [className] - An optional class name\n   * @property {string[]} [exclude] - An array with exclusion selectors.\n   * Elements matching those selectors will be ignored\n   * @property {boolean} [iframes=false] - Whether to search inside iframes\n   * @property {Mark~commonDoneCallback} [done]\n   * @property {boolean} [debug=false] - Wheter to log messages\n   * @property {object} [log=window.console] - Where to log messages (only if\n   * debug is true)\n   */\n  /**\n   * Callback for each marked element\n   * @callback Mark~markRegExpEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Callback if there were no matches\n   * @callback Mark~markRegExpNoMatchCallback\n   * @param {RegExp} regexp - The regular expression\n   */\n  /**\n   * Callback to filter matches\n   * @callback Mark~markRegExpFilterCallback\n   * @param {HTMLElement} textNode - The text node which includes the match\n   * @param {string} match - The matching string for the RegExp\n   * @param {number} counter - A counter indicating the number of all marks\n   */\n  /**\n   * These options also include the common options from\n   * {@link Mark~commonOptions}\n   * @typedef Mark~markRegExpOptions\n   * @type {object.<string>}\n   * @property {Mark~markRegExpEachCallback} [each]\n   * @property {Mark~markRegExpNoMatchCallback} [noMatch]\n   * @property {Mark~markRegExpFilterCallback} [filter]\n   */\n  /**\n   * Marks a custom regular expression\n   * @param  {RegExp} regexp - The regular expression\n   * @param  {Mark~markRegExpOptions} [opt] - Optional options object\n   * @access public\n   */\n  markRegExp(regexp, opt) {\n    this.opt = opt;\n    this.log(`Searching with expression \"${regexp}\"`);\n    let totalMatches = 0,\n      fn = 'wrapMatches';\n    const eachCb = element => {\n      totalMatches++;\n      this.opt.each(element);\n    };\n    if (this.opt.acrossElements) {\n      fn = 'wrapMatchesAcrossElements';\n    }\n    this[fn](regexp, this.opt.ignoreGroups, (match, node) => {\n      return this.opt.filter(node, match, totalMatches);\n    }, eachCb, () => {\n      if (totalMatches === 0) {\n        this.opt.noMatch(regexp);\n      }\n      this.opt.done(totalMatches);\n    });\n  }\n\n  /**\n   * Callback for each marked element\n   * @callback Mark~markEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   */\n  /**\n   * Callback if there were no matches\n   * @callback Mark~markNoMatchCallback\n   * @param {RegExp} term - The search term that was not found\n   */\n  /**\n   * Callback to filter matches\n   * @callback Mark~markFilterCallback\n   * @param {HTMLElement} textNode - The text node which includes the match\n   * @param {string} match - The matching term\n   * @param {number} totalCounter - A counter indicating the number of all\n   * marks\n   * @param {number} termCounter - A counter indicating the number of marks\n   * for the specific match\n   */\n  /**\n   * @typedef Mark~markAccuracyObject\n   * @type {object.<string>}\n   * @property {string} value - A accuracy string value\n   * @property {string[]} limiters - A custom array of limiters. For example\n   * <code>[\"-\", \",\"]</code>\n   */\n  /**\n   * @typedef Mark~markAccuracySetting\n   * @type {string}\n   * @property {\"partially\"|\"complementary\"|\"exactly\"|Mark~markAccuracyObject}\n   * [accuracy=\"partially\"] - Either one of the following string values:\n   * <ul>\n   *   <li><i>partially</i>: When searching for \"lor\" only \"lor\" inside\n   *   \"lorem\" will be marked</li>\n   *   <li><i>complementary</i>: When searching for \"lor\" the whole word\n   *   \"lorem\" will be marked</li>\n   *   <li><i>exactly</i>: When searching for \"lor\" only those exact words\n   *   will be marked. In this example nothing inside \"lorem\". This value\n   *   is equivalent to the previous option <i>wordBoundary</i></li>\n   * </ul>\n   * Or an object containing two properties:\n   * <ul>\n   *   <li><i>value</i>: One of the above named string values</li>\n   *   <li><i>limiters</i>: A custom array of string limiters for accuracy\n   *   \"exactly\" or \"complementary\"</li>\n   * </ul>\n   */\n  /**\n   * @typedef Mark~markWildcardsSetting\n   * @type {string}\n   * @property {\"disabled\"|\"enabled\"|\"withSpaces\"}\n   * [wildcards=\"disabled\"] - Set to any of the following string values:\n   * <ul>\n   *   <li><i>disabled</i>: Disable wildcard usage</li>\n   *   <li><i>enabled</i>: When searching for \"lor?m\", the \"?\" will match zero\n   *   or one non-space character (e.g. \"lorm\", \"loram\", \"lor3m\", etc). When\n   *   searching for \"lor*m\", the \"*\" will match zero or more non-space\n   *   characters (e.g. \"lorm\", \"loram\", \"lor123m\", etc).</li>\n   *   <li><i>withSpaces</i>: When searching for \"lor?m\", the \"?\" will\n   *   match zero or one space or non-space character (e.g. \"lor m\", \"loram\",\n   *   etc). When searching for \"lor*m\", the \"*\" will match zero or more space\n   *   or non-space characters (e.g. \"lorm\", \"lore et dolor ipsum\", \"lor: m\",\n   *   etc).</li>\n   * </ul>\n   */\n  /**\n   * @typedef Mark~markIgnorePunctuationSetting\n   * @type {string[]}\n   * @property {string} The strings in this setting will contain punctuation\n   * marks that will be ignored:\n   * <ul>\n   *   <li>These punctuation marks can be between any characters, e.g. setting\n   *   this option to <code>[\"'\"]</code> would match \"Worlds\", \"World's\" and\n   *   \"Wo'rlds\"</li>\n   *   <li>One or more apostrophes between the letters would still produce a\n   *   match (e.g. \"W'o''r'l'd's\").</li>\n   *   <li>A typical setting for this option could be as follows:\n   *   <pre>ignorePunctuation: \":;.,-–—‒_(){}[]!'\\\"+=\".split(\"\"),</pre> This\n   *   setting includes common punctuation as well as a minus, en-dash,\n   *   em-dash and figure-dash\n   *   ({@link https://en.wikipedia.org/wiki/Dash#Figure_dash ref}), as well\n   *   as an underscore.</li>\n   * </ul>\n   */\n  /**\n   * These options also include the common options from\n   * {@link Mark~commonOptions}\n   * @typedef Mark~markOptions\n   * @type {object.<string>}\n   * @property {boolean} [separateWordSearch=true] - Whether to search for\n   * each word separated by a blank instead of the complete term\n   * @property {boolean} [diacritics=true] - If diacritic characters should be\n   * matched. ({@link https://en.wikipedia.org/wiki/Diacritic Diacritics})\n   * @property {object} [synonyms] - An object with synonyms. The key will be\n   * a synonym for the value and the value for the key\n   * @property {Mark~markAccuracySetting} [accuracy]\n   * @property {Mark~markWildcardsSetting} [wildcards]\n   * @property {boolean} [acrossElements=false] - Whether to find matches\n   * across HTML elements. By default, only matches within single HTML\n   * elements will be found\n   * @property {boolean} [ignoreJoiners=false] - Whether to ignore word\n   * joiners inside of key words. These include soft-hyphens, zero-width\n   * space, zero-width non-joiners and zero-width joiners.\n   * @property {Mark~markIgnorePunctuationSetting} [ignorePunctuation]\n   * @property {Mark~markEachCallback} [each]\n   * @property {Mark~markNoMatchCallback} [noMatch]\n   * @property {Mark~markFilterCallback} [filter]\n   */\n  /**\n   * Marks the specified search terms\n   * @param {string|string[]} [sv] - Search value, either a search string or\n   * an array containing multiple search strings\n   * @param  {Mark~markOptions} [opt] - Optional options object\n   * @access public\n   */\n  mark(sv, opt) {\n    this.opt = opt;\n    let totalMatches = 0,\n      fn = 'wrapMatches';\n\n    const {\n        keywords: kwArr,\n        length: kwArrLen\n      } = this.getSeparatedKeywords(typeof sv === 'string' ? [sv] : sv),\n      sens = this.opt.caseSensitive ? '' : 'i',\n      handler = kw => { // async function calls as iframes are async too\n        let regex = new RegExp(this.createRegExp(kw), `gm${sens}`),\n          matches = 0;\n        this.log(`Searching with expression \"${regex}\"`);\n        this[fn](regex, 1, (term, node) => {\n          return this.opt.filter(node, kw, totalMatches, matches);\n        }, element => {\n          matches++;\n          totalMatches++;\n          this.opt.each(element);\n        }, () => {\n          if (matches === 0) {\n            this.opt.noMatch(kw);\n          }\n          if (kwArr[kwArrLen - 1] === kw) {\n            this.opt.done(totalMatches);\n          } else {\n            handler(kwArr[kwArr.indexOf(kw) + 1]);\n          }\n        });\n      };\n    if (this.opt.acrossElements) {\n      fn = 'wrapMatchesAcrossElements';\n    }\n    if (kwArrLen === 0) {\n      this.opt.done(totalMatches);\n    } else {\n      handler(kwArr[0]);\n    }\n  }\n\n  /**\n   * Callback for each marked element\n   * @callback Mark~markRangesEachCallback\n   * @param {HTMLElement} element - The marked DOM element\n   * @param {array} range - array of range start and end points\n   */\n  /**\n   * Callback if a processed range is invalid, out-of-bounds, overlaps another\n   * range, or only matches whitespace\n   * @callback Mark~markRangesNoMatchCallback\n   * @param {Mark~rangeObject} range - a range object\n   */\n  /**\n   * Callback to filter matches\n   * @callback Mark~markRangesFilterCallback\n   * @param {HTMLElement} node - The text node which includes the range\n   * @param {array} range - array of range start and end points\n   * @param {string} match - string extracted from the matching range\n   * @param {number} counter - A counter indicating the number of all marks\n   */\n  /**\n   * These options also include the common options from\n   * {@link Mark~commonOptions}\n   * @typedef Mark~markRangesOptions\n   * @type {object.<string>}\n   * @property {Mark~markRangesEachCallback} [each]\n   * @property {Mark~markRangesNoMatchCallback} [noMatch]\n   * @property {Mark~markRangesFilterCallback} [filter]\n   */\n  /**\n   * Marks an array of objects containing a start with an end or length of the\n   * string to mark\n   * @param  {Mark~setOfRanges} rawRanges - The original (preprocessed)\n   * array of objects\n   * @param  {Mark~markRangesOptions} [opt] - Optional options object\n   * @access public\n   */\n  markRanges(rawRanges, opt) {\n    this.opt = opt;\n    let totalMatches = 0,\n      ranges = this.checkRanges(rawRanges);\n    if (ranges && ranges.length) {\n      this.log(\n        'Starting to mark with the following ranges: ' +\n        JSON.stringify(ranges)\n      );\n      this.wrapRangeFromIndex(\n        ranges, (node, range, match, counter) => {\n          return this.opt.filter(node, range, match, counter);\n        }, (element, range) => {\n          totalMatches++;\n          this.opt.each(element, range);\n        }, () => {\n          this.opt.done(totalMatches);\n        }\n      );\n    } else {\n      this.opt.done(totalMatches);\n    }\n  }\n\n  /**\n   * Removes all marked elements inside the context with their HTML and\n   * normalizes the parent at the end\n   * @param  {Mark~commonOptions} [opt] - Optional options object\n   * @access public\n   */\n  unmark(opt) {\n    this.opt = opt;\n    let sel = this.opt.element ? this.opt.element : '*';\n    sel += '[data-markjs]';\n    if (this.opt.className) {\n      sel += `.${this.opt.className}`;\n    }\n    this.log(`Removal selector \"${sel}\"`);\n    this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT, node => {\n      this.unwrapMatches(node);\n    }, node => {\n      const matchesSel = DOMIterator.matches(node, sel),\n        matchesExclude = this.matchesExclude(node);\n      if (!matchesSel || matchesExclude) {\n        return NodeFilter.FILTER_REJECT;\n      } else {\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }, this.opt.done);\n  }\n}\n","import MarkJS from './lib/mark';\n\nexport default function Mark(ctx) {\n  const instance = new MarkJS(ctx);\n  this.mark = (sv, opt) => {\n    instance.mark(sv, opt);\n    return this;\n  };\n  this.markRegExp = (sv, opt) => {\n    instance.markRegExp(sv, opt);\n    return this;\n  };\n  this.markRanges = (sv, opt) => {\n    instance.markRanges(sv, opt);\n    return this;\n  };\n  this.unmark = (opt) => {\n    instance.unmark(opt);\n    return this;\n  };\n  return this;\n}","/** @ignore */\nconst ENTRIES = 'ENTRIES';\n/** @ignore */\nconst KEYS = 'KEYS';\n/** @ignore */\nconst VALUES = 'VALUES';\n/** @ignore */\nconst LEAF = '';\n/**\n * @private\n */\nclass TreeIterator {\n    constructor(set, type) {\n        const node = set._tree;\n        const keys = Array.from(node.keys());\n        this.set = set;\n        this._type = type;\n        this._path = keys.length > 0 ? [{ node, keys }] : [];\n    }\n    next() {\n        const value = this.dive();\n        this.backtrack();\n        return value;\n    }\n    dive() {\n        if (this._path.length === 0) {\n            return { done: true, value: undefined };\n        }\n        const { node, keys } = last$1(this._path);\n        if (last$1(keys) === LEAF) {\n            return { done: false, value: this.result() };\n        }\n        const child = node.get(last$1(keys));\n        this._path.push({ node: child, keys: Array.from(child.keys()) });\n        return this.dive();\n    }\n    backtrack() {\n        if (this._path.length === 0) {\n            return;\n        }\n        const keys = last$1(this._path).keys;\n        keys.pop();\n        if (keys.length > 0) {\n            return;\n        }\n        this._path.pop();\n        this.backtrack();\n    }\n    key() {\n        return this.set._prefix + this._path\n            .map(({ keys }) => last$1(keys))\n            .filter(key => key !== LEAF)\n            .join('');\n    }\n    value() {\n        return last$1(this._path).node.get(LEAF);\n    }\n    result() {\n        switch (this._type) {\n            case VALUES: return this.value();\n            case KEYS: return this.key();\n            default: return [this.key(), this.value()];\n        }\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n}\nconst last$1 = (array) => {\n    return array[array.length - 1];\n};\n\n/* eslint-disable no-labels */\n/**\n * @ignore\n */\nconst fuzzySearch = (node, query, maxDistance) => {\n    const results = new Map();\n    if (query === undefined)\n        return results;\n    // Number of columns in the Levenshtein matrix.\n    const n = query.length + 1;\n    // Matching terms can never be longer than N + maxDistance.\n    const m = n + maxDistance;\n    // Fill first matrix row and column with numbers: 0 1 2 3 ...\n    const matrix = new Uint8Array(m * n).fill(maxDistance + 1);\n    for (let j = 0; j < n; ++j)\n        matrix[j] = j;\n    for (let i = 1; i < m; ++i)\n        matrix[i * n] = i;\n    recurse(node, query, maxDistance, results, matrix, 1, n, '');\n    return results;\n};\n// Modified version of http://stevehanov.ca/blog/?id=114\n// This builds a Levenshtein matrix for a given query and continuously updates\n// it for nodes in the radix tree that fall within the given maximum edit\n// distance. Keeping the same matrix around is beneficial especially for larger\n// edit distances.\n//\n//           k   a   t   e   <-- query\n//       0   1   2   3   4\n//   c   1   1   2   3   4\n//   a   2   2   1   2   3\n//   t   3   3   2   1  [2]  <-- edit distance\n//   ^\n//   ^ term in radix tree, rows are added and removed as needed\nconst recurse = (node, query, maxDistance, results, matrix, m, n, prefix) => {\n    const offset = m * n;\n    key: for (const key of node.keys()) {\n        if (key === LEAF) {\n            // We've reached a leaf node. Check if the edit distance acceptable and\n            // store the result if it is.\n            const distance = matrix[offset - 1];\n            if (distance <= maxDistance) {\n                results.set(prefix, [node.get(key), distance]);\n            }\n        }\n        else {\n            // Iterate over all characters in the key. Update the Levenshtein matrix\n            // and check if the minimum distance in the last row is still within the\n            // maximum edit distance. If it is, we can recurse over all child nodes.\n            let i = m;\n            for (let pos = 0; pos < key.length; ++pos, ++i) {\n                const char = key[pos];\n                const thisRowOffset = n * i;\n                const prevRowOffset = thisRowOffset - n;\n                // Set the first column based on the previous row, and initialize the\n                // minimum distance in the current row.\n                let minDistance = matrix[thisRowOffset];\n                const jmin = Math.max(0, i - maxDistance - 1);\n                const jmax = Math.min(n - 1, i + maxDistance);\n                // Iterate over remaining columns (characters in the query).\n                for (let j = jmin; j < jmax; ++j) {\n                    const different = char !== query[j];\n                    // It might make sense to only read the matrix positions used for\n                    // deletion/insertion if the characters are different. But we want to\n                    // avoid conditional reads for performance reasons.\n                    const rpl = matrix[prevRowOffset + j] + +different;\n                    const del = matrix[prevRowOffset + j + 1] + 1;\n                    const ins = matrix[thisRowOffset + j] + 1;\n                    const dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins);\n                    if (dist < minDistance)\n                        minDistance = dist;\n                }\n                // Because distance will never decrease, we can stop. There will be no\n                // matching child nodes.\n                if (minDistance > maxDistance) {\n                    continue key;\n                }\n            }\n            recurse(node.get(key), query, maxDistance, results, matrix, i, n, prefix + key);\n        }\n    }\n};\n\n/* eslint-disable no-labels */\n/**\n * A class implementing the same interface as a standard JavaScript\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * with string keys, but adding support for efficiently searching entries with\n * prefix or fuzzy search. This class is used internally by {@link MiniSearch}\n * as the inverted index data structure. The implementation is a radix tree\n * (compressed prefix tree).\n *\n * Since this class can be of general utility beyond _MiniSearch_, it is\n * exported by the `minisearch` package and can be imported (or required) as\n * `minisearch/SearchableMap`.\n *\n * @typeParam T  The type of the values stored in the map.\n */\nclass SearchableMap {\n    /**\n     * The constructor is normally called without arguments, creating an empty\n     * map. In order to create a {@link SearchableMap} from an iterable or from an\n     * object, check {@link SearchableMap.from} and {@link\n     * SearchableMap.fromObject}.\n     *\n     * The constructor arguments are for internal use, when creating derived\n     * mutable views of a map at a prefix.\n     */\n    constructor(tree = new Map(), prefix = '') {\n        this._size = undefined;\n        this._tree = tree;\n        this._prefix = prefix;\n    }\n    /**\n     * Creates and returns a mutable view of this {@link SearchableMap},\n     * containing only entries that share the given prefix.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * let map = new SearchableMap()\n     * map.set(\"unicorn\", 1)\n     * map.set(\"universe\", 2)\n     * map.set(\"university\", 3)\n     * map.set(\"unique\", 4)\n     * map.set(\"hello\", 5)\n     *\n     * let uni = map.atPrefix(\"uni\")\n     * uni.get(\"unique\") // => 4\n     * uni.get(\"unicorn\") // => 1\n     * uni.get(\"hello\") // => undefined\n     *\n     * let univer = map.atPrefix(\"univer\")\n     * univer.get(\"unique\") // => undefined\n     * univer.get(\"universe\") // => 2\n     * univer.get(\"university\") // => 3\n     * ```\n     *\n     * @param prefix  The prefix\n     * @return A {@link SearchableMap} representing a mutable view of the original\n     * Map at the given prefix\n     */\n    atPrefix(prefix) {\n        if (!prefix.startsWith(this._prefix)) {\n            throw new Error('Mismatched prefix');\n        }\n        const [node, path] = trackDown(this._tree, prefix.slice(this._prefix.length));\n        if (node === undefined) {\n            const [parentNode, key] = last(path);\n            for (const k of parentNode.keys()) {\n                if (k !== LEAF && k.startsWith(key)) {\n                    const node = new Map();\n                    node.set(k.slice(key.length), parentNode.get(k));\n                    return new SearchableMap(node, prefix);\n                }\n            }\n        }\n        return new SearchableMap(node, prefix);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\n     */\n    clear() {\n        this._size = undefined;\n        this._tree.clear();\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\n     * @param key  Key to delete\n     */\n    delete(key) {\n        this._size = undefined;\n        return remove(this._tree, key);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\n     * @return An iterator iterating through `[key, value]` entries.\n     */\n    entries() {\n        return new TreeIterator(this, ENTRIES);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\n     * @param fn  Iteration function\n     */\n    forEach(fn) {\n        for (const [key, value] of this) {\n            fn(key, value, this);\n        }\n    }\n    /**\n     * Returns a Map of all the entries that have a key within the given edit\n     * distance from the search key. The keys of the returned Map are the matching\n     * keys, while the values are two-element arrays where the first element is\n     * the value associated to the key, and the second is the edit distance of the\n     * key to the search key.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * let map = new SearchableMap()\n     * map.set('hello', 'world')\n     * map.set('hell', 'yeah')\n     * map.set('ciao', 'mondo')\n     *\n     * // Get all entries that match the key 'hallo' with a maximum edit distance of 2\n     * map.fuzzyGet('hallo', 2)\n     * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }\n     *\n     * // In the example, the \"hello\" key has value \"world\" and edit distance of 1\n     * // (change \"e\" to \"a\"), the key \"hell\" has value \"yeah\" and edit distance of 2\n     * // (change \"e\" to \"a\", delete \"o\")\n     * ```\n     *\n     * @param key  The search key\n     * @param maxEditDistance  The maximum edit distance (Levenshtein)\n     * @return A Map of the matching keys to their value and edit distance\n     */\n    fuzzyGet(key, maxEditDistance) {\n        return fuzzySearch(this._tree, key, maxEditDistance);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\n     * @param key  Key to get\n     * @return Value associated to the key, or `undefined` if the key is not\n     * found.\n     */\n    get(key) {\n        const node = lookup(this._tree, key);\n        return node !== undefined ? node.get(LEAF) : undefined;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\n     * @param key  Key\n     * @return True if the key is in the map, false otherwise\n     */\n    has(key) {\n        const node = lookup(this._tree, key);\n        return node !== undefined && node.has(LEAF);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\n     * @return An `Iterable` iterating through keys\n     */\n    keys() {\n        return new TreeIterator(this, KEYS);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\n     * @param key  Key to set\n     * @param value  Value to associate to the key\n     * @return The {@link SearchableMap} itself, to allow chaining\n     */\n    set(key, value) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        node.set(LEAF, value);\n        return this;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\n     */\n    get size() {\n        if (this._size) {\n            return this._size;\n        }\n        /** @ignore */\n        this._size = 0;\n        const iter = this.entries();\n        while (!iter.next().done)\n            this._size += 1;\n        return this._size;\n    }\n    /**\n     * Updates the value at the given key using the provided function. The function\n     * is called with the current value at the key, and its return value is used as\n     * the new value to be set.\n     *\n     * ### Example:\n     *\n     * ```javascript\n     * // Increment the current value by one\n     * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)\n     * ```\n     *\n     * If the value at the given key is or will be an object, it might not require\n     * re-assignment. In that case it is better to use `fetch()`, because it is\n     * faster.\n     *\n     * @param key  The key to update\n     * @param fn  The function used to compute the new value from the current one\n     * @return The {@link SearchableMap} itself, to allow chaining\n     */\n    update(key, fn) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        node.set(LEAF, fn(node.get(LEAF)));\n        return this;\n    }\n    /**\n     * Fetches the value of the given key. If the value does not exist, calls the\n     * given function to create a new value, which is inserted at the given key\n     * and subsequently returned.\n     *\n     * ### Example:\n     *\n     * ```javascript\n     * const map = searchableMap.fetch('somekey', () => new Map())\n     * map.set('foo', 'bar')\n     * ```\n     *\n     * @param key  The key to update\n     * @param initial  A function that creates a new value if the key does not exist\n     * @return The existing or new value at the given key\n     */\n    fetch(key, initial) {\n        if (typeof key !== 'string') {\n            throw new Error('key must be a string');\n        }\n        this._size = undefined;\n        const node = createPath(this._tree, key);\n        let value = node.get(LEAF);\n        if (value === undefined) {\n            node.set(LEAF, value = initial());\n        }\n        return value;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\n     * @return An `Iterable` iterating through values.\n     */\n    values() {\n        return new TreeIterator(this, VALUES);\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Creates a {@link SearchableMap} from an `Iterable` of entries\n     *\n     * @param entries  Entries to be inserted in the {@link SearchableMap}\n     * @return A new {@link SearchableMap} with the given entries\n     */\n    static from(entries) {\n        const tree = new SearchableMap();\n        for (const [key, value] of entries) {\n            tree.set(key, value);\n        }\n        return tree;\n    }\n    /**\n     * Creates a {@link SearchableMap} from the iterable properties of a JavaScript object\n     *\n     * @param object  Object of entries for the {@link SearchableMap}\n     * @return A new {@link SearchableMap} with the given entries\n     */\n    static fromObject(object) {\n        return SearchableMap.from(Object.entries(object));\n    }\n}\nconst trackDown = (tree, key, path = []) => {\n    if (key.length === 0 || tree == null) {\n        return [tree, path];\n    }\n    for (const k of tree.keys()) {\n        if (k !== LEAF && key.startsWith(k)) {\n            path.push([tree, k]); // performance: update in place\n            return trackDown(tree.get(k), key.slice(k.length), path);\n        }\n    }\n    path.push([tree, key]); // performance: update in place\n    return trackDown(undefined, '', path);\n};\nconst lookup = (tree, key) => {\n    if (key.length === 0 || tree == null) {\n        return tree;\n    }\n    for (const k of tree.keys()) {\n        if (k !== LEAF && key.startsWith(k)) {\n            return lookup(tree.get(k), key.slice(k.length));\n        }\n    }\n};\n// Create a path in the radix tree for the given key, and returns the deepest\n// node. This function is in the hot path for indexing. It avoids unnecessary\n// string operations and recursion for performance.\nconst createPath = (node, key) => {\n    const keyLength = key.length;\n    outer: for (let pos = 0; node && pos < keyLength;) {\n        for (const k of node.keys()) {\n            // Check whether this key is a candidate: the first characters must match.\n            if (k !== LEAF && key[pos] === k[0]) {\n                const len = Math.min(keyLength - pos, k.length);\n                // Advance offset to the point where key and k no longer match.\n                let offset = 1;\n                while (offset < len && key[pos + offset] === k[offset])\n                    ++offset;\n                const child = node.get(k);\n                if (offset === k.length) {\n                    // The existing key is shorter than the key we need to create.\n                    node = child;\n                }\n                else {\n                    // Partial match: we need to insert an intermediate node to contain\n                    // both the existing subtree and the new node.\n                    const intermediate = new Map();\n                    intermediate.set(k.slice(offset), child);\n                    node.set(key.slice(pos, pos + offset), intermediate);\n                    node.delete(k);\n                    node = intermediate;\n                }\n                pos += offset;\n                continue outer;\n            }\n        }\n        // Create a final child node to contain the final suffix of the key.\n        const child = new Map();\n        node.set(key.slice(pos), child);\n        return child;\n    }\n    return node;\n};\nconst remove = (tree, key) => {\n    const [node, path] = trackDown(tree, key);\n    if (node === undefined) {\n        return;\n    }\n    node.delete(LEAF);\n    if (node.size === 0) {\n        cleanup(path);\n    }\n    else if (node.size === 1) {\n        const [key, value] = node.entries().next().value;\n        merge(path, key, value);\n    }\n};\nconst cleanup = (path) => {\n    if (path.length === 0) {\n        return;\n    }\n    const [node, key] = last(path);\n    node.delete(key);\n    if (node.size === 0) {\n        cleanup(path.slice(0, -1));\n    }\n    else if (node.size === 1) {\n        const [key, value] = node.entries().next().value;\n        if (key !== LEAF) {\n            merge(path.slice(0, -1), key, value);\n        }\n    }\n};\nconst merge = (path, key, value) => {\n    if (path.length === 0) {\n        return;\n    }\n    const [node, nodeKey] = last(path);\n    node.set(nodeKey + key, value);\n    node.delete(nodeKey);\n};\nconst last = (array) => {\n    return array[array.length - 1];\n};\n\nconst OR = 'or';\nconst AND = 'and';\nconst AND_NOT = 'and_not';\n/**\n * {@link MiniSearch} is the main entrypoint class, implementing a full-text\n * search engine in memory.\n *\n * @typeParam T  The type of the documents being indexed.\n *\n * ### Basic example:\n *\n * ```javascript\n * const documents = [\n *   {\n *     id: 1,\n *     title: 'Moby Dick',\n *     text: 'Call me Ishmael. Some years ago...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 2,\n *     title: 'Zen and the Art of Motorcycle Maintenance',\n *     text: 'I can see by my watch...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 3,\n *     title: 'Neuromancer',\n *     text: 'The sky above the port was...',\n *     category: 'fiction'\n *   },\n *   {\n *     id: 4,\n *     title: 'Zen and the Art of Archery',\n *     text: 'At first sight it must seem...',\n *     category: 'non-fiction'\n *   },\n *   // ...and more\n * ]\n *\n * // Create a search engine that indexes the 'title' and 'text' fields for\n * // full-text search. Search results will include 'title' and 'category' (plus the\n * // id field, that is always stored and returned)\n * const miniSearch = new MiniSearch({\n *   fields: ['title', 'text'],\n *   storeFields: ['title', 'category']\n * })\n *\n * // Add documents to the index\n * miniSearch.addAll(documents)\n *\n * // Search for documents:\n * let results = miniSearch.search('zen art motorcycle')\n * // => [\n * //   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },\n * //   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }\n * // ]\n * ```\n */\nclass MiniSearch {\n    /**\n     * @param options  Configuration options\n     *\n     * ### Examples:\n     *\n     * ```javascript\n     * // Create a search engine that indexes the 'title' and 'text' fields of your\n     * // documents:\n     * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * ```\n     *\n     * ### ID Field:\n     *\n     * ```javascript\n     * // Your documents are assumed to include a unique 'id' field, but if you want\n     * // to use a different field for document identification, you can set the\n     * // 'idField' option:\n     * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })\n     * ```\n     *\n     * ### Options and defaults:\n     *\n     * ```javascript\n     * // The full set of options (here with their default value) is:\n     * const miniSearch = new MiniSearch({\n     *   // idField: field that uniquely identifies a document\n     *   idField: 'id',\n     *\n     *   // extractField: function used to get the value of a field in a document.\n     *   // By default, it assumes the document is a flat object with field names as\n     *   // property keys and field values as string property values, but custom logic\n     *   // can be implemented by setting this option to a custom extractor function.\n     *   extractField: (document, fieldName) => document[fieldName],\n     *\n     *   // tokenize: function used to split fields into individual terms. By\n     *   // default, it is also used to tokenize search queries, unless a specific\n     *   // `tokenize` search option is supplied. When tokenizing an indexed field,\n     *   // the field name is passed as the second argument.\n     *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),\n     *\n     *   // processTerm: function used to process each tokenized term before\n     *   // indexing. It can be used for stemming and normalization. Return a falsy\n     *   // value in order to discard a term. By default, it is also used to process\n     *   // search queries, unless a specific `processTerm` option is supplied as a\n     *   // search option. When processing a term from a indexed field, the field\n     *   // name is passed as the second argument.\n     *   processTerm: (term, _fieldName) => term.toLowerCase(),\n     *\n     *   // searchOptions: default search options, see the `search` method for\n     *   // details\n     *   searchOptions: undefined,\n     *\n     *   // fields: document fields to be indexed. Mandatory, but not set by default\n     *   fields: undefined\n     *\n     *   // storeFields: document fields to be stored and returned as part of the\n     *   // search results.\n     *   storeFields: []\n     * })\n     * ```\n     */\n    constructor(options) {\n        if ((options === null || options === void 0 ? void 0 : options.fields) == null) {\n            throw new Error('MiniSearch: option \"fields\" must be provided');\n        }\n        const autoVacuum = (options.autoVacuum == null || options.autoVacuum === true) ? defaultAutoVacuumOptions : options.autoVacuum;\n        this._options = {\n            ...defaultOptions,\n            ...options,\n            autoVacuum,\n            searchOptions: { ...defaultSearchOptions, ...(options.searchOptions || {}) },\n            autoSuggestOptions: { ...defaultAutoSuggestOptions, ...(options.autoSuggestOptions || {}) }\n        };\n        this._index = new SearchableMap();\n        this._documentCount = 0;\n        this._documentIds = new Map();\n        this._idToShortId = new Map();\n        // Fields are defined during initialization, don't change, are few in\n        // number, rarely need iterating over, and have string keys. Therefore in\n        // this case an object is a better candidate than a Map to store the mapping\n        // from field key to ID.\n        this._fieldIds = {};\n        this._fieldLength = new Map();\n        this._avgFieldLength = [];\n        this._nextId = 0;\n        this._storedFields = new Map();\n        this._dirtCount = 0;\n        this._currentVacuum = null;\n        this._enqueuedVacuum = null;\n        this._enqueuedVacuumConditions = defaultVacuumConditions;\n        this.addFields(this._options.fields);\n    }\n    /**\n     * Adds a document to the index\n     *\n     * @param document  The document to be indexed\n     */\n    add(document) {\n        const { extractField, tokenize, processTerm, fields, idField } = this._options;\n        const id = extractField(document, idField);\n        if (id == null) {\n            throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`);\n        }\n        if (this._idToShortId.has(id)) {\n            throw new Error(`MiniSearch: duplicate ID ${id}`);\n        }\n        const shortDocumentId = this.addDocumentId(id);\n        this.saveStoredFields(shortDocumentId, document);\n        for (const field of fields) {\n            const fieldValue = extractField(document, field);\n            if (fieldValue == null)\n                continue;\n            const tokens = tokenize(fieldValue.toString(), field);\n            const fieldId = this._fieldIds[field];\n            const uniqueTerms = new Set(tokens).size;\n            this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms);\n            for (const term of tokens) {\n                const processedTerm = processTerm(term, field);\n                if (Array.isArray(processedTerm)) {\n                    for (const t of processedTerm) {\n                        this.addTerm(fieldId, shortDocumentId, t);\n                    }\n                }\n                else if (processedTerm) {\n                    this.addTerm(fieldId, shortDocumentId, processedTerm);\n                }\n            }\n        }\n    }\n    /**\n     * Adds all the given documents to the index\n     *\n     * @param documents  An array of documents to be indexed\n     */\n    addAll(documents) {\n        for (const document of documents)\n            this.add(document);\n    }\n    /**\n     * Adds all the given documents to the index asynchronously.\n     *\n     * Returns a promise that resolves (to `undefined`) when the indexing is done.\n     * This method is useful when index many documents, to avoid blocking the main\n     * thread. The indexing is performed asynchronously and in chunks.\n     *\n     * @param documents  An array of documents to be indexed\n     * @param options  Configuration options\n     * @return A promise resolving to `undefined` when the indexing is done\n     */\n    addAllAsync(documents, options = {}) {\n        const { chunkSize = 10 } = options;\n        const acc = { chunk: [], promise: Promise.resolve() };\n        const { chunk, promise } = documents.reduce(({ chunk, promise }, document, i) => {\n            chunk.push(document);\n            if ((i + 1) % chunkSize === 0) {\n                return {\n                    chunk: [],\n                    promise: promise\n                        .then(() => new Promise(resolve => setTimeout(resolve, 0)))\n                        .then(() => this.addAll(chunk))\n                };\n            }\n            else {\n                return { chunk, promise };\n            }\n        }, acc);\n        return promise.then(() => this.addAll(chunk));\n    }\n    /**\n     * Removes the given document from the index.\n     *\n     * The document to remove must NOT have changed between indexing and removal,\n     * otherwise the index will be corrupted.\n     *\n     * This method requires passing the full document to be removed (not just the\n     * ID), and immediately removes the document from the inverted index, allowing\n     * memory to be released. A convenient alternative is {@link\n     * MiniSearch#discard}, which needs only the document ID, and has the same\n     * visible effect, but delays cleaning up the index until the next vacuuming.\n     *\n     * @param document  The document to be removed\n     */\n    remove(document) {\n        const { tokenize, processTerm, extractField, fields, idField } = this._options;\n        const id = extractField(document, idField);\n        if (id == null) {\n            throw new Error(`MiniSearch: document does not have ID field \"${idField}\"`);\n        }\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            throw new Error(`MiniSearch: cannot remove document with ID ${id}: it is not in the index`);\n        }\n        for (const field of fields) {\n            const fieldValue = extractField(document, field);\n            if (fieldValue == null)\n                continue;\n            const tokens = tokenize(fieldValue.toString(), field);\n            const fieldId = this._fieldIds[field];\n            const uniqueTerms = new Set(tokens).size;\n            this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms);\n            for (const term of tokens) {\n                const processedTerm = processTerm(term, field);\n                if (Array.isArray(processedTerm)) {\n                    for (const t of processedTerm) {\n                        this.removeTerm(fieldId, shortId, t);\n                    }\n                }\n                else if (processedTerm) {\n                    this.removeTerm(fieldId, shortId, processedTerm);\n                }\n            }\n        }\n        this._storedFields.delete(shortId);\n        this._documentIds.delete(shortId);\n        this._idToShortId.delete(id);\n        this._fieldLength.delete(shortId);\n        this._documentCount -= 1;\n    }\n    /**\n     * Removes all the given documents from the index. If called with no arguments,\n     * it removes _all_ documents from the index.\n     *\n     * @param documents  The documents to be removed. If this argument is omitted,\n     * all documents are removed. Note that, for removing all documents, it is\n     * more efficient to call this method with no arguments than to pass all\n     * documents.\n     */\n    removeAll(documents) {\n        if (documents) {\n            for (const document of documents)\n                this.remove(document);\n        }\n        else if (arguments.length > 0) {\n            throw new Error('Expected documents to be present. Omit the argument to remove all documents.');\n        }\n        else {\n            this._index = new SearchableMap();\n            this._documentCount = 0;\n            this._documentIds = new Map();\n            this._idToShortId = new Map();\n            this._fieldLength = new Map();\n            this._avgFieldLength = [];\n            this._storedFields = new Map();\n            this._nextId = 0;\n        }\n    }\n    /**\n     * Discards the document with the given ID, so it won't appear in search results\n     *\n     * It has the same visible effect of {@link MiniSearch.remove} (both cause the\n     * document to stop appearing in searches), but a different effect on the\n     * internal data structures:\n     *\n     *   - {@link MiniSearch#remove} requires passing the full document to be\n     *   removed as argument, and removes it from the inverted index immediately.\n     *\n     *   - {@link MiniSearch#discard} instead only needs the document ID, and\n     *   works by marking the current version of the document as discarded, so it\n     *   is immediately ignored by searches. This is faster and more convenient\n     *   than {@link MiniSearch#remove}, but the index is not immediately\n     *   modified. To take care of that, vacuuming is performed after a certain\n     *   number of documents are discarded, cleaning up the index and allowing\n     *   memory to be released.\n     *\n     * After discarding a document, it is possible to re-add a new version, and\n     * only the new version will appear in searches. In other words, discarding\n     * and re-adding a document works exactly like removing and re-adding it. The\n     * {@link MiniSearch.replace} method can also be used to replace a document\n     * with a new version.\n     *\n     * #### Details about vacuuming\n     *\n     * Repetite calls to this method would leave obsolete document references in\n     * the index, invisible to searches. Two mechanisms take care of cleaning up:\n     * clean up during search, and vacuuming.\n     *\n     *   - Upon search, whenever a discarded ID is found (and ignored for the\n     *   results), references to the discarded document are removed from the\n     *   inverted index entries for the search terms. This ensures that subsequent\n     *   searches for the same terms do not need to skip these obsolete references\n     *   again.\n     *\n     *   - In addition, vacuuming is performed automatically by default (see the\n     *   `autoVacuum` field in {@link Options}) after a certain number of\n     *   documents are discarded. Vacuuming traverses all terms in the index,\n     *   cleaning up all references to discarded documents. Vacuuming can also be\n     *   triggered manually by calling {@link MiniSearch#vacuum}.\n     *\n     * @param id  The ID of the document to be discarded\n     */\n    discard(id) {\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            throw new Error(`MiniSearch: cannot discard document with ID ${id}: it is not in the index`);\n        }\n        this._idToShortId.delete(id);\n        this._documentIds.delete(shortId);\n        this._storedFields.delete(shortId);\n        (this._fieldLength.get(shortId) || []).forEach((fieldLength, fieldId) => {\n            this.removeFieldLength(shortId, fieldId, this._documentCount, fieldLength);\n        });\n        this._fieldLength.delete(shortId);\n        this._documentCount -= 1;\n        this._dirtCount += 1;\n        this.maybeAutoVacuum();\n    }\n    maybeAutoVacuum() {\n        if (this._options.autoVacuum === false) {\n            return;\n        }\n        const { minDirtFactor, minDirtCount, batchSize, batchWait } = this._options.autoVacuum;\n        this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor });\n    }\n    /**\n     * Discards the documents with the given IDs, so they won't appear in search\n     * results\n     *\n     * It is equivalent to calling {@link MiniSearch#discard} for all the given\n     * IDs, but with the optimization of triggering at most one automatic\n     * vacuuming at the end.\n     *\n     * Note: to remove all documents from the index, it is faster and more\n     * convenient to call {@link MiniSearch.removeAll} with no argument, instead\n     * of passing all IDs to this method.\n     */\n    discardAll(ids) {\n        const autoVacuum = this._options.autoVacuum;\n        try {\n            this._options.autoVacuum = false;\n            for (const id of ids) {\n                this.discard(id);\n            }\n        }\n        finally {\n            this._options.autoVacuum = autoVacuum;\n        }\n        this.maybeAutoVacuum();\n    }\n    /**\n     * It replaces an existing document with the given updated version\n     *\n     * It works by discarding the current version and adding the updated one, so\n     * it is functionally equivalent to calling {@link MiniSearch#discard}\n     * followed by {@link MiniSearch#add}. The ID of the updated document should\n     * be the same as the original one.\n     *\n     * Since it uses {@link MiniSearch#discard} internally, this method relies on\n     * vacuuming to clean up obsolete document references from the index, allowing\n     * memory to be released (see {@link MiniSearch#discard}).\n     *\n     * @param updatedDocument  The updated document to replace the old version\n     * with\n     */\n    replace(updatedDocument) {\n        const { idField, extractField } = this._options;\n        const id = extractField(updatedDocument, idField);\n        this.discard(id);\n        this.add(updatedDocument);\n    }\n    /**\n     * Triggers a manual vacuuming, cleaning up references to discarded documents\n     * from the inverted index\n     *\n     * Vacuuming is only useful for applications that use the {@link\n     * MiniSearch#discard} or {@link MiniSearch#replace} methods.\n     *\n     * By default, vacuuming is performed automatically when needed (controlled by\n     * the `autoVacuum` field in {@link Options}), so there is usually no need to\n     * call this method, unless one wants to make sure to perform vacuuming at a\n     * specific moment.\n     *\n     * Vacuuming traverses all terms in the inverted index in batches, and cleans\n     * up references to discarded documents from the posting list, allowing memory\n     * to be released.\n     *\n     * The method takes an optional object as argument with the following keys:\n     *\n     *   - `batchSize`: the size of each batch (1000 by default)\n     *\n     *   - `batchWait`: the number of milliseconds to wait between batches (10 by\n     *   default)\n     *\n     * On large indexes, vacuuming could have a non-negligible cost: batching\n     * avoids blocking the thread for long, diluting this cost so that it is not\n     * negatively affecting the application. Nonetheless, this method should only\n     * be called when necessary, and relying on automatic vacuuming is usually\n     * better.\n     *\n     * It returns a promise that resolves (to undefined) when the clean up is\n     * completed. If vacuuming is already ongoing at the time this method is\n     * called, a new one is enqueued immediately after the ongoing one, and a\n     * corresponding promise is returned. However, no more than one vacuuming is\n     * enqueued on top of the ongoing one, even if this method is called more\n     * times (enqueuing multiple ones would be useless).\n     *\n     * @param options  Configuration options for the batch size and delay. See\n     * {@link VacuumOptions}.\n     */\n    vacuum(options = {}) {\n        return this.conditionalVacuum(options);\n    }\n    conditionalVacuum(options, conditions) {\n        // If a vacuum is already ongoing, schedule another as soon as it finishes,\n        // unless there's already one enqueued. If one was already enqueued, do not\n        // enqueue another on top, but make sure that the conditions are the\n        // broadest.\n        if (this._currentVacuum) {\n            this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions;\n            if (this._enqueuedVacuum != null) {\n                return this._enqueuedVacuum;\n            }\n            this._enqueuedVacuum = this._currentVacuum.then(() => {\n                const conditions = this._enqueuedVacuumConditions;\n                this._enqueuedVacuumConditions = defaultVacuumConditions;\n                return this.performVacuuming(options, conditions);\n            });\n            return this._enqueuedVacuum;\n        }\n        if (this.vacuumConditionsMet(conditions) === false) {\n            return Promise.resolve();\n        }\n        this._currentVacuum = this.performVacuuming(options);\n        return this._currentVacuum;\n    }\n    async performVacuuming(options, conditions) {\n        const initialDirtCount = this._dirtCount;\n        if (this.vacuumConditionsMet(conditions)) {\n            const batchSize = options.batchSize || defaultVacuumOptions.batchSize;\n            const batchWait = options.batchWait || defaultVacuumOptions.batchWait;\n            let i = 1;\n            for (const [term, fieldsData] of this._index) {\n                for (const [fieldId, fieldIndex] of fieldsData) {\n                    for (const [shortId] of fieldIndex) {\n                        if (this._documentIds.has(shortId)) {\n                            continue;\n                        }\n                        if (fieldIndex.size <= 1) {\n                            fieldsData.delete(fieldId);\n                        }\n                        else {\n                            fieldIndex.delete(shortId);\n                        }\n                    }\n                }\n                if (this._index.get(term).size === 0) {\n                    this._index.delete(term);\n                }\n                if (i % batchSize === 0) {\n                    await new Promise((resolve) => setTimeout(resolve, batchWait));\n                }\n                i += 1;\n            }\n            this._dirtCount -= initialDirtCount;\n        }\n        // Make the next lines always async, so they execute after this function returns\n        await null;\n        this._currentVacuum = this._enqueuedVacuum;\n        this._enqueuedVacuum = null;\n    }\n    vacuumConditionsMet(conditions) {\n        if (conditions == null) {\n            return true;\n        }\n        let { minDirtCount, minDirtFactor } = conditions;\n        minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount;\n        minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor;\n        return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor;\n    }\n    /**\n     * Is `true` if a vacuuming operation is ongoing, `false` otherwise\n     */\n    get isVacuuming() {\n        return this._currentVacuum != null;\n    }\n    /**\n     * The number of documents discarded since the most recent vacuuming\n     */\n    get dirtCount() {\n        return this._dirtCount;\n    }\n    /**\n     * A number between 0 and 1 giving an indication about the proportion of\n     * documents that are discarded, and can therefore be cleaned up by vacuuming.\n     * A value close to 0 means that the index is relatively clean, while a higher\n     * value means that the index is relatively dirty, and vacuuming could release\n     * memory.\n     */\n    get dirtFactor() {\n        return this._dirtCount / (1 + this._documentCount + this._dirtCount);\n    }\n    /**\n     * Returns `true` if a document with the given ID is present in the index and\n     * available for search, `false` otherwise\n     *\n     * @param id  The document ID\n     */\n    has(id) {\n        return this._idToShortId.has(id);\n    }\n    /**\n     * Returns the stored fields (as configured in the `storeFields` constructor\n     * option) for the given document ID. Returns `undefined` if the document is\n     * not present in the index.\n     *\n     * @param id  The document ID\n     */\n    getStoredFields(id) {\n        const shortId = this._idToShortId.get(id);\n        if (shortId == null) {\n            return undefined;\n        }\n        return this._storedFields.get(shortId);\n    }\n    /**\n     * Search for documents matching the given search query.\n     *\n     * The result is a list of scored document IDs matching the query, sorted by\n     * descending score, and each including data about which terms were matched and\n     * in which fields.\n     *\n     * ### Basic usage:\n     *\n     * ```javascript\n     * // Search for \"zen art motorcycle\" with default options: terms have to match\n     * // exactly, and individual terms are joined with OR\n     * miniSearch.search('zen art motorcycle')\n     * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]\n     * ```\n     *\n     * ### Restrict search to specific fields:\n     *\n     * ```javascript\n     * // Search only in the 'title' field\n     * miniSearch.search('zen', { fields: ['title'] })\n     * ```\n     *\n     * ### Field boosting:\n     *\n     * ```javascript\n     * // Boost a field\n     * miniSearch.search('zen', { boost: { title: 2 } })\n     * ```\n     *\n     * ### Prefix search:\n     *\n     * ```javascript\n     * // Search for \"moto\" with prefix search (it will match documents\n     * // containing terms that start with \"moto\" or \"neuro\")\n     * miniSearch.search('moto neuro', { prefix: true })\n     * ```\n     *\n     * ### Fuzzy search:\n     *\n     * ```javascript\n     * // Search for \"ismael\" with fuzzy search (it will match documents containing\n     * // terms similar to \"ismael\", with a maximum edit distance of 0.2 term.length\n     * // (rounded to nearest integer)\n     * miniSearch.search('ismael', { fuzzy: 0.2 })\n     * ```\n     *\n     * ### Combining strategies:\n     *\n     * ```javascript\n     * // Mix of exact match, prefix search, and fuzzy search\n     * miniSearch.search('ismael mob', {\n     *  prefix: true,\n     *  fuzzy: 0.2\n     * })\n     * ```\n     *\n     * ### Advanced prefix and fuzzy search:\n     *\n     * ```javascript\n     * // Perform fuzzy and prefix search depending on the search term. Here\n     * // performing prefix and fuzzy search only on terms longer than 3 characters\n     * miniSearch.search('ismael mob', {\n     *  prefix: term => term.length > 3\n     *  fuzzy: term => term.length > 3 ? 0.2 : null\n     * })\n     * ```\n     *\n     * ### Combine with AND:\n     *\n     * ```javascript\n     * // Combine search terms with AND (to match only documents that contain both\n     * // \"motorcycle\" and \"art\")\n     * miniSearch.search('motorcycle art', { combineWith: 'AND' })\n     * ```\n     *\n     * ### Combine with AND_NOT:\n     *\n     * There is also an AND_NOT combinator, that finds documents that match the\n     * first term, but do not match any of the other terms. This combinator is\n     * rarely useful with simple queries, and is meant to be used with advanced\n     * query combinations (see later for more details).\n     *\n     * ### Filtering results:\n     *\n     * ```javascript\n     * // Filter only results in the 'fiction' category (assuming that 'category'\n     * // is a stored field)\n     * miniSearch.search('motorcycle art', {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * ```\n     *\n     * ### Wildcard query\n     *\n     * Searching for an empty string (assuming the default tokenizer) returns no\n     * results. Sometimes though, one needs to match all documents, like in a\n     * \"wildcard\" search. This is possible by passing the special value\n     * {@link MiniSearch.wildcard} as the query:\n     *\n     * ```javascript\n     * // Return search results for all documents\n     * miniSearch.search(MiniSearch.wildcard)\n     * ```\n     *\n     * Note that search options such as `filter` and `boostDocument` are still\n     * applied, influencing which results are returned, and their order:\n     *\n     * ```javascript\n     * // Return search results for all documents in the 'fiction' category\n     * miniSearch.search(MiniSearch.wildcard, {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * ```\n     *\n     * ### Advanced combination of queries:\n     *\n     * It is possible to combine different subqueries with OR, AND, and AND_NOT,\n     * and even with different search options, by passing a query expression\n     * tree object as the first argument, instead of a string.\n     *\n     * ```javascript\n     * // Search for documents that contain \"zen\" and (\"motorcycle\" or \"archery\")\n     * miniSearch.search({\n     *   combineWith: 'AND',\n     *   queries: [\n     *     'zen',\n     *     {\n     *       combineWith: 'OR',\n     *       queries: ['motorcycle', 'archery']\n     *     }\n     *   ]\n     * })\n     *\n     * // Search for documents that contain (\"apple\" or \"pear\") but not \"juice\" and\n     * // not \"tree\"\n     * miniSearch.search({\n     *   combineWith: 'AND_NOT',\n     *   queries: [\n     *     {\n     *       combineWith: 'OR',\n     *       queries: ['apple', 'pear']\n     *     },\n     *     'juice',\n     *     'tree'\n     *   ]\n     * })\n     * ```\n     *\n     * Each node in the expression tree can be either a string, or an object that\n     * supports all {@link SearchOptions} fields, plus a `queries` array field for\n     * subqueries.\n     *\n     * Note that, while this can become complicated to do by hand for complex or\n     * deeply nested queries, it provides a formalized expression tree API for\n     * external libraries that implement a parser for custom query languages.\n     *\n     * @param query  Search query\n     * @param searchOptions  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.\n     */\n    search(query, searchOptions = {}) {\n        const { searchOptions: globalSearchOptions } = this._options;\n        const searchOptionsWithDefaults = { ...globalSearchOptions, ...searchOptions };\n        const rawResults = this.executeQuery(query, searchOptions);\n        const results = [];\n        for (const [docId, { score, terms, match }] of rawResults) {\n            // terms are the matched query terms, which will be returned to the user\n            // as queryTerms. The quality is calculated based on them, as opposed to\n            // the matched terms in the document (which can be different due to\n            // prefix and fuzzy match)\n            const quality = terms.length || 1;\n            const result = {\n                id: this._documentIds.get(docId),\n                score: score * quality,\n                terms: Object.keys(match),\n                queryTerms: terms,\n                match\n            };\n            Object.assign(result, this._storedFields.get(docId));\n            if (searchOptionsWithDefaults.filter == null || searchOptionsWithDefaults.filter(result)) {\n                results.push(result);\n            }\n        }\n        // If it's a wildcard query, and no document boost is applied, skip sorting\n        // the results, as all results have the same score of 1\n        if (query === MiniSearch.wildcard && searchOptionsWithDefaults.boostDocument == null) {\n            return results;\n        }\n        results.sort(byScore);\n        return results;\n    }\n    /**\n     * Provide suggestions for the given search query\n     *\n     * The result is a list of suggested modified search queries, derived from the\n     * given search query, each with a relevance score, sorted by descending score.\n     *\n     * By default, it uses the same options used for search, except that by\n     * default it performs prefix search on the last term of the query, and\n     * combine terms with `'AND'` (requiring all query terms to match). Custom\n     * options can be passed as a second argument. Defaults can be changed upon\n     * calling the {@link MiniSearch} constructor, by passing a\n     * `autoSuggestOptions` option.\n     *\n     * ### Basic usage:\n     *\n     * ```javascript\n     * // Get suggestions for 'neuro':\n     * miniSearch.autoSuggest('neuro')\n     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]\n     * ```\n     *\n     * ### Multiple words:\n     *\n     * ```javascript\n     * // Get suggestions for 'zen ar':\n     * miniSearch.autoSuggest('zen ar')\n     * // => [\n     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n     * // ]\n     * ```\n     *\n     * ### Fuzzy suggestions:\n     *\n     * ```javascript\n     * // Correct spelling mistakes using fuzzy search:\n     * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\n     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\n     * ```\n     *\n     * ### Filtering:\n     *\n     * ```javascript\n     * // Get suggestions for 'zen ar', but only within the 'fiction' category\n     * // (assuming that 'category' is a stored field):\n     * miniSearch.autoSuggest('zen ar', {\n     *   filter: (result) => result.category === 'fiction'\n     * })\n     * // => [\n     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\n     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }\n     * // ]\n     * ```\n     *\n     * @param queryString  Query string to be expanded into suggestions\n     * @param options  Search options. The supported options and default values\n     * are the same as for the {@link MiniSearch#search} method, except that by\n     * default prefix search is performed on the last term in the query, and terms\n     * are combined with `'AND'`.\n     * @return  A sorted array of suggestions sorted by relevance score.\n     */\n    autoSuggest(queryString, options = {}) {\n        options = { ...this._options.autoSuggestOptions, ...options };\n        const suggestions = new Map();\n        for (const { score, terms } of this.search(queryString, options)) {\n            const phrase = terms.join(' ');\n            const suggestion = suggestions.get(phrase);\n            if (suggestion != null) {\n                suggestion.score += score;\n                suggestion.count += 1;\n            }\n            else {\n                suggestions.set(phrase, { score, terms, count: 1 });\n            }\n        }\n        const results = [];\n        for (const [suggestion, { score, terms, count }] of suggestions) {\n            results.push({ suggestion, terms, score: score / count });\n        }\n        results.sort(byScore);\n        return results;\n    }\n    /**\n     * Total number of documents available to search\n     */\n    get documentCount() {\n        return this._documentCount;\n    }\n    /**\n     * Number of terms in the index\n     */\n    get termCount() {\n        return this._index.size;\n    }\n    /**\n     * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)\n     * and instantiates a MiniSearch instance. It should be given the same options\n     * originally used when serializing the index.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // If the index was serialized with:\n     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * miniSearch.addAll(documents)\n     *\n     * const json = JSON.stringify(miniSearch)\n     * // It can later be deserialized like this:\n     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n     * ```\n     *\n     * @param json  JSON-serialized index\n     * @param options  configuration options, same as the constructor\n     * @return An instance of MiniSearch deserialized from the given JSON.\n     */\n    static loadJSON(json, options) {\n        if (options == null) {\n            throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');\n        }\n        return this.loadJS(JSON.parse(json), options);\n    }\n    /**\n     * Async equivalent of {@link MiniSearch.loadJSON}\n     *\n     * This function is an alternative to {@link MiniSearch.loadJSON} that returns\n     * a promise, and loads the index in batches, leaving pauses between them to avoid\n     * blocking the main thread. It tends to be slower than the synchronous\n     * version, but does not block the main thread, so it can be a better choice\n     * when deserializing very large indexes.\n     *\n     * @param json  JSON-serialized index\n     * @param options  configuration options, same as the constructor\n     * @return A Promise that will resolve to an instance of MiniSearch deserialized from the given JSON.\n     */\n    static async loadJSONAsync(json, options) {\n        if (options == null) {\n            throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');\n        }\n        return this.loadJSAsync(JSON.parse(json), options);\n    }\n    /**\n     * Returns the default value of an option. It will throw an error if no option\n     * with the given name exists.\n     *\n     * @param optionName  Name of the option\n     * @return The default value of the given option\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // Get default tokenizer\n     * MiniSearch.getDefault('tokenize')\n     *\n     * // Get default term processor\n     * MiniSearch.getDefault('processTerm')\n     *\n     * // Unknown options will throw an error\n     * MiniSearch.getDefault('notExisting')\n     * // => throws 'MiniSearch: unknown option \"notExisting\"'\n     * ```\n     */\n    static getDefault(optionName) {\n        if (defaultOptions.hasOwnProperty(optionName)) {\n            return getOwnProperty(defaultOptions, optionName);\n        }\n        else {\n            throw new Error(`MiniSearch: unknown option \"${optionName}\"`);\n        }\n    }\n    /**\n     * @ignore\n     */\n    static loadJS(js, options) {\n        const { index, documentIds, fieldLength, storedFields, serializationVersion } = js;\n        const miniSearch = this.instantiateMiniSearch(js, options);\n        miniSearch._documentIds = objectToNumericMap(documentIds);\n        miniSearch._fieldLength = objectToNumericMap(fieldLength);\n        miniSearch._storedFields = objectToNumericMap(storedFields);\n        for (const [shortId, id] of miniSearch._documentIds) {\n            miniSearch._idToShortId.set(id, shortId);\n        }\n        for (const [term, data] of index) {\n            const dataMap = new Map();\n            for (const fieldId of Object.keys(data)) {\n                let indexEntry = data[fieldId];\n                // Version 1 used to nest the index entry inside a field called ds\n                if (serializationVersion === 1) {\n                    indexEntry = indexEntry.ds;\n                }\n                dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry));\n            }\n            miniSearch._index.set(term, dataMap);\n        }\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    static async loadJSAsync(js, options) {\n        const { index, documentIds, fieldLength, storedFields, serializationVersion } = js;\n        const miniSearch = this.instantiateMiniSearch(js, options);\n        miniSearch._documentIds = await objectToNumericMapAsync(documentIds);\n        miniSearch._fieldLength = await objectToNumericMapAsync(fieldLength);\n        miniSearch._storedFields = await objectToNumericMapAsync(storedFields);\n        for (const [shortId, id] of miniSearch._documentIds) {\n            miniSearch._idToShortId.set(id, shortId);\n        }\n        let count = 0;\n        for (const [term, data] of index) {\n            const dataMap = new Map();\n            for (const fieldId of Object.keys(data)) {\n                let indexEntry = data[fieldId];\n                // Version 1 used to nest the index entry inside a field called ds\n                if (serializationVersion === 1) {\n                    indexEntry = indexEntry.ds;\n                }\n                dataMap.set(parseInt(fieldId, 10), await objectToNumericMapAsync(indexEntry));\n            }\n            if (++count % 1000 === 0)\n                await wait(0);\n            miniSearch._index.set(term, dataMap);\n        }\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    static instantiateMiniSearch(js, options) {\n        const { documentCount, nextId, fieldIds, averageFieldLength, dirtCount, serializationVersion } = js;\n        if (serializationVersion !== 1 && serializationVersion !== 2) {\n            throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version');\n        }\n        const miniSearch = new MiniSearch(options);\n        miniSearch._documentCount = documentCount;\n        miniSearch._nextId = nextId;\n        miniSearch._idToShortId = new Map();\n        miniSearch._fieldIds = fieldIds;\n        miniSearch._avgFieldLength = averageFieldLength;\n        miniSearch._dirtCount = dirtCount || 0;\n        miniSearch._index = new SearchableMap();\n        return miniSearch;\n    }\n    /**\n     * @ignore\n     */\n    executeQuery(query, searchOptions = {}) {\n        if (query === MiniSearch.wildcard) {\n            return this.executeWildcardQuery(searchOptions);\n        }\n        if (typeof query !== 'string') {\n            const options = { ...searchOptions, ...query, queries: undefined };\n            const results = query.queries.map((subquery) => this.executeQuery(subquery, options));\n            return this.combineResults(results, options.combineWith);\n        }\n        const { tokenize, processTerm, searchOptions: globalSearchOptions } = this._options;\n        const options = { tokenize, processTerm, ...globalSearchOptions, ...searchOptions };\n        const { tokenize: searchTokenize, processTerm: searchProcessTerm } = options;\n        const terms = searchTokenize(query)\n            .flatMap((term) => searchProcessTerm(term))\n            .filter((term) => !!term);\n        const queries = terms.map(termToQuerySpec(options));\n        const results = queries.map(query => this.executeQuerySpec(query, options));\n        return this.combineResults(results, options.combineWith);\n    }\n    /**\n     * @ignore\n     */\n    executeQuerySpec(query, searchOptions) {\n        const options = { ...this._options.searchOptions, ...searchOptions };\n        const boosts = (options.fields || this._options.fields).reduce((boosts, field) => ({ ...boosts, [field]: getOwnProperty(options.boost, field) || 1 }), {});\n        const { boostDocument, weights, maxFuzzy, bm25: bm25params } = options;\n        const { fuzzy: fuzzyWeight, prefix: prefixWeight } = { ...defaultSearchOptions.weights, ...weights };\n        const data = this._index.get(query.term);\n        const results = this.termResults(query.term, query.term, 1, query.termBoost, data, boosts, boostDocument, bm25params);\n        let prefixMatches;\n        let fuzzyMatches;\n        if (query.prefix) {\n            prefixMatches = this._index.atPrefix(query.term);\n        }\n        if (query.fuzzy) {\n            const fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy;\n            const maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy;\n            if (maxDistance)\n                fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance);\n        }\n        if (prefixMatches) {\n            for (const [term, data] of prefixMatches) {\n                const distance = term.length - query.term.length;\n                if (!distance) {\n                    continue;\n                } // Skip exact match.\n                // Delete the term from fuzzy results (if present) if it is also a\n                // prefix result. This entry will always be scored as a prefix result.\n                fuzzyMatches === null || fuzzyMatches === void 0 ? void 0 : fuzzyMatches.delete(term);\n                // Weight gradually approaches 0 as distance goes to infinity, with the\n                // weight for the hypothetical distance 0 being equal to prefixWeight.\n                // The rate of change is much lower than that of fuzzy matches to\n                // account for the fact that prefix matches stay more relevant than\n                // fuzzy matches for longer distances.\n                const weight = prefixWeight * term.length / (term.length + 0.3 * distance);\n                this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results);\n            }\n        }\n        if (fuzzyMatches) {\n            for (const term of fuzzyMatches.keys()) {\n                const [data, distance] = fuzzyMatches.get(term);\n                if (!distance) {\n                    continue;\n                } // Skip exact match.\n                // Weight gradually approaches 0 as distance goes to infinity, with the\n                // weight for the hypothetical distance 0 being equal to fuzzyWeight.\n                const weight = fuzzyWeight * term.length / (term.length + distance);\n                this.termResults(query.term, term, weight, query.termBoost, data, boosts, boostDocument, bm25params, results);\n            }\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    executeWildcardQuery(searchOptions) {\n        const results = new Map();\n        const options = { ...this._options.searchOptions, ...searchOptions };\n        for (const [shortId, id] of this._documentIds) {\n            const score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1;\n            results.set(shortId, {\n                score,\n                terms: [],\n                match: {}\n            });\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    combineResults(results, combineWith = OR) {\n        if (results.length === 0) {\n            return new Map();\n        }\n        const operator = combineWith.toLowerCase();\n        const combinator = combinators[operator];\n        if (!combinator) {\n            throw new Error(`Invalid combination operator: ${combineWith}`);\n        }\n        return results.reduce(combinator) || new Map();\n    }\n    /**\n     * Allows serialization of the index to JSON, to possibly store it and later\n     * deserialize it with {@link MiniSearch.loadJSON}.\n     *\n     * Normally one does not directly call this method, but rather call the\n     * standard JavaScript `JSON.stringify()` passing the {@link MiniSearch}\n     * instance, and JavaScript will internally call this method. Upon\n     * deserialization, one must pass to {@link MiniSearch.loadJSON} the same\n     * options used to create the original instance that was serialized.\n     *\n     * ### Usage:\n     *\n     * ```javascript\n     * // Serialize the index:\n     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })\n     * miniSearch.addAll(documents)\n     * const json = JSON.stringify(miniSearch)\n     *\n     * // Later, to deserialize it:\n     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })\n     * ```\n     *\n     * @return A plain-object serializable representation of the search index.\n     */\n    toJSON() {\n        const index = [];\n        for (const [term, fieldIndex] of this._index) {\n            const data = {};\n            for (const [fieldId, freqs] of fieldIndex) {\n                data[fieldId] = Object.fromEntries(freqs);\n            }\n            index.push([term, data]);\n        }\n        return {\n            documentCount: this._documentCount,\n            nextId: this._nextId,\n            documentIds: Object.fromEntries(this._documentIds),\n            fieldIds: this._fieldIds,\n            fieldLength: Object.fromEntries(this._fieldLength),\n            averageFieldLength: this._avgFieldLength,\n            storedFields: Object.fromEntries(this._storedFields),\n            dirtCount: this._dirtCount,\n            index,\n            serializationVersion: 2\n        };\n    }\n    /**\n     * @ignore\n     */\n    termResults(sourceTerm, derivedTerm, termWeight, termBoost, fieldTermData, fieldBoosts, boostDocumentFn, bm25params, results = new Map()) {\n        if (fieldTermData == null)\n            return results;\n        for (const field of Object.keys(fieldBoosts)) {\n            const fieldBoost = fieldBoosts[field];\n            const fieldId = this._fieldIds[field];\n            const fieldTermFreqs = fieldTermData.get(fieldId);\n            if (fieldTermFreqs == null)\n                continue;\n            let matchingFields = fieldTermFreqs.size;\n            const avgFieldLength = this._avgFieldLength[fieldId];\n            for (const docId of fieldTermFreqs.keys()) {\n                if (!this._documentIds.has(docId)) {\n                    this.removeTerm(fieldId, docId, derivedTerm);\n                    matchingFields -= 1;\n                    continue;\n                }\n                const docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1;\n                if (!docBoost)\n                    continue;\n                const termFreq = fieldTermFreqs.get(docId);\n                const fieldLength = this._fieldLength.get(docId)[fieldId];\n                // NOTE: The total number of fields is set to the number of documents\n                // `this._documentCount`. It could also make sense to use the number of\n                // documents where the current field is non-blank as a normalization\n                // factor. This will make a difference in scoring if the field is rarely\n                // present. This is currently not supported, and may require further\n                // analysis to see if it is a valid use case.\n                const rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params);\n                const weightedScore = termWeight * termBoost * fieldBoost * docBoost * rawScore;\n                const result = results.get(docId);\n                if (result) {\n                    result.score += weightedScore;\n                    assignUniqueTerm(result.terms, sourceTerm);\n                    const match = getOwnProperty(result.match, derivedTerm);\n                    if (match) {\n                        match.push(field);\n                    }\n                    else {\n                        result.match[derivedTerm] = [field];\n                    }\n                }\n                else {\n                    results.set(docId, {\n                        score: weightedScore,\n                        terms: [sourceTerm],\n                        match: { [derivedTerm]: [field] }\n                    });\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * @ignore\n     */\n    addTerm(fieldId, documentId, term) {\n        const indexData = this._index.fetch(term, createMap);\n        let fieldIndex = indexData.get(fieldId);\n        if (fieldIndex == null) {\n            fieldIndex = new Map();\n            fieldIndex.set(documentId, 1);\n            indexData.set(fieldId, fieldIndex);\n        }\n        else {\n            const docs = fieldIndex.get(documentId);\n            fieldIndex.set(documentId, (docs || 0) + 1);\n        }\n    }\n    /**\n     * @ignore\n     */\n    removeTerm(fieldId, documentId, term) {\n        if (!this._index.has(term)) {\n            this.warnDocumentChanged(documentId, fieldId, term);\n            return;\n        }\n        const indexData = this._index.fetch(term, createMap);\n        const fieldIndex = indexData.get(fieldId);\n        if (fieldIndex == null || fieldIndex.get(documentId) == null) {\n            this.warnDocumentChanged(documentId, fieldId, term);\n        }\n        else if (fieldIndex.get(documentId) <= 1) {\n            if (fieldIndex.size <= 1) {\n                indexData.delete(fieldId);\n            }\n            else {\n                fieldIndex.delete(documentId);\n            }\n        }\n        else {\n            fieldIndex.set(documentId, fieldIndex.get(documentId) - 1);\n        }\n        if (this._index.get(term).size === 0) {\n            this._index.delete(term);\n        }\n    }\n    /**\n     * @ignore\n     */\n    warnDocumentChanged(shortDocumentId, fieldId, term) {\n        for (const fieldName of Object.keys(this._fieldIds)) {\n            if (this._fieldIds[fieldName] === fieldId) {\n                this._options.logger('warn', `MiniSearch: document with ID ${this._documentIds.get(shortDocumentId)} has changed before removal: term \"${term}\" was not present in field \"${fieldName}\". Removing a document after it has changed can corrupt the index!`, 'version_conflict');\n                return;\n            }\n        }\n    }\n    /**\n     * @ignore\n     */\n    addDocumentId(documentId) {\n        const shortDocumentId = this._nextId;\n        this._idToShortId.set(documentId, shortDocumentId);\n        this._documentIds.set(shortDocumentId, documentId);\n        this._documentCount += 1;\n        this._nextId += 1;\n        return shortDocumentId;\n    }\n    /**\n     * @ignore\n     */\n    addFields(fields) {\n        for (let i = 0; i < fields.length; i++) {\n            this._fieldIds[fields[i]] = i;\n        }\n    }\n    /**\n     * @ignore\n     */\n    addFieldLength(documentId, fieldId, count, length) {\n        let fieldLengths = this._fieldLength.get(documentId);\n        if (fieldLengths == null)\n            this._fieldLength.set(documentId, fieldLengths = []);\n        fieldLengths[fieldId] = length;\n        const averageFieldLength = this._avgFieldLength[fieldId] || 0;\n        const totalFieldLength = (averageFieldLength * count) + length;\n        this._avgFieldLength[fieldId] = totalFieldLength / (count + 1);\n    }\n    /**\n     * @ignore\n     */\n    removeFieldLength(documentId, fieldId, count, length) {\n        if (count === 1) {\n            this._avgFieldLength[fieldId] = 0;\n            return;\n        }\n        const totalFieldLength = (this._avgFieldLength[fieldId] * count) - length;\n        this._avgFieldLength[fieldId] = totalFieldLength / (count - 1);\n    }\n    /**\n     * @ignore\n     */\n    saveStoredFields(documentId, doc) {\n        const { storeFields, extractField } = this._options;\n        if (storeFields == null || storeFields.length === 0) {\n            return;\n        }\n        let documentFields = this._storedFields.get(documentId);\n        if (documentFields == null)\n            this._storedFields.set(documentId, documentFields = {});\n        for (const fieldName of storeFields) {\n            const fieldValue = extractField(doc, fieldName);\n            if (fieldValue !== undefined)\n                documentFields[fieldName] = fieldValue;\n        }\n    }\n}\n/**\n * The special wildcard symbol that can be passed to {@link MiniSearch#search}\n * to match all documents\n */\nMiniSearch.wildcard = Symbol('*');\nconst getOwnProperty = (object, property) => Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;\nconst combinators = {\n    [OR]: (a, b) => {\n        for (const docId of b.keys()) {\n            const existing = a.get(docId);\n            if (existing == null) {\n                a.set(docId, b.get(docId));\n            }\n            else {\n                const { score, terms, match } = b.get(docId);\n                existing.score = existing.score + score;\n                existing.match = Object.assign(existing.match, match);\n                assignUniqueTerms(existing.terms, terms);\n            }\n        }\n        return a;\n    },\n    [AND]: (a, b) => {\n        const combined = new Map();\n        for (const docId of b.keys()) {\n            const existing = a.get(docId);\n            if (existing == null)\n                continue;\n            const { score, terms, match } = b.get(docId);\n            assignUniqueTerms(existing.terms, terms);\n            combined.set(docId, {\n                score: existing.score + score,\n                terms: existing.terms,\n                match: Object.assign(existing.match, match)\n            });\n        }\n        return combined;\n    },\n    [AND_NOT]: (a, b) => {\n        for (const docId of b.keys())\n            a.delete(docId);\n        return a;\n    }\n};\nconst defaultBM25params = { k: 1.2, b: 0.7, d: 0.5 };\nconst calcBM25Score = (termFreq, matchingCount, totalCount, fieldLength, avgFieldLength, bm25params) => {\n    const { k, b, d } = bm25params;\n    const invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5));\n    return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)));\n};\nconst termToQuerySpec = (options) => (term, i, terms) => {\n    const fuzzy = (typeof options.fuzzy === 'function')\n        ? options.fuzzy(term, i, terms)\n        : (options.fuzzy || false);\n    const prefix = (typeof options.prefix === 'function')\n        ? options.prefix(term, i, terms)\n        : (options.prefix === true);\n    const termBoost = (typeof options.boostTerm === 'function')\n        ? options.boostTerm(term, i, terms)\n        : 1;\n    return { term, fuzzy, prefix, termBoost };\n};\nconst defaultOptions = {\n    idField: 'id',\n    extractField: (document, fieldName) => document[fieldName],\n    tokenize: (text) => text.split(SPACE_OR_PUNCTUATION),\n    processTerm: (term) => term.toLowerCase(),\n    fields: undefined,\n    searchOptions: undefined,\n    storeFields: [],\n    logger: (level, message) => {\n        if (typeof (console === null || console === void 0 ? void 0 : console[level]) === 'function')\n            console[level](message);\n    },\n    autoVacuum: true\n};\nconst defaultSearchOptions = {\n    combineWith: OR,\n    prefix: false,\n    fuzzy: false,\n    maxFuzzy: 6,\n    boost: {},\n    weights: { fuzzy: 0.45, prefix: 0.375 },\n    bm25: defaultBM25params\n};\nconst defaultAutoSuggestOptions = {\n    combineWith: AND,\n    prefix: (term, i, terms) => i === terms.length - 1\n};\nconst defaultVacuumOptions = { batchSize: 1000, batchWait: 10 };\nconst defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 };\nconst defaultAutoVacuumOptions = { ...defaultVacuumOptions, ...defaultVacuumConditions };\nconst assignUniqueTerm = (target, term) => {\n    // Avoid adding duplicate terms.\n    if (!target.includes(term))\n        target.push(term);\n};\nconst assignUniqueTerms = (target, source) => {\n    for (const term of source) {\n        // Avoid adding duplicate terms.\n        if (!target.includes(term))\n            target.push(term);\n    }\n};\nconst byScore = ({ score: a }, { score: b }) => b - a;\nconst createMap = () => new Map();\nconst objectToNumericMap = (object) => {\n    const map = new Map();\n    for (const key of Object.keys(object)) {\n        map.set(parseInt(key, 10), object[key]);\n    }\n    return map;\n};\nconst objectToNumericMapAsync = async (object) => {\n    const map = new Map();\n    let count = 0;\n    for (const key of Object.keys(object)) {\n        map.set(parseInt(key, 10), object[key]);\n        if (++count % 1000 === 0) {\n            await wait(0);\n        }\n    }\n    return map;\n};\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n// This regular expression matches any Unicode space, newline, or punctuation\n// character\nconst SPACE_OR_PUNCTUATION = /[\\n\\r\\p{Z}\\p{P}]+/u;\n\nexport { MiniSearch as default };\n//# sourceMappingURL=index.js.map\n","// adapted from https://stackoverflow.com/a/46432113/11613622\nexport class LRUCache {\n    max;\n    cache;\n    constructor(max = 10) {\n        this.max = max;\n        this.cache = new Map();\n    }\n    get(key) {\n        let item = this.cache.get(key);\n        if (item !== undefined) {\n            // refresh key\n            this.cache.delete(key);\n            this.cache.set(key, item);\n        }\n        return item;\n    }\n    set(key, val) {\n        // refresh key\n        if (this.cache.has(key))\n            this.cache.delete(key);\n        // evict oldest\n        else if (this.cache.size === this.max)\n            this.cache.delete(this.first());\n        this.cache.set(key, val);\n    }\n    first() {\n        return this.cache.keys().next().value;\n    }\n    clear() {\n        this.cache.clear();\n    }\n}\n","<script lang=\"ts\" setup>\nimport localSearchIndex from '@localSearchIndex'\nimport {\n  computedAsync,\n  debouncedWatch,\n  onKeyStroke,\n  useEventListener,\n  useLocalStorage,\n  useScrollLock,\n  useSessionStorage\n} from '@vueuse/core'\nimport { useFocusTrap } from '@vueuse/integrations/useFocusTrap'\nimport Mark from 'mark.js/src/vanilla.js'\nimport MiniSearch, { type SearchResult } from 'minisearch'\nimport { dataSymbol, inBrowser, useRouter } from 'vitepress'\nimport {\n  computed,\n  createApp,\n  markRaw,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  shallowRef,\n  watch,\n  watchEffect,\n  type Ref\n} from 'vue'\nimport type { ModalTranslations } from '../../../../types/local-search'\nimport { pathToFile } from '../../app/utils'\nimport { escapeRegExp } from '../../shared'\nimport { useData } from '../composables/data'\nimport { LRUCache } from '../support/lru'\nimport { createSearchTranslate } from '../support/translation'\n\nconst emit = defineEmits<{\n  (e: 'close'): void\n}>()\n\nconst el = shallowRef<HTMLElement>()\nconst resultsEl = shallowRef<HTMLElement>()\n\n/* Search */\n\nconst searchIndexData = shallowRef(localSearchIndex)\n\n// hmr\nif (import.meta.hot) {\n  import.meta.hot.accept('/@localSearchIndex', (m) => {\n    if (m) {\n      searchIndexData.value = m.default\n    }\n  })\n}\n\ninterface Result {\n  title: string\n  titles: string[]\n  text?: string\n}\n\nconst vitePressData = useData()\nconst { activate } = useFocusTrap(el, {\n  immediate: true,\n  allowOutsideClick: true,\n  clickOutsideDeactivates: true,\n  escapeDeactivates: true\n})\nconst { localeIndex, theme } = vitePressData\nconst searchIndex = computedAsync(async () =>\n  markRaw(\n    MiniSearch.loadJSON<Result>(\n      (await searchIndexData.value[localeIndex.value]?.())?.default,\n      {\n        fields: ['title', 'titles', 'text'],\n        storeFields: ['title', 'titles'],\n        searchOptions: {\n          fuzzy: 0.2,\n          prefix: true,\n          boost: { title: 4, text: 2, titles: 1 },\n          ...(theme.value.search?.provider === 'local' &&\n            theme.value.search.options?.miniSearch?.searchOptions)\n        },\n        ...(theme.value.search?.provider === 'local' &&\n          theme.value.search.options?.miniSearch?.options)\n      }\n    )\n  )\n)\n\nconst disableQueryPersistence = computed(() => {\n  return (\n    theme.value.search?.provider === 'local' &&\n    theme.value.search.options?.disableQueryPersistence === true\n  )\n})\n\nconst filterText = disableQueryPersistence.value\n  ? ref('')\n  : useSessionStorage('vitepress:local-search-filter', '')\n\nconst showDetailedList = useLocalStorage(\n  'vitepress:local-search-detailed-list',\n  theme.value.search?.provider === 'local' &&\n    theme.value.search.options?.detailedView === true\n)\n\nconst disableDetailedView = computed(() => {\n  return (\n    theme.value.search?.provider === 'local' &&\n    (theme.value.search.options?.disableDetailedView === true ||\n      theme.value.search.options?.detailedView === false)\n  )\n})\n\nconst buttonText = computed(() => {\n  const options = theme.value.search?.options ?? theme.value.algolia\n\n  return (\n    options?.locales?.[localeIndex.value]?.translations?.button?.buttonText ||\n    options?.translations?.button?.buttonText ||\n    'Search'\n  )\n})\n\nwatchEffect(() => {\n  if (disableDetailedView.value) {\n    showDetailedList.value = false\n  }\n})\n\nconst results: Ref<(SearchResult & Result)[]> = shallowRef([])\n\nconst enableNoResults = ref(false)\n\nwatch(filterText, () => {\n  enableNoResults.value = false\n})\n\nconst mark = computedAsync(async () => {\n  if (!resultsEl.value) return\n  return markRaw(new Mark(resultsEl.value))\n}, null)\n\nconst cache = new LRUCache<string, Map<string, string>>(16) // 16 files\n\ndebouncedWatch(\n  () => [searchIndex.value, filterText.value, showDetailedList.value] as const,\n  async ([index, filterTextValue, showDetailedListValue], old, onCleanup) => {\n    if (old?.[0] !== index) {\n      // in case of hmr\n      cache.clear()\n    }\n\n    let canceled = false\n    onCleanup(() => {\n      canceled = true\n    })\n\n    if (!index) return\n\n    // Search\n    results.value = index\n      .search(filterTextValue)\n      .slice(0, 16) as (SearchResult & Result)[]\n    enableNoResults.value = true\n\n    // Highlighting\n    const mods = showDetailedListValue\n      ? await Promise.all(results.value.map((r) => fetchExcerpt(r.id)))\n      : []\n    if (canceled) return\n    for (const { id, mod } of mods) {\n      const mapId = id.slice(0, id.indexOf('#'))\n      let map = cache.get(mapId)\n      if (map) continue\n      map = new Map()\n      cache.set(mapId, map)\n      const comp = mod.default ?? mod\n      if (comp?.render || comp?.setup) {\n        const app = createApp(comp)\n        // Silence warnings about missing components\n        app.config.warnHandler = () => {}\n        app.provide(dataSymbol, vitePressData)\n        Object.defineProperties(app.config.globalProperties, {\n          $frontmatter: {\n            get() {\n              return vitePressData.frontmatter.value\n            }\n          },\n          $params: {\n            get() {\n              return vitePressData.page.value.params\n            }\n          }\n        })\n        const div = document.createElement('div')\n        app.mount(div)\n        const headings = div.querySelectorAll('h1, h2, h3, h4, h5, h6')\n        headings.forEach((el) => {\n          const href = el.querySelector('a')?.getAttribute('href')\n          const anchor = href?.startsWith('#') && href.slice(1)\n          if (!anchor) return\n          let html = ''\n          while ((el = el.nextElementSibling!) && !/^h[1-6]$/i.test(el.tagName))\n            html += el.outerHTML\n          map!.set(anchor, html)\n        })\n        app.unmount()\n      }\n      if (canceled) return\n    }\n\n    const terms = new Set<string>()\n\n    results.value = results.value.map((r) => {\n      const [id, anchor] = r.id.split('#')\n      const map = cache.get(id)\n      const text = map?.get(anchor) ?? ''\n      for (const term in r.match) {\n        terms.add(term)\n      }\n      return { ...r, text }\n    })\n\n    await nextTick()\n    if (canceled) return\n\n    await new Promise((r) => {\n      mark.value?.unmark({\n        done: () => {\n          mark.value?.markRegExp(formMarkRegex(terms), { done: r })\n        }\n      })\n    })\n\n    const excerpts = el.value?.querySelectorAll('.result .excerpt') ?? []\n    for (const excerpt of excerpts) {\n      excerpt\n        .querySelector('mark[data-markjs=\"true\"]')\n        ?.scrollIntoView({ block: 'center' })\n    }\n    // FIXME: without this whole page scrolls to the bottom\n    resultsEl.value?.firstElementChild?.scrollIntoView({ block: 'start' })\n  },\n  { debounce: 200, immediate: true }\n)\n\nasync function fetchExcerpt(id: string) {\n  const file = pathToFile(id.slice(0, id.indexOf('#')))\n  try {\n    if (!file) throw new Error(`Cannot find file for id: ${id}`)\n    return { id, mod: await import(/*@vite-ignore*/ file) }\n  } catch (e) {\n    console.error(e)\n    return { id, mod: {} }\n  }\n}\n\n/* Search input focus */\n\nconst searchInput = ref<HTMLInputElement>()\nconst disableReset = computed(() => {\n  return filterText.value?.length <= 0\n})\nfunction focusSearchInput(select = true) {\n  searchInput.value?.focus()\n  select && searchInput.value?.select()\n}\n\nonMounted(() => {\n  focusSearchInput()\n})\n\nfunction onSearchBarClick(event: PointerEvent) {\n  if (event.pointerType === 'mouse') {\n    focusSearchInput()\n  }\n}\n\n/* Search keyboard selection */\n\nconst selectedIndex = ref(-1)\nconst disableMouseOver = ref(true)\n\nwatch(results, (r) => {\n  selectedIndex.value = r.length ? 0 : -1\n  scrollToSelectedResult()\n})\n\nfunction scrollToSelectedResult() {\n  nextTick(() => {\n    const selectedEl = document.querySelector('.result.selected')\n    selectedEl?.scrollIntoView({ block: 'nearest' })\n  })\n}\n\nonKeyStroke('ArrowUp', (event) => {\n  event.preventDefault()\n  selectedIndex.value--\n  if (selectedIndex.value < 0) {\n    selectedIndex.value = results.value.length - 1\n  }\n  disableMouseOver.value = true\n  scrollToSelectedResult()\n})\n\nonKeyStroke('ArrowDown', (event) => {\n  event.preventDefault()\n  selectedIndex.value++\n  if (selectedIndex.value >= results.value.length) {\n    selectedIndex.value = 0\n  }\n  disableMouseOver.value = true\n  scrollToSelectedResult()\n})\n\nconst router = useRouter()\n\nonKeyStroke('Enter', (e) => {\n  if (e.isComposing) return\n\n  if (e.target instanceof HTMLButtonElement && e.target.type !== 'submit')\n    return\n\n  const selectedPackage = results.value[selectedIndex.value]\n  if (e.target instanceof HTMLInputElement && !selectedPackage) {\n    e.preventDefault()\n    return\n  }\n\n  if (selectedPackage) {\n    router.go(selectedPackage.id)\n    emit('close')\n  }\n})\n\nonKeyStroke('Escape', () => {\n  emit('close')\n})\n\n// Translations\nconst defaultTranslations: { modal: ModalTranslations } = {\n  modal: {\n    displayDetails: 'Display detailed list',\n    resetButtonTitle: 'Reset search',\n    backButtonTitle: 'Close search',\n    noResultsText: 'No results for',\n    footer: {\n      selectText: 'to select',\n      selectKeyAriaLabel: 'enter',\n      navigateText: 'to navigate',\n      navigateUpKeyAriaLabel: 'up arrow',\n      navigateDownKeyAriaLabel: 'down arrow',\n      closeText: 'to close',\n      closeKeyAriaLabel: 'escape'\n    }\n  }\n}\n\nconst translate = createSearchTranslate(defaultTranslations)\n\n// Back\n\nonMounted(() => {\n  // Prevents going to previous site\n  window.history.pushState(null, '', null)\n})\n\nuseEventListener('popstate', (event) => {\n  event.preventDefault()\n  emit('close')\n})\n\n/** Lock body */\nconst isLocked = useScrollLock(inBrowser ? document.body : null)\n\nonMounted(() => {\n  nextTick(() => {\n    isLocked.value = true\n    nextTick().then(() => activate())\n  })\n})\n\nonBeforeUnmount(() => {\n  isLocked.value = false\n})\n\nfunction resetSearch() {\n  filterText.value = ''\n  nextTick().then(() => focusSearchInput(false))\n}\n\nfunction formMarkRegex(terms: Set<string>) {\n  return new RegExp(\n    [...terms]\n      .sort((a, b) => b.length - a.length)\n      .map((term) => `(${escapeRegExp(term)})`)\n      .join('|'),\n    'gi'\n  )\n}\n\nfunction onMouseMove(e: MouseEvent) {\n  if (!disableMouseOver.value) return\n  const el = (e.target as HTMLElement)?.closest<HTMLAnchorElement>('.result')\n  const index = Number.parseInt(el?.dataset.index!)\n  if (index >= 0 && index !== selectedIndex.value) {\n    selectedIndex.value = index\n  }\n  disableMouseOver.value = false\n}\n</script>\n\n<template>\n  <Teleport to=\"body\">\n    <div\n      ref=\"el\"\n      role=\"button\"\n      :aria-owns=\"results?.length ? 'localsearch-list' : undefined\"\n      aria-expanded=\"true\"\n      aria-haspopup=\"listbox\"\n      aria-labelledby=\"localsearch-label\"\n      class=\"VPLocalSearchBox\"\n    >\n      <div class=\"backdrop\" @click=\"$emit('close')\" />\n\n      <div class=\"shell\">\n        <form\n          class=\"search-bar\"\n          @pointerup=\"onSearchBarClick($event)\"\n          @submit.prevent=\"\"\n        >\n          <label\n            :title=\"buttonText\"\n            id=\"localsearch-label\"\n            for=\"localsearch-input\"\n          >\n            <span aria-hidden=\"true\" class=\"vpi-search search-icon local-search-icon\" />\n          </label>\n          <div class=\"search-actions before\">\n            <button\n              class=\"back-button\"\n              :title=\"translate('modal.backButtonTitle')\"\n              @click=\"$emit('close')\"\n            >\n              <span class=\"vpi-arrow-left local-search-icon\" />\n            </button>\n          </div>\n          <input\n            ref=\"searchInput\"\n            v-model=\"filterText\"\n            :aria-activedescendant=\"selectedIndex > -1 ? ('localsearch-item-' + selectedIndex) : undefined\"\n            aria-autocomplete=\"both\"\n            :aria-controls=\"results?.length ? 'localsearch-list' : undefined\"\n            aria-labelledby=\"localsearch-label\"\n            autocapitalize=\"off\"\n            autocomplete=\"off\"\n            autocorrect=\"off\"\n            class=\"search-input\"\n            id=\"localsearch-input\"\n            enterkeyhint=\"go\"\n            maxlength=\"64\"\n            :placeholder=\"buttonText\"\n            spellcheck=\"false\"\n            type=\"search\"\n          />\n          <div class=\"search-actions\">\n            <button\n              v-if=\"!disableDetailedView\"\n              class=\"toggle-layout-button\"\n              type=\"button\"\n              :class=\"{ 'detailed-list': showDetailedList }\"\n              :title=\"translate('modal.displayDetails')\"\n              @click=\"\n                selectedIndex > -1 && (showDetailedList = !showDetailedList)\n              \"\n            >\n              <span class=\"vpi-layout-list local-search-icon\" />\n            </button>\n\n            <button\n              class=\"clear-button\"\n              type=\"reset\"\n              :disabled=\"disableReset\"\n              :title=\"translate('modal.resetButtonTitle')\"\n              @click=\"resetSearch\"\n            >\n              <span class=\"vpi-delete local-search-icon\" />\n            </button>\n          </div>\n        </form>\n\n        <ul\n          ref=\"resultsEl\"\n          :id=\"results?.length ? 'localsearch-list' : undefined\"\n          :role=\"results?.length ? 'listbox' : undefined\"\n          :aria-labelledby=\"results?.length ? 'localsearch-label' : undefined\"\n          class=\"results\"\n          @mousemove=\"onMouseMove\"\n        >\n          <li\n            v-for=\"(p, index) in results\"\n            :key=\"p.id\"\n            :id=\"'localsearch-item-' + index\"\n            :aria-selected=\"selectedIndex === index ? 'true' : 'false'\"\n            role=\"option\"\n          >\n            <a\n              :href=\"p.id\"\n              class=\"result\"\n              :class=\"{\n                selected: selectedIndex === index\n              }\"\n              :aria-label=\"[...p.titles, p.title].join(' > ')\"\n              @mouseenter=\"!disableMouseOver && (selectedIndex = index)\"\n              @focusin=\"selectedIndex = index\"\n              @click=\"$emit('close')\"\n              :data-index=\"index\"\n            >\n              <div>\n                <div class=\"titles\">\n                  <span class=\"title-icon\">#</span>\n                  <span\n                    v-for=\"(t, index) in p.titles\"\n                    :key=\"index\"\n                    class=\"title\"\n                  >\n                    <span class=\"text\" v-html=\"t\" />\n                    <span class=\"vpi-chevron-right local-search-icon\" />\n                  </span>\n                  <span class=\"title main\">\n                    <span class=\"text\" v-html=\"p.title\" />\n                  </span>\n                </div>\n\n                <div v-if=\"showDetailedList\" class=\"excerpt-wrapper\">\n                  <div v-if=\"p.text\" class=\"excerpt\" inert>\n                    <div class=\"vp-doc\" v-html=\"p.text\" />\n                  </div>\n                  <div class=\"excerpt-gradient-bottom\" />\n                  <div class=\"excerpt-gradient-top\" />\n                </div>\n              </div>\n            </a>\n          </li>\n          <li\n            v-if=\"filterText && !results.length && enableNoResults\"\n            class=\"no-results\"\n          >\n            {{ translate('modal.noResultsText') }} \"<strong>{{ filterText }}</strong\n            >\"\n          </li>\n        </ul>\n\n        <div class=\"search-keyboard-shortcuts\">\n          <span>\n            <kbd :aria-label=\"translate('modal.footer.navigateUpKeyAriaLabel')\">\n              <span class=\"vpi-arrow-up navigate-icon\" />\n            </kbd>\n            <kbd :aria-label=\"translate('modal.footer.navigateDownKeyAriaLabel')\">\n              <span class=\"vpi-arrow-down navigate-icon\" />\n            </kbd>\n            {{ translate('modal.footer.navigateText') }}\n          </span>\n          <span>\n            <kbd :aria-label=\"translate('modal.footer.selectKeyAriaLabel')\">\n              <span class=\"vpi-corner-down-left navigate-icon\" />\n            </kbd>\n            {{ translate('modal.footer.selectText') }}\n          </span>\n          <span>\n            <kbd :aria-label=\"translate('modal.footer.closeKeyAriaLabel')\">esc</kbd>\n            {{ translate('modal.footer.closeText') }}\n          </span>\n        </div>\n      </div>\n    </div>\n  </Teleport>\n</template>\n\n<style scoped>\n.VPLocalSearchBox {\n  position: fixed;\n  z-index: 100;\n  inset: 0;\n  display: flex;\n}\n\n.backdrop {\n  position: absolute;\n  inset: 0;\n  background: var(--vp-backdrop-bg-color);\n  transition: opacity 0.5s;\n}\n\n.shell {\n  position: relative;\n  padding: 12px;\n  margin: 64px auto;\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  background: var(--vp-local-search-bg);\n  width: min(100vw - 60px, 900px);\n  height: min-content;\n  max-height: min(100vh - 128px, 900px);\n  border-radius: 6px;\n}\n\n@media (max-width: 767px) {\n  .shell {\n    margin: 0;\n    width: 100vw;\n    height: 100vh;\n    max-height: none;\n    border-radius: 0;\n  }\n}\n\n.search-bar {\n  border: 1px solid var(--vp-c-divider);\n  border-radius: 4px;\n  display: flex;\n  align-items: center;\n  padding: 0 12px;\n  cursor: text;\n}\n\n@media (max-width: 767px) {\n  .search-bar {\n    padding: 0 8px;\n  }\n}\n\n.search-bar:focus-within {\n  border-color: var(--vp-c-brand-1);\n}\n\n.local-search-icon {\n  display: block;\n  font-size: 18px;\n}\n\n.navigate-icon {\n  display: block;\n  font-size: 14px;\n}\n\n.search-icon {\n  margin: 8px;\n}\n\n@media (max-width: 767px) {\n  .search-icon {\n    display: none;\n  }\n}\n\n.search-input {\n  padding: 6px 12px;\n  font-size: inherit;\n  width: 100%;\n}\n\n@media (max-width: 767px) {\n  .search-input {\n    padding: 6px 4px;\n  }\n}\n\n.search-actions {\n  display: flex;\n  gap: 4px;\n}\n\n@media (any-pointer: coarse) {\n  .search-actions {\n    gap: 8px;\n  }\n}\n\n@media (min-width: 769px) {\n  .search-actions.before {\n    display: none;\n  }\n}\n\n.search-actions button {\n  padding: 8px;\n}\n\n.search-actions button:not([disabled]):hover,\n.toggle-layout-button.detailed-list {\n  color: var(--vp-c-brand-1);\n}\n\n.search-actions button.clear-button:disabled {\n  opacity: 0.37;\n}\n\n.search-keyboard-shortcuts {\n  font-size: 0.8rem;\n  opacity: 75%;\n  display: flex;\n  flex-wrap: wrap;\n  gap: 16px;\n  line-height: 14px;\n}\n\n.search-keyboard-shortcuts span {\n  display: flex;\n  align-items: center;\n  gap: 4px;\n}\n\n@media (max-width: 767px) {\n  .search-keyboard-shortcuts {\n    display: none;\n  }\n}\n\n.search-keyboard-shortcuts kbd {\n  background: rgba(128, 128, 128, 0.1);\n  border-radius: 4px;\n  padding: 3px 6px;\n  min-width: 24px;\n  display: inline-block;\n  text-align: center;\n  vertical-align: middle;\n  border: 1px solid rgba(128, 128, 128, 0.15);\n  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.1);\n}\n\n.results {\n  display: flex;\n  flex-direction: column;\n  gap: 6px;\n  overflow-x: hidden;\n  overflow-y: auto;\n  overscroll-behavior: contain;\n}\n\n.result {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  border-radius: 4px;\n  transition: none;\n  line-height: 1rem;\n  border: solid 2px var(--vp-local-search-result-border);\n  outline: none;\n}\n\n.result > div {\n  margin: 12px;\n  width: 100%;\n  overflow: hidden;\n}\n\n@media (max-width: 767px) {\n  .result > div {\n    margin: 8px;\n  }\n}\n\n.titles {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 4px;\n  position: relative;\n  z-index: 1001;\n  padding: 2px 0;\n}\n\n.title {\n  display: flex;\n  align-items: center;\n  gap: 4px;\n}\n\n.title.main {\n  font-weight: 500;\n}\n\n.title-icon {\n  opacity: 0.5;\n  font-weight: 500;\n  color: var(--vp-c-brand-1);\n}\n\n.title svg {\n  opacity: 0.5;\n}\n\n.result.selected {\n  --vp-local-search-result-bg: var(--vp-local-search-result-selected-bg);\n  border-color: var(--vp-local-search-result-selected-border);\n}\n\n.excerpt-wrapper {\n  position: relative;\n}\n\n.excerpt {\n  opacity: 50%;\n  pointer-events: none;\n  max-height: 140px;\n  overflow: hidden;\n  position: relative;\n  margin-top: 4px;\n}\n\n.result.selected .excerpt {\n  opacity: 1;\n}\n\n.excerpt :deep(*) {\n  font-size: 0.8rem !important;\n  line-height: 130% !important;\n}\n\n.titles :deep(mark),\n.excerpt :deep(mark) {\n  background-color: var(--vp-local-search-highlight-bg);\n  color: var(--vp-local-search-highlight-text);\n  border-radius: 2px;\n  padding: 0 2px;\n}\n\n.excerpt :deep(.vp-code-group) .tabs {\n  display: none;\n}\n\n.excerpt :deep(.vp-code-group) div[class*='language-'] {\n  border-radius: 8px !important;\n}\n\n.excerpt-gradient-bottom {\n  position: absolute;\n  bottom: -1px;\n  left: 0;\n  width: 100%;\n  height: 8px;\n  background: linear-gradient(transparent, var(--vp-local-search-result-bg));\n  z-index: 1000;\n}\n\n.excerpt-gradient-top {\n  position: absolute;\n  top: -1px;\n  left: 0;\n  width: 100%;\n  height: 8px;\n  background: linear-gradient(var(--vp-local-search-result-bg), transparent);\n  z-index: 1000;\n}\n\n.result.selected .titles,\n.result.selected .title-icon {\n  color: var(--vp-c-brand-1) !important;\n}\n\n.no-results {\n  font-size: 0.9rem;\n  text-align: center;\n  padding: 12px;\n}\n\nsvg {\n  flex: none;\n}\n</style>\n","import { toArray, unrefElement, tryOnScopeDispose } from '@vueuse/core';\nimport { notNullish } from '@vueuse/shared';\nimport { createFocusTrap } from 'focus-trap';\nimport { shallowRef, computed, toValue, watch } from 'vue';\n\nfunction useFocusTrap(target, options = {}) {\n  let trap;\n  const { immediate, ...focusTrapOptions } = options;\n  const hasFocus = shallowRef(false);\n  const isPaused = shallowRef(false);\n  const activate = (opts) => trap && trap.activate(opts);\n  const deactivate = (opts) => trap && trap.deactivate(opts);\n  const pause = () => {\n    if (trap) {\n      trap.pause();\n      isPaused.value = true;\n    }\n  };\n  const unpause = () => {\n    if (trap) {\n      trap.unpause();\n      isPaused.value = false;\n    }\n  };\n  const targets = computed(() => {\n    const _targets = toValue(target);\n    return toArray(_targets).map((el) => {\n      const _el = toValue(el);\n      return typeof _el === \"string\" ? _el : unrefElement(_el);\n    }).filter(notNullish);\n  });\n  watch(\n    targets,\n    (els) => {\n      if (!els.length)\n        return;\n      trap = createFocusTrap(els, {\n        ...focusTrapOptions,\n        onActivate() {\n          hasFocus.value = true;\n          if (options.onActivate)\n            options.onActivate();\n        },\n        onDeactivate() {\n          hasFocus.value = false;\n          if (options.onDeactivate)\n            options.onDeactivate();\n        }\n      });\n      if (immediate)\n        activate();\n    },\n    { flush: \"post\" }\n  );\n  tryOnScopeDispose(() => deactivate());\n  return {\n    hasFocus,\n    isPaused,\n    activate,\n    deactivate,\n    pause,\n    unpause\n  };\n}\n\nexport { useFocusTrap };\n"],"file":"assets/chunks/VPLocalSearchBox.Dpa86P3q.js"}
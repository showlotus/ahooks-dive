# useRequest





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-request" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/index.ts" text="源码" />

这里包含了 ahooks 中与网络请求相关的 Hook，特别是 useRequest。

## 用法

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useRequest } from 'ahooks'\n\nfunction getUsername(): Promise<string> {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(Math.random().toString())\n    }, 1000)\n  })\n}\n\nexport default function Demo() {\n  const { data, error, loading } = useRequest(getUsername)\n\n  if (error) {\n    return <div>failed to load</div>\n  }\n  if (loading) {\n    return <div>loading...</div>\n  }\n  return <div>Username: {data}</div>\n}\n"} />

## 源码

## 解读

*TODO*


# useConditionalEffect



```ts title="useConditionalEffect.ts"
function useConditionalEffect(effect: () => boolean | void | (() => void), deps: any[]) {
  const shouldRunRef = useRef(true)

  useEffect(() => {
    // 如果已经标记为不再执行，直接返回
    if (!shouldRunRef.current) {
      return
    }

    const cleanup = effect()

    // 如果 effect 返回 false，标记为不再执行
    if (cleanup === false) {
      shouldRunRef.current = false
    }

    // 如果返回的是清理函数，正常执行清理
    return typeof cleanup === 'function' ? cleanup : undefined
  }, deps)
}
```


# useEffect



# useEffect


# useImmer



# useImmer


# useRef



# useRef


# useState



# useState


# useWatch



# useWatch

```ts
function useWatch(source, callback, options = {}) {
  const { immediate = false } = options
  const isActive = useRef(true)
  const unwatch = useRef(() => {})

  useEffect(() => {
    if (!isActive.current) return

    let oldValue = source()

    // 立即执行一次
    if (immediate) {
      callback(oldValue, undefined)
    }

    const stop = () => {
      isActive.current = false
      unwatch.current?.()
    }

    unwatch.current = () => {
      isActive.current = false
    }

    return () => {
      if (isActive.current) {
        const newValue = source()
        if (newValue !== oldValue) {
          callback(newValue, oldValue)
        }
      }
    }
  }, [source, callback, immediate])

  return () => {
    isActive.current = false
    unwatch.current?.()
  }
}

// 使用示例
function MyComponent() {
  const [count, setCount] = useState(0)

  const stopWatch = useWatch(
    () => count, // 获取值函数
    (newVal, oldVal) => {
      console.log(`count 从 ${oldVal} 变为 ${newVal}`)
    },
    { immediate: true },
  )

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>增加</button>
      <button onClick={stopWatch}>停止监听</button>
    </div>
  )
}
```


# useControllableValue





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-controllable-value" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useControllableValue/index.ts" text="源码" />

## 用法

在某些组件开发时，我们需要组件的状态既可以自己管理，也可以被外部控制，`useControllableValue` 就是帮你管理这种状态的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState } from 'react'\nimport { useControllableValue } from 'ahooks'\n\nfunction Input(props: { value?: string; onChange?: (value: string) => void }) {\n  const [state, setState] = useControllableValue<string>(props, {\n    defaultValue: '',\n  })\n\n  return (\n    <>\n      <input value={state} onChange={e => setState(e.target.value)} style={{ width: 300 }} />\n      <button type=\"button\" onClick={() => setState('')} style={{ marginLeft: 8 }}>\n        Clear By Self\n      </button>\n    </>\n  )\n}\n\nexport default () => {\n  const [state, setState] = useState<string>('')\n  const clear = () => {\n    setState('')\n  }\n\n  return (\n    <div>\n      <div style={{ border: '1px dashed', padding: 10 }}>\n        <div>非受控组件</div>\n        <Input />\n      </div>\n      <div style={{ border: '1px dashed', padding: 10, marginTop: 10 }}>\n        <div>受控组件</div>\n        <Input value={state} onChange={setState} />\n        <button style={{ marginLeft: 10 }} onClick={clear}>\n          Clear By Parent\n        </button>\n      </div>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useControllableValue.ts"
import { useMemo, useRef } from 'react';
import type { SetStateAction } from 'react';
import { isFunction } from '../utils';
import useMemoizedFn from '../useMemoizedFn';
import useUpdate from '../useUpdate';

export interface Options<T> {
  defaultValue?: T;
  defaultValuePropName?: string;
  valuePropName?: string;
  trigger?: string;
}

export type Props = Record<string, any>;

export interface StandardProps<T> {
  value: T;
  defaultValue?: T;
  onChange: (val: T) => void;
}

function useControllableValue<T = any>(
  props: StandardProps<T>,
): [T, (v: SetStateAction<T>) => void];
function useControllableValue<T = any>(
  props?: Props,
  options?: Options<T>,
): [T, (v: SetStateAction<T>, ...args: any[]) => void];
function useControllableValue<T = any>(defaultProps?: Props, options: Options<T> = {}) {
  const props = defaultProps ?? {};

  const {
    defaultValue,
    defaultValuePropName = 'defaultValue',
    valuePropName = 'value',
    trigger = 'onChange',
  } = options;

  const value = props[valuePropName] as T;
  const isControlled = Object.prototype.hasOwnProperty.call(props, valuePropName);

  const initialValue = useMemo(() => {
    if (isControlled) {
      return value;
    }
    if (Object.prototype.hasOwnProperty.call(props, defaultValuePropName)) {
      return props[defaultValuePropName];
    }
    return defaultValue;
  }, []);

  const stateRef = useRef(initialValue);
  if (isControlled) {
    stateRef.current = value;
  }

  const update = useUpdate();

  function setState(v: SetStateAction<T>, ...args: any[]) {
    const r = isFunction(v) ? v(stateRef.current) : v;

    if (!isControlled) {
      stateRef.current = r;
      update();
    }
    if (props[trigger]) {
      props[trigger](r, ...args);
    }
  }

  return [stateRef.current, useMemoizedFn(setState)] as const;
}

export default useControllableValue;
```

## 解读

<Callout>
  关于
  `useMemoizedFn`、`useUpdate`，可以查看对应文档：[useMemoizedFn](../../advanced/use-memoized-fn/)、[useUpdate](../../effect/use-update/)。
</Callout>

*TODO*


# useCreation





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-creation#use-creation" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useCreation/index.ts" text="源码" />

## 用法

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState } from 'react'\nimport { useCreation } from 'ahooks'\n\nclass Foo {\n  constructor() {\n    this.data = Math.random()\n  }\n\n  data: number\n}\n\nexport default function Demo() {\n  const foo = useCreation(() => new Foo(), [])\n  const [, setFlag] = useState({})\n  return (\n    <>\n      <p>{foo.data}</p>\n      <button\n        type=\"button\"\n        onClick={() => {\n          setFlag({})\n        }}\n      >\n        Rerender\n      </button>\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="useCreation.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="useCreation.ts">
      useCreation.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="useCreation.ts">
    ```ts
    import type { DependencyList } from 'react';
    import { useRef } from 'react';
    import depsAreSame from '../utils/depsAreSame';

    const useCreation = <T>(factory: () => T, deps: DependencyList) => {
      const { current } = useRef({
        deps,
        obj: undefined as T,
        initialized: false,
      });
      if (current.initialized === false || !depsAreSame(current.deps, deps)) {
        current.deps = deps;
        current.obj = factory();
        current.initialized = true;
      }
      return current.obj;
    };

    export default useCreation;
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="depsAreSame.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="depsAreSame.ts">
      depsAreSame.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="depsAreSame.ts">
    ```ts
    import type { DependencyList } from 'react';

    function depsAreSame(oldDeps: DependencyList, deps: DependencyList): boolean {
      if (oldDeps === deps) {
        return true;
      }
      for (let i = 0; i < oldDeps.length; i++) {
        if (!Object.is(oldDeps[i], deps[i])) {
          return false;
        }
      }
      return true;
    }

    export default depsAreSame;
    ```
  </CodeBlockTab>
</CodeBlockTabs>

## 解读

先看 `depsAreSame` 函数，用于比较两个依赖数组是否相同，内部采用 `Object.is` 进行比较。

{/* prettier-ignore */}

```ts
function depsAreSame(oldDeps: DependencyList, deps: DependencyList): boolean {
  if (oldDeps === deps) {
    return true;
  }
  for (let i = 0; i < oldDeps.length; i++) {
    if (!Object.is(oldDeps[i], deps[i])) {
      return false;
    }
  }
  return true;
}
```

而 `useCreation` 函数则是在内部使用 `useRef` 定义了一个 `ref` 对象，用于存储依赖数组和计算结果。

{/* prettier-ignore */}

```ts title="useCreation.ts"
const useCreation = <T>(factory: () => T, deps: DependencyList) => {
  // 1. 定义一个 ref 对象，用于存储依赖数组和计算结果
  const { current } = useRef({
    deps,
    obj: undefined as T,
    initialized: false,
  });
  // 2. 如果依赖数组未初始化，或者依赖数组发生变化，则更新依赖数组并重新计算结果
  if (current.initialized === false || !depsAreSame(current.deps, deps)) {
    // 2.1. 更新依赖数组
    current.deps = deps;
    // 2.2. 重新计算结果
    current.obj = factory();
    // 2.3. 标记为已初始化
    current.initialized = true;
  }
  // 3. 返回计算结果
  return current.obj;
};
```


# useEventEmitter







<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-event-emitter" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useEventEmitter/index.ts" text="源码" />

## 用法

创建一个事件发射器，用于在组件之间传递事件。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useRef, FC } from 'react'\nimport { useEventEmitter } from 'ahooks'\nimport { EventEmitter } from 'ahooks/lib/useEventEmitter'\n\nconst MessageBox: FC<{\n  focus$: EventEmitter<void>\n}> = function (props) {\n  return (\n    <div style={{ paddingBottom: 24 }}>\n      <p>You received a message</p>\n      <button\n        type=\"button\"\n        onClick={() => {\n          props.focus$.emit()\n        }}\n      >\n        Reply\n      </button>\n    </div>\n  )\n}\n\nconst InputBox: FC<{\n  focus$: EventEmitter<void>\n}> = function (props) {\n  const inputRef = useRef<HTMLInputElement>(null)\n  props.focus$.useSubscription(() => {\n    inputRef.current.focus()\n  })\n  return (\n    <input ref={inputRef} placeholder=\"Enter reply\" style={{ width: '100%', padding: '4px' }} />\n  )\n}\n\nexport default function Demo() {\n  const focus$ = useEventEmitter()\n  return (\n    <>\n      <MessageBox focus$={focus$} />\n      <InputBox focus$={focus$} />\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts [useEventEmitter.ts]
import { useRef, useEffect } from 'react';

type Subscription<T> = (val: T) => void;

export class EventEmitter<T> {
  private subscriptions = new Set<Subscription<T>>();

  emit = (val: T) => {
    for (const subscription of this.subscriptions) {
      subscription(val);
    }
  };

  useSubscription = (callback: Subscription<T>) => {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const callbackRef = useRef<Subscription<T>>(undefined);
    callbackRef.current = callback;
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useEffect(() => {
      function subscription(val: T) {
        if (callbackRef.current) {
          callbackRef.current(val);
        }
      }
      this.subscriptions.add(subscription);
      return () => {
        this.subscriptions.delete(subscription);
      };
    }, []);
  };
}

function useEventEmitter<T = void>() {
  const ref = useRef<EventEmitter<T>>(undefined);
  if (!ref.current) {
    ref.current = new EventEmitter();
  }
  return ref.current;
}

export default useEventEmitter;
```

## 解读

先看 `EventEmitter` 类的实现。

{/* prettier-ignore */}

```ts
export class EventEmitter<T> {
  // 1. 使用 Set 存储订阅者
  private subscriptions = new Set<Subscription<T>>();

  // 2. 定义 emit 方法，用于触发事件
  emit = (val: T) => {
    // 2.1. 遍历订阅者，调用每个订阅者的回调函数
    for (const subscription of this.subscriptions) {
      subscription(val);
    }
  };

  // 3. 定义 useSubscription 方法，用于订阅事件
  useSubscription = (callback: Subscription<T>) => {
    // 3.1. 使用 useRef 存储订阅者回调函数
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const callbackRef = useRef<Subscription<T>>(undefined);
    callbackRef.current = callback;
    // 3.2. 使用 useEffect 订阅事件
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useEffect(() => {
      // 3.2.1. 定义订阅者回调函数
      function subscription(val: T) {
        // 3.2.2. 如果订阅者回调函数存在，则调用该回调函数
        if (callbackRef.current) {
          callbackRef.current(val);
        }
      }
      // 3.2.3. 将订阅者回调函数添加到订阅者集合中
      this.subscriptions.add(subscription);
      // 3.2.4. 返回一个清理函数，用于在组件卸载时清理订阅者
      return () => {
        this.subscriptions.delete(subscription);
      };
    }, []);
  };
}
```

再来看 `useEventEmitter` 函数的实现。

{/* prettier-ignore */}

```ts
function useEventEmitter<T = void>() {
  // 1. 使用 useRef 创建一个 ref 对象，用于存储 EventEmitter 实例
  const ref = useRef<EventEmitter<T>>(undefined);
  // 2. 如果 ref 对象不存在，则创建一个 EventEmitter 实例
  if (!ref.current) {
    // 2.1. 创建一个 EventEmitter 实例
    ref.current = new EventEmitter();
  }
  // 3. 返回 EventEmitter 实例
  return ref.current;
}
```

其实就是一个 `EventBus` 的 `hook` 版本，在 `EventBus` 的基础上，增加了当组件卸载时清理订阅者的功能。以及在组件的顶层调用订阅事件 `useSubscription`，因为对于一个组件来说，只需要订阅一次，也就是为什么订阅函数是一个 `hook`，而不是一个普通的函数，仅需要在顶层调用一次 `useSubscription` 即可。

而当前的 `EventEmitter` 仅支持发布者发布唯一事件，如果需要发布多个事件，那就需要创建多个 `EventEmitter` 实例了。其实根据简单改造一下就能支持多事件发布订阅。

<ViewCode component={<ViewCodeActualComponent1 />} code={"'use client'\n\nimport { useEffect, useRef, useState } from 'react'\n\ntype Subscription<T> = (val: T) => void\n\nclass MultiEventEmitter<T> {\n  private subscriptions = new Map<string, Set<Subscription<T>>>()\n\n  emit(eventName: string, val: T) {\n    if (!this.subscriptions.has(eventName)) {\n      return\n    }\n\n    const subscriptions = this.subscriptions.get(eventName)!\n    for (const subscription of subscriptions) {\n      subscription(val)\n    }\n  }\n\n  useSubscription(eventName: string, callback: Subscription<T>) {\n    const callbackRef = useRef<Subscription<T>>(undefined)\n    callbackRef.current = callback\n    useEffect(() => {\n      function subscription(val: T) {\n        if (callbackRef.current) {\n          callbackRef.current(val)\n        }\n      }\n      if (this.subscriptions.has(eventName)) {\n        this.subscriptions.get(eventName)!.add(subscription)\n      } else {\n        this.subscriptions.set(eventName, new Set([subscription]))\n      }\n      return () => {\n        this.subscriptions.get(eventName)?.delete(subscription)\n      }\n    }, [])\n  }\n}\n\nfunction useMultiEventEmitter<T>() {\n  const ref = useRef<MultiEventEmitter<T>>(undefined)\n  if (!ref.current) {\n    ref.current = new MultiEventEmitter()\n  }\n  return ref.current\n}\n\nfunction Child1({ multiEventEmitter }: { multiEventEmitter: MultiEventEmitter<string> }) {\n  const [inputMessage, setInputMessage] = useState<string>('')\n  const [messages, setMessages] = useState<string[]>([])\n  multiEventEmitter.useSubscription('chat-to-child1', message => {\n    setMessages(prev => [...prev, message])\n  })\n  return (\n    <div>\n      Child1\n      <div>\n        <input\n          style={{ width: '100%' }}\n          type=\"text\"\n          placeholder=\"Enter message to send to Child2\"\n          value={inputMessage}\n          onChange={e => setInputMessage(e.target.value)}\n          onKeyDown={e => {\n            if (e.key === 'Enter') {\n              multiEventEmitter.emit('chat-to-child2', `Child1: ${inputMessage}`)\n              setInputMessage('')\n            }\n          }}\n        />\n      </div>\n      <ul>\n        {messages.map((message, index) => (\n          <li key={index}>{message}</li>\n        ))}\n      </ul>\n    </div>\n  )\n}\n\nfunction Child2({ multiEventEmitter }: { multiEventEmitter: MultiEventEmitter<string> }) {\n  const [inputMessage, setInputMessage] = useState<string>('')\n  const [messages, setMessages] = useState<string[]>([])\n  multiEventEmitter.useSubscription('chat-to-child2', (message: string) => {\n    setMessages((prev: string[]) => [...prev, message])\n  })\n  return (\n    <div>\n      Child2\n      <div>\n        <input\n          type=\"text\"\n          style={{ width: '100%' }}\n          placeholder=\"Enter message to send to Child1\"\n          value={inputMessage}\n          onChange={e => setInputMessage(e.target.value)}\n          onKeyDown={e => {\n            if (e.key === 'Enter') {\n              multiEventEmitter.emit('chat-to-child1', `Child2: ${inputMessage}`)\n              setInputMessage('')\n            }\n          }}\n        />\n      </div>\n      <ul>\n        {messages.map((message, index) => (\n          <li key={index}>{message}</li>\n        ))}\n      </ul>\n    </div>\n  )\n}\n\nexport default function Demo() {\n  const multiEventEmitter = useMultiEventEmitter<string>()\n  return (\n    <div\n      style={{\n        display: 'grid',\n        gridTemplateColumns: '1fr 1fr',\n        gap: '20px',\n      }}\n    >\n      <Child1 multiEventEmitter={multiEventEmitter} />\n      <Child2 multiEventEmitter={multiEventEmitter} />\n    </div>\n  )\n}\n"} />


# useIsomorphicLayoutEffect



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-isomorphic-layout-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useIsomorphicLayoutEffect/index.ts" text="源码" />

## 用法

## 源码

{/* prettier-ignore */}

```ts title="useIsomorphicLayoutEffect.ts"
import { useEffect, useLayoutEffect } from 'react';
import isBrowser from '../utils/isBrowser';

const useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;

export default useIsomorphicLayoutEffect;
```

## 解读

在浏览器环境返回 `useLayoutEffect`，在非浏览器环境返回 `useEffect`。


# useLatest











<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-latest#uselatest" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLatest/index.ts" text="源码" />

## 用法

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState, useEffect } from 'react'\nimport { useLatest } from 'ahooks'\n\nexport default function UseLatestDemo() {\n  const [useLatestCount, setUseLatestCount] = useState(0)\n  const [defaultCount, setDefaultCount] = useState(0)\n\n  const latestCountRef = useLatest(useLatestCount)\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setUseLatestCount(latestCountRef.current + 1)\n    }, 1000)\n    return () => clearInterval(interval)\n  }, [])\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setDefaultCount(defaultCount + 1)\n    }, 1000)\n    return () => clearInterval(interval)\n  }, [])\n\n  return (\n    <>\n      <p>count(useLatest): {useLatestCount}</p>\n      <p>count(default): {defaultCount}</p>\n    </>\n  )\n}\n"} />

{' '}

为什么 `demo.tsx` 中为什么 `defaultCount` 没有更新？

这是一个典型的 React 闭包问题，由于 `useEffect` 在组件挂载后只会执行一次，且 `setInterval` 中的回调函数内部始终是对第一次初始化时的 `defaultCount` 进行引用，也就意味着 `setInterval` 的回调函数中获取到的 `defaultCount` 一直都是 `0`。

如果将 `setDefaultCount` 传入一个更新函数，那么就能解决这个问题。

```tsx title="demo.tsx"
import { useState, useEffect } from 'react'

export default () => {
  const [defaultCount, setDefaultCount] = useState(0)

  useEffect(() => {
    const interval = setInterval(() => {
      setDefaultCount(count => count + 1) // [!code highlight]
    }, 1000)
    return () => clearInterval(interval)
  }, [])

  return (
    <>
      <p>count(default): {defaultCount}</p>
    </>
  )
}
```

<ViewCode component={<ViewCodeActualComponent1 />} code={"'use client'\n\nimport { useState, useEffect } from 'react'\n\nexport default function Demo() {\n  const [defaultCount, setDefaultCount] = useState(0)\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setDefaultCount(count => count + 1)\n    }, 1000)\n    return () => clearInterval(interval)\n  }, [])\n\n  return (\n    <>\n      <p>count(default): {defaultCount}</p>\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useLatest.ts"
import { useRef } from 'react';

function useLatest<T>(value: T) {
  const ref = useRef(value);
  ref.current = value;

  return ref;
}

export default useLatest;
```

## 解读

使用 `useRef` 定义一个 `ref` 对象，将入参赋值给 `ref` 对象，然后返回这个 `ref` 对象。相较于 `useRef`，多了一行赋值的代码，确保每次获取的值都是最新的。

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="useLatest.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="useLatest.ts">
      useLatest.ts
    </CodeBlockTabsTrigger>

    <CodeBlockTabsTrigger value="demo.tsx">
      demo.tsx
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="useLatest.ts">
    ```ts
    import { useRef } from 'react';

    function useLatest<T>(value: T) {
      const ref = useRef(value);
      ref.current = value; // [!code highlight]

      return ref;
    }

    export default useLatest;
    ```
  </CodeBlockTab>

  <CodeBlockTab value="demo.tsx">
    ```tsx
    import { useState, useEffect, useRef } from 'react'
    import { useLatest } from 'ahooks'

    export default () => {
      const [useLatestCount, setUseLatestCount] = useState(0)
      const [defaultCount, setDefaultCount] = useState(0)

      const latestCountRef = useLatest(useLatestCount)

      useEffect(() => {
        const interval = setInterval(() => {
          setUseLatestCount(latestCountRef.current + 1)
        }, 1000)
        return () => clearInterval(interval)
      }, [])

      useEffect(() => {
        const interval = setInterval(() => {
          setDefaultCount(defaultCount + 1)
        }, 1000)
        return () => clearInterval(interval)
      }, [])

      return (
        <>
          <p>count(useLatest): {useLatestCount}</p>
          <p>count(default): {defaultCount}</p>
        </>
      )
    }
    ```
  </CodeBlockTab>
</CodeBlockTabs>

因为使用 `useRef` 定义的变量，React 会记录在当前组件内部，在组件重新渲染时，不会再被初始化，而是使用当前组件内部记录的值。

而每次重新渲染时，当前组件内部上下文中拿到的都是每个 `state` 最新的值，`useLatest` 相当于更新了一下 `useRef` 定义的值，保证当前 `ref` 对象是最新的值。

<ThemeImage light={ThemeImage_light_0.src} dark={ThemeImage_dark_1.src} alt="demo.tsx 更新流程" />


# useMemoizedFn





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-memoized-fn" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMemoizedFn/index.ts" text="源码" />

## 用法

持久化 `function` 的引用，保证函数引用保持不变，避免重复创建函数。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState, useCallback } from 'react'\nimport { useMemoizedFn } from 'ahooks'\n\nexport default function Demo() {\n  const [count, setCount] = useState(0)\n\n  const callbackFn = useCallback(() => {\n    console.log(`Current count is ${count}`)\n  }, [count])\n\n  const memoizedFn = useMemoizedFn(() => {\n    console.log(`Current count is ${count}`)\n  })\n\n  return (\n    <>\n      <p>count: {count}</p>\n      <button\n        type=\"button\"\n        onClick={() => {\n          setCount(c => c + 1)\n        }}\n      >\n        Add Count\n      </button>\n      <div style={{ marginTop: 16 }}>\n        <button type=\"button\" onClick={callbackFn}>\n          call callbackFn\n        </button>\n        <button type=\"button\" onClick={memoizedFn} style={{ marginLeft: 8 }}>\n          call memoizedFn\n        </button>\n      </div>\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useMemoizedFn.ts"
import { useMemo, useRef } from 'react';
import { isFunction } from '../utils';
import isDev from '../utils/isDev';

type noop = (this: any, ...args: any[]) => any;

type PickFunction<T extends noop> = (
  this: ThisParameterType<T>,
  ...args: Parameters<T>
) => ReturnType<T>;

const useMemoizedFn = <T extends noop>(fn: T) => {
  if (isDev) {
    if (!isFunction(fn)) {
      console.error(`useMemoizedFn expected parameter is a function, got ${typeof fn}`);
    }
  }

  const fnRef = useRef<T>(fn);

  // why not write `fnRef.current = fn`?
  // https://github.com/alibaba/hooks/issues/728
  fnRef.current = useMemo<T>(() => fn, [fn]);

  const memoizedFn = useRef<PickFunction<T>>(undefined);

  if (!memoizedFn.current) {
    memoizedFn.current = function (this, ...args) {
      return fnRef.current.apply(this, args);
    };
  }

  return memoizedFn.current;
};

export default useMemoizedFn;
```

## 解读

先是环境判断，开发模式下传入参数的类型不为 `Function` 时，输出错误日志。

{/* prettier-ignore */}

```tsx
const useMemoizedFn = <T extends noop>(fn: T) => {
  if (isDev) { // [!code focus:5]
    if (!isFunction(fn)) {
      console.error(`useMemoizedFn expected parameter is a function, got ${typeof fn}`);
    }
  }

  /* ... */
}
```

然后使用 `useRef` 定义了一个 `fnRef` 对象，用于存储传入的函数。并且当传入的 `fn` 发生变化时，更新 `fnRef` 对象的值。

<Callout>
  关于为什么使用 `useMemo` 包裹，可以查看对应
  issue：[#728](https://github.com/alibaba/hooks/issues/728)。
</Callout>

{/* prettier-ignore */}

```tsx
const useMemoizedFn = <T extends noop>(fn: T) => {
  /* ... */

  const fnRef = useRef<T>(fn); // [!code focus:5]

  // why not write `fnRef.current = fn`?
  // https://github.com/alibaba/hooks/issues/728
  fnRef.current = useMemo<T>(() => fn, [fn]);
}
```

接着使用 `useRef` 定义了一个 `memoizedFn` 对象，初始值为 `undefined`，用来记录新函数。

首次执行时，会更新 `memoizedFn` 对象的值，赋值一个新函数，新函数内部会修改 `this` 指向后直接调用 `fnRef` 对象的值，并返回函数的执行结果。

首次更新 `memoizedFn` 对象的值后，后续便不再更新，这也是 `useMemoizedFn` 为什么能保证函数引用保持不变的原因。

最后返回 `memoizedFn` 对象中记录的这个新函数。

{/* prettier-ignore */}

```tsx
const useMemoizedFn = <T extends noop>(fn: T) => {
  /* ... */

  const memoizedFn = useRef<PickFunction<T>>(undefined); // [!code focus:9]

  if (!memoizedFn.current) {
    memoizedFn.current = function (this, ...args) {
      return fnRef.current.apply(this, args);
    };
  }

  return memoizedFn.current;
}
```

综上，简单来说，`useMemoizedFn` 就是在内部创建了一个新函数，新函数内部执行传入的函数 `fn`，将 `fn` 的执行结果作为新函数的返回值，最后返回这个新函数，来保证函数的引用一直不变。通过 `useRef` 和 `useMemo` 来保证新函数内部执行的 `fn` 函数始终是最新的 `fn` 。


# useReactive





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-reactive" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useReactive/index.ts" text="源码" />

## 用法

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useReactive } from 'ahooks'\n\nexport default function Demo() {\n  const state = useReactive({\n    count: 0,\n    inputVal: '',\n    obj: {\n      value: '',\n    },\n  })\n\n  return (\n    <div>\n      <p> state.count：{state.count}</p>\n\n      <button style={{ marginRight: 8 }} onClick={() => state.count++}>\n        state.count++\n      </button>\n      <button onClick={() => state.count--}>state.count--</button>\n\n      <p style={{ marginTop: 20 }}> state.inputVal: {state.inputVal}</p>\n      <input onChange={e => (state.inputVal = e.target.value)} />\n\n      <p style={{ marginTop: 20 }}> state.obj.value: {state.obj.value}</p>\n      <input onChange={e => (state.obj.value = e.target.value)} />\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useReactive.ts"
import { useRef } from 'react';
import isPlainObject from 'lodash/isPlainObject';
import useCreation from '../useCreation';
import useUpdate from '../useUpdate';

// k:v 原对象:代理过的对象
const proxyMap = new WeakMap();
// k:v 代理过的对象:原对象
const rawMap = new WeakMap();

function observer<T extends Record<string, any>>(initialVal: T, cb: () => void): T {
  const existingProxy = proxyMap.get(initialVal);

  // 添加缓存 防止重新构建proxy
  if (existingProxy) {
    return existingProxy;
  }

  // 防止代理已经代理过的对象
  // https://github.com/alibaba/hooks/issues/839
  if (rawMap.has(initialVal)) {
    return initialVal;
  }

  const proxy = new Proxy<T>(initialVal, {
    get(target, key, receiver) {
      const res = Reflect.get(target, key, receiver);

      // https://github.com/alibaba/hooks/issues/1317
      const descriptor = Reflect.getOwnPropertyDescriptor(target, key);
      if (!descriptor?.configurable && !descriptor?.writable) {
        return res;
      }

      // Only proxy plain object or array,
      // otherwise it will cause: https://github.com/alibaba/hooks/issues/2080
      return isPlainObject(res) || Array.isArray(res) ? observer(res, cb) : res;
    },
    set(target, key, val) {
      const ret = Reflect.set(target, key, val);
      cb();
      return ret;
    },
    deleteProperty(target, key) {
      const ret = Reflect.deleteProperty(target, key);
      cb();
      return ret;
    },
  });

  proxyMap.set(initialVal, proxy);
  rawMap.set(proxy, initialVal);

  return proxy;
}

function useReactive<S extends Record<string, any>>(initialState: S): S {
  const update = useUpdate();
  const stateRef = useRef<S>(initialState);

  const state = useCreation(() => {
    return observer(stateRef.current, () => {
      update();
    });
  }, []);

  return state;
}

export default useReactive;
```

## 解读

<Callout>
  关于
  `useCreation`、`useUpdate`，可以查看对应文档：[useCreation](../../advanced/use-creation/)、[useUpdate](../../effect/use-update/)。
</Callout>

先看 `observer` 函数，用于深度代理一个对象。

{/* prettier-ignore */}

```ts
// k:v 原对象:代理过的对象
const proxyMap = new WeakMap();
// k:v 代理过的对象:原对象
const rawMap = new WeakMap();

function observer<T extends Record<string, any>>(initialVal: T, cb: () => void): T {
  // 1. 在 proxyMap 中查找当前对象是否已经代理过
  const existingProxy = proxyMap.get(initialVal);

  // 添加缓存 防止重新构建proxy
  // 2. 如果已经代理过，则直接返回代理过的对象
  if (existingProxy) {
    return existingProxy;
  }

  // 防止代理已经代理过的对象
  // https://github.com/alibaba/hooks/issues/839
  // 3. 如果当前对象是个已经代理过的对象，则直接返回该对象
  if (rawMap.has(initialVal)) {
    return initialVal;
  }

  // 4. 构建代理对象
  const proxy = new Proxy<T>(initialVal, {
    get(target, key, receiver) {
      // 4.1. 通过 Reflect.get 获取当前对象的属性值，可确保 this 指向的正确性
      const res = Reflect.get(target, key, receiver);

      // https://github.com/alibaba/hooks/issues/1317
      // 4.2. 获取当前对象的属性描述符，如果属性描述符不可配置且不可写，则直接返回该属性
      const descriptor = Reflect.getOwnPropertyDescriptor(target, key);
      if (!descriptor?.configurable && !descriptor?.writable) {
        return res;
      }

      // Only proxy plain object or array,
      // otherwise it will cause: https://github.com/alibaba/hooks/issues/2080
      // 4.3. 如果当前对象是普通对象或数组，则递归代理该对象
      return isPlainObject(res) || Array.isArray(res) ? observer(res, cb) : res;
    },
    set(target, key, val) {
      // 4.4. 通过 Reflect.set 设置当前对象的属性值，并触发回调
      const ret = Reflect.set(target, key, val);
      cb();
      return ret;
    },
    deleteProperty(target, key) {
      // 4.5. 通过 Reflect.deleteProperty 删除当前对象的属性，并触发回调
      const ret = Reflect.deleteProperty(target, key);
      cb();
      return ret;
    },
  });

  // 5. 将原对象和代理对象分别缓存到 proxyMap 和 rawMap 中
  proxyMap.set(initialVal, proxy);
  rawMap.set(proxy, initialVal);

  // 6. 返回代理对象
  return proxy;
}
```

再来看看 `useReactive` 函数的实现。

{/* prettier-ignore */}

```ts
function useReactive<S extends Record<string, any>>(initialState: S): S {
  // 1. 使用 useUpdate 获取更新函数，调用 update 会触发组件重新渲染
  const update = useUpdate();
  // 2. 使用 useRef 创建一个 ref 对象，用于存储初始状态
  const stateRef = useRef<S>(initialState);

  // 3. 使用 useCreation 创建一个响应式对象
  const state = useCreation(() => {
    // 3.1. 调用 observer 函数，深度代理初始状态
    return observer(stateRef.current, () => {
      // 3.2. 当对象的属性发生变化时，触发 update 函数，从而触发组件重新渲染
      update();
    });
  }, []);

  // 4. 返回响应式对象
  return state;
}
```


# useTrackedEffect



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-tracked-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useTrackedEffect/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useWhyDidYouUpdate



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-why-did-you-update" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useWhyDidYouUpdate/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useClickAway



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-click-away" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useClickAway/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useDocumentVisibility



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-document-visibility" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDocumentVisibility/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useDrag



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-drag" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDrag/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useDrop



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-drop" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDrop/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useEventListener





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-event-listener#useeventlistener" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useEventListener/index.ts" text="源码" />

## 用法

监听事件。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState, useRef } from 'react'\nimport { useEventListener } from 'ahooks'\n\nexport default function UseEventListenerDemo() {\n  const [value, setValue] = useState(0)\n  const ref = useRef(null)\n\n  useEventListener(\n    'click',\n    () => {\n      setValue(value + 1)\n    },\n    { target: ref },\n  )\n\n  return (\n    <button ref={ref} type=\"button\">\n      You click {value} times\n    </button>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useEventListener.ts"
import useLatest from '../useLatest';
import type { BasicTarget } from '../utils/domTarget';
import { getTargetElement } from '../utils/domTarget';
import useEffectWithTarget from '../utils/useEffectWithTarget';

type noop = (...p: any) => void;

export type Target = BasicTarget<HTMLElement | Element | Window | Document>;

type Options<T extends Target = Target> = {
  target?: T;
  capture?: boolean;
  once?: boolean;
  passive?: boolean;
  enable?: boolean;
};

function useEventListener<K extends keyof HTMLElementEventMap>(
  eventName: K,
  handler: (ev: HTMLElementEventMap[K]) => void,
  options?: Options<HTMLElement>,
): void;
function useEventListener<K extends keyof ElementEventMap>(
  eventName: K,
  handler: (ev: ElementEventMap[K]) => void,
  options?: Options<Element>,
): void;
function useEventListener<K extends keyof DocumentEventMap>(
  eventName: K,
  handler: (ev: DocumentEventMap[K]) => void,
  options?: Options<Document>,
): void;
function useEventListener<K extends keyof WindowEventMap>(
  eventName: K,
  handler: (ev: WindowEventMap[K]) => void,
  options?: Options<Window>,
): void;
function useEventListener(
  eventName: string | string[],
  handler: (event: Event) => void,
  options?: Options<Window>,
): void;
function useEventListener(eventName: string | string[], handler: noop, options: Options): void;

function useEventListener(eventName: string | string[], handler: noop, options: Options = {}) {
  const { enable = true } = options;

  const handlerRef = useLatest(handler);

  useEffectWithTarget(
    () => {
      if (!enable) {
        return;
      }

      const targetElement = getTargetElement(options.target, window);
      if (!targetElement?.addEventListener) {
        return;
      }

      const eventListener = (event: Event) => {
        return handlerRef.current(event);
      };

      const eventNameArray = Array.isArray(eventName) ? eventName : [eventName];

      eventNameArray.forEach((event) => {
        targetElement.addEventListener(event, eventListener, {
          capture: options.capture,
          once: options.once,
          passive: options.passive,
        });
      });

      return () => {
        eventNameArray.forEach((event) => {
          targetElement.removeEventListener(event, eventListener, {
            capture: options.capture,
          });
        });
      };
    },
    [eventName, options.capture, options.once, options.passive, enable],
    options.target,
  );
}

export default useEventListener;
```

## 解读

*TODO*


# useEventTarget



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-event-target" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useEventTarget/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useExternal



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-external" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useExternal/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useFavicon



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-favicon" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useFavicon/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useFocusWithin



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-focus-within" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useFocusWithin/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useFullscreen



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-fullscreen" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useFullscreen/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useHover





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-hover#usehover" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useHover/index.ts" text="源码" />

## 用法

监听元素的悬停状态。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useRef } from 'react'\nimport { useHover } from 'ahooks'\n\nexport default function Demo() {\n  const ref = useRef(null)\n  const isHovering = useHover(ref)\n  return <div ref={ref}>{isHovering ? 'hover' : 'leaveHover'}</div>\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useHover.ts"
import useBoolean from '../useBoolean';
import useEventListener from '../useEventListener';
import type { BasicTarget } from '../utils/domTarget';

export interface Options {
  onEnter?: () => void;
  onLeave?: () => void;
  onChange?: (isHovering: boolean) => void;
}

export default (target: BasicTarget, options?: Options): boolean => {
  const { onEnter, onLeave, onChange } = options || {};

  const [state, { setTrue, setFalse }] = useBoolean(false);

  useEventListener(
    'mouseenter',
    () => {
      onEnter?.();
      setTrue();
      onChange?.(true);
    },
    {
      target,
    },
  );

  useEventListener(
    'mouseleave',
    () => {
      onLeave?.();
      setFalse();
      onChange?.(false);
    },
    {
      target,
    },
  );

  return state;
};
```

## 解读

*TODO*


# useInViewport



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-in-viewport" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useInViewport/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useKeyPress



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-key-press" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useKeyPress/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useLongPress



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-long-press" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLongPress/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useMouse



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-mouse" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMouse/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useMutationObserver



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-mutation-observer" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMutationObserver/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useResponsive



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-responsive" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useResponsive/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useScroll





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-scroll#usescroll" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useScroll/index.ts" text="源码" />

## 用法

监听元素的滚动事件。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useRef } from 'react'\nimport { useScroll } from 'ahooks'\n\nexport default function Demo() {\n  const ref = useRef(null)\n  const scroll = useScroll(ref)\n  return (\n    <>\n      <p>{JSON.stringify(scroll)}</p>\n      <div\n        style={{\n          height: '160px',\n          width: '160px',\n          border: 'solid 1px #000',\n          overflow: 'scroll',\n          whiteSpace: 'nowrap',\n          fontSize: '32px',\n        }}\n        ref={ref}\n      >\n        <div>\n          Lorem ipsum dolor sit amet, consectetur adipisicing elit. A aspernatur atque, debitis ex\n          excepturi explicabo iste iure labore molestiae neque optio perspiciatis\n        </div>\n        <div>\n          Aspernatur cupiditate, deleniti id incidunt mollitia omnis! A aspernatur assumenda\n          consequuntur culpa cumque dignissimos enim eos, et fugit natus nemo nesciunt\n        </div>\n        <div>\n          Alias aut deserunt expedita, inventore maiores minima officia porro rem. Accusamus ducimus\n          magni modi mollitia nihil nisi provident\n        </div>\n        <div>\n          Alias aut autem consequuntur doloremque esse facilis id molestiae neque officia placeat,\n          quia quisquam repellendus reprehenderit.\n        </div>\n        <div>\n          Adipisci blanditiis facere nam perspiciatis sit soluta ullam! Architecto aut blanditiis,\n          consectetur corporis cum deserunt distinctio dolore eius est exercitationem\n        </div>\n        <div>Ab aliquid asperiores assumenda corporis cumque dolorum expedita</div>\n        <div>\n          Culpa cumque eveniet natus totam! Adipisci, animi at commodi delectus distinctio dolore\n          earum, eum expedita facilis\n        </div>\n        <div>\n          Quod sit, temporibus! Amet animi fugit officiis perspiciatis, quis unde. Cumque\n          dignissimos distinctio, dolor eaque est fugit nisi non pariatur porro possimus, quas quasi\n        </div>\n      </div>\n    </>\n  )\n}\n"} />

## 源码

```ts title="useScroll.ts"
import { useEffect, useRef } from 'react'

const useScroll = () => {
  const ref = useRef(null)
  useEffect(() => {
    const handleScroll = () => {
      console.log('scroll')
    }
    ref.current.addEventListener('scroll', handleScroll)
    return () => {
      ref.current.removeEventListener('scroll', handleScroll)
    }
  }, [])
  return ref
}

export default useScroll
```

## 解读

*TODO*


# useSize



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-size" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useSize/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useTitle



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-title" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useTitle/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useMount





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-mount#usemount" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMount/index.ts" text="源码" />

## 用法

组件挂载时执行。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport React from 'react'\nimport { useMount, useBoolean } from 'ahooks'\n\nconst MyComponent = () => {\n  useMount(() => {\n    console.log('mount')\n  })\n\n  return <div>Hello World</div>\n}\n\nexport default function Demo() {\n  const [state, { toggle }] = useBoolean(false)\n\n  return (\n    <>\n      <button type=\"button\" onClick={toggle}>\n        {state ? 'unmount' : 'mount'}\n      </button>\n      {state && <MyComponent />}\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useMount.ts"
import { useEffect } from 'react';
import { type EffectCallback } from 'react';
import { isFunction } from '../utils';
import isDev from '../utils/isDev';

const useMount = (fn: EffectCallback) => {
  if (isDev) {
    if (!isFunction(fn)) {
      console.error(
        `useMount: parameter \`fn\` expected to be a function, but got "${typeof fn}".`
      );
    }
  }

  useEffect(() => {
    return fn?.();
  }, []);
};

export default useMount;
```

## 解读

先是环境判断，开发模式下传入参数的类型不为 `Function` 时，输出错误日志。

然后，主要逻辑就是上面高亮的 `15-17` 行，用 `useEffect` 包了一层，然后再将入参函数的执行结果返回。


# useUnmount





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-unmount#useunmount" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useUnmount/index.ts" text="源码" />

## 用法

组件卸载时执行。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useUnmount, useBoolean } from 'ahooks'\n\nconst MyComponent = () => {\n  useUnmount(() => {\n    console.log('mount')\n  })\n\n  return <div>Hello World</div>\n}\n\nexport default function Demo() {\n  const [state, { toggle }] = useBoolean(false)\n\n  return (\n    <>\n      <button type=\"button\" onClick={toggle}>\n        {state ? 'unmount' : 'mount'}\n      </button>\n      {state && <MyComponent />}\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useUnMount.ts"
import { useEffect } from 'react';
import useLatest from '../useLatest';
import { isFunction } from '../utils';
import isDev from '../utils/isDev';

const useUnmount = (fn: () => void) => {
  if (isDev) {
    if (!isFunction(fn)) {
      console.error(`useUnmount expected parameter is a function, got ${typeof fn}`);
    }
  }

  const fnRef = useLatest(fn);

  useEffect(
    () => () => {
      fnRef.current();
    },
    [],
  );
};

export default useUnmount;
```

<Callout>
  关于 `useLatest`，可以查看对应文档：[useLatest](../../advanced/use-latest/)，用来返回最新的值。
</Callout>

## 解读

先是环境判断，开发模式下传入参数的类型不为 `Function` 时，输出错误日志。

然后，主要逻辑就是上面高亮的 `15-17` 行，用 `useEffect` 包了一层，然后再将入参函数的执行结果返回。


# useUnmountedRef





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-unmounted-ref#useunmountedref" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useUnmountedRef/index.tsx" text="源码" />

## 用法

当前组件是否已经卸载。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useEffect, useState } from 'react'\nimport { useUnmountedRef } from 'ahooks'\n\nconst MyComponent = () => {\n  const unmountedRef = useUnmountedRef()\n  useEffect(() => {\n    setTimeout(() => {\n      if (!unmountedRef.current) {\n        console.log('component is alive')\n      } else {\n        console.log('component is unmounted')\n      }\n    }, 3000)\n  }, [])\n\n  return <p>Hello World!</p>\n}\n\nexport default function Demo() {\n  const [state, setState] = useState(true)\n\n  return (\n    <>\n      <button type=\"button\" onClick={() => setState(!state)}>\n        {state ? 'unmount' : 'mount'}\n      </button>\n      {state && <MyComponent />}\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```tsx title="useUnmountedRef.tsx"
import { useEffect, useRef } from 'react';

const useUnmountedRef = () => {
  const unmountedRef = useRef(false);
  useEffect(() => {
    unmountedRef.current = false;
    return () => {
      unmountedRef.current = true;
    };
  }, []);
  return unmountedRef;
};

export default useUnmountedRef;
```

## 解读

使用 `useRef` 记录当前组件的卸载状态，初始值为 `false`，挂载时赋值为 `false`，卸载时赋值为 `true`，最后返回当前 `ref` 对象，用于判断组件是否已经卸载。


# useAsyncEffect



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-async-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useAsyncEffect/index.ts" text="源码" />

## 用法

## 源码

## 解读


# useDebounceEffect



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-debounce-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDebounceEffect/index.ts" text="源码" />

## 用法

{/* prettier-ignore */}

```ts title="useDebounceEffect.ts"
import { useEffect, useState } from 'react';
import type { DependencyList, EffectCallback } from 'react';
import type { DebounceOptions } from '../useDebounce/debounceOptions';
import useDebounceFn from '../useDebounceFn';
import useUpdateEffect from '../useUpdateEffect';

function useDebounceEffect(
  effect: EffectCallback,
  deps?: DependencyList,
  options?: DebounceOptions,
) {
  const [flag, setFlag] = useState({});

  const { run } = useDebounceFn(() => {
    setFlag({});
  }, options);

  useEffect(() => {
    return run();
  }, deps);

  useUpdateEffect(effect, [flag]);
}

export default useDebounceEffect;
```

## 解读

<Callout>
  关于
  `useDebounceFn`、`useUpdateEffect`，可以查看对应文档：[useDebounceFn](../../effect/use-debounce-fn/)、[useUpdateEffect](../../effect/use-update-effect/)。
</Callout>

{/* prettier-ignore */}

```ts
function useDebounceEffect(
  effect: EffectCallback,
  deps?: DependencyList,
  options?: DebounceOptions,
) {
  // 1. 首先，使用 useState 定义了一个 flag 状态，用于记录依赖是否更新。
  const [flag, setFlag] = useState({});

  // 2. 然后，使用 useDebounceFn 来处理防抖值。
  const { run } = useDebounceFn(() => {
    setFlag({});
  }, options);

  // 3. 接着，使用 useEffect 来监听依赖的更新，并调用 run 函数来更新防抖值。
  useEffect(() => {
    return run();
  }, deps);

  // 4. 最后，使用 useUpdateEffect 来监听 flag 的变化，并执行 effect。
  useUpdateEffect(effect, [flag]);
}
```

执行流程：`deps` 更新 -> 执行 `run` 函数 -> `flag` 更新 -> 执行 `effect`。

由于 `useUpdateEffect` 会忽略首次执行，如果需要首次执行，可以通过 `useDebounceFn` 的 `options` 参数来设置。

```ts
const { run } = useDebounceFn(
  () => {
    setFlag({})
  },
  {
    wait: 1000,
    // 设置为 true，表示在延迟开始前调用
    leading: true, // [!code highlight]
  },
)
```


# useDebounceFn







<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-debounce-fn" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDebounceFn/index.ts" text="源码" />

## 用法

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useDebounceFn } from 'ahooks'\nimport { useState } from 'react'\n\nexport default function Demo() {\n  const [value, setValue] = useState(0)\n  const { run } = useDebounceFn(\n    () => {\n      setValue(value + 1)\n    },\n    {\n      wait: 500,\n    },\n  )\n\n  return (\n    <div>\n      <p style={{ marginTop: 16 }}> Clicked count: {value} </p>\n      <button type=\"button\" onClick={run}>\n        Click fast!\n      </button>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useDebounceFn.ts"
import { debounce } from '../utils/lodash-polyfill';
import { useMemo } from 'react';
import type { DebounceOptions } from '../useDebounce/debounceOptions';
import useLatest from '../useLatest';
import useUnmount from '../useUnmount';
import { isFunction } from '../utils';
import isDev from '../utils/isDev';

type noop = (...args: any[]) => any;

function useDebounceFn<T extends noop>(fn: T, options?: DebounceOptions) {
  if (isDev) {
    if (!isFunction(fn)) {
      console.error(`useDebounceFn expected parameter is a function, got ${typeof fn}`);
    }
  }

  const fnRef = useLatest(fn);

  const wait = options?.wait ?? 1000;

  const debounced = useMemo(
    () =>
      debounce(
        (...args: Parameters<T>): ReturnType<T> => {
          return fnRef.current(...args);
        },
        wait,
        options,
      ),
    [],
  );

  useUnmount(() => {
    debounced.cancel();
  });

  return {
    run: debounced,
    cancel: debounced.cancel,
    flush: debounced.flush,
  };
}

export default useDebounceFn;
```

## 解读

<Callout>
  关于
  `useLatest`、`useUnmount`，可以查看对应文档：[useLatest](../../advanced/use-latest/)、[useUnmount](../../life-cycle/use-unmount/)。
</Callout>

{/* prettier-ignore */}

```ts
function useDebounceFn<T extends noop>(fn: T, options?: DebounceOptions) {
  // 1. 首先，使用 useLatest 来记录函数的最新值。
  const fnRef = useLatest(fn);

  // 2. 然后，使用 options 中的 wait 属性来设置防抖时间，默认值为 1000ms。
  const wait = options?.wait ?? 1000;

  // 3. 接着，使用 useMemo 来缓存防抖后的函数。防抖后的函数内部会调用 fnRef 对象的值，并返回函数的执行结果。
  const debounced = useMemo(
    () =>
      // 使用 lodash 的 debounce 函数实现防抖函数，参数配置也完全与 lodash 的 debounce 函数一致。
      debounce(
        (...args: Parameters<T>): ReturnType<T> => {
          return fnRef.current(...args);
        },
        wait,
        options,
      ),
    [],
  );

  // 4. 然后，使用 useUnmount 来卸载防抖后的函数。
  useUnmount(() => {
    debounced.cancel();
  });

  // 5. 最后，返回防抖后的函数，包括 run、cancel、flush 三个方法。
  return {
    run: debounced,
    cancel: debounced.cancel,
    flush: debounced.flush,
  };
}
```

本质上就是利用 `debounce` 来延时更新 `state` 的值，完全可以利用 `setTimeout` 来实现一个简易的版本。

<ViewCode component={<ViewCodeActualComponent1 />} code={"'use client'\n\nimport { useState, useEffect } from 'react'\n\nfunction useDebounce<T>(value: T, options?: { wait: number }) {\n  const wait = options?.wait ?? 1000\n  const [debouncedValue, setDebouncedValue] = useState(value)\n  let timer: NodeJS.Timeout\n  useEffect(() => {\n    if (timer) {\n      clearTimeout(timer)\n    }\n    timer = setTimeout(() => {\n      setDebouncedValue(value)\n    }, wait)\n    return () => {\n      if (timer) {\n        clearTimeout(timer)\n      }\n    }\n  }, [value, wait])\n  return debouncedValue\n}\n\nexport default function Demo() {\n  const [value, setValue] = useState<string>()\n  const debouncedValue = useDebounce(value, { wait: 500 })\n\n  return (\n    <div>\n      <input\n        value={value}\n        onChange={e => setValue(e.target.value)}\n        placeholder=\"Typed value\"\n        style={{ width: 280 }}\n      />\n      <p style={{ marginTop: 16 }}>Value: {value}</p>\n      <p style={{ marginTop: 16 }}>DebouncedValue（延时 500ms 后更新）: {debouncedValue}</p>\n    </div>\n  )\n}\n"} />


# useDeepCompareEffect









<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-deep-compare-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDeepCompareEffect/index.tsx" text="源码" />

## 用法

用法与 `useEffect` 一致，不同的是，会深度比较依赖。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useEffect, useState, useRef } from 'react'\nimport { useDeepCompareEffect } from 'ahooks'\n\nexport default function Demo() {\n  const [count, setCount] = useState(0)\n  const effectCountRef = useRef(0)\n  const deepCompareCountRef = useRef(0)\n\n  useEffect(() => {\n    effectCountRef.current += 1\n  }, [{}])\n\n  useDeepCompareEffect(() => {\n    deepCompareCountRef.current += 1\n    return () => {\n      // do something\n    }\n  }, [{}])\n\n  return (\n    <div>\n      <p>effectCount: {effectCountRef.current}</p>\n      <p>deepCompareCount: {deepCompareCountRef.current}</p>\n      <p>\n        <button type=\"button\" onClick={() => setCount(c => c + 1)}>\n          reRender\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="useDeepCompareEffect.tsx">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="useDeepCompareEffect.tsx">
      useDeepCompareEffect.tsx
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="useDeepCompareEffect.tsx">
    ```tsx
    import { useEffect } from 'react';
    import { createDeepCompareEffect } from '../createDeepCompareEffect';

    export default createDeepCompareEffect(useEffect);
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="createDeepCompareEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="createDeepCompareEffect.ts">
      createDeepCompareEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="createDeepCompareEffect.ts">
    ```ts
    import { useRef } from 'react';
    import type { DependencyList, useEffect, useLayoutEffect } from 'react';
    import { depsEqual } from '../utils/depsEqual';

    type EffectHookType = typeof useEffect | typeof useLayoutEffect;

    type CreateUpdateEffect = (hook: EffectHookType) => EffectHookType;

    export const createDeepCompareEffect: CreateUpdateEffect = (hook) => (effect, deps) => {
      const ref = useRef<DependencyList>(undefined);
      const signalRef = useRef<number>(0);
      if (deps === undefined || !depsEqual(deps, ref.current)) {
        signalRef.current += 1;
      }
      ref.current = deps;
      hook(effect, [signalRef.current]);
    };
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="depsEqual.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="depsEqual.ts">
      depsEqual.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="depsEqual.ts">
    ```ts
    import type { DependencyList } from 'react';
    import isEqual from 'react-fast-compare';

    export const depsEqual = (aDeps: DependencyList = [], bDeps: DependencyList = []) =>
      isEqual(aDeps, bDeps);
    ```
  </CodeBlockTab>
</CodeBlockTabs>

## 解读

首先调用 `createDeepCompareEffect` 函数，传入 `useEffect` 函数。

`createDeepCompareEffect` 执行后返回一个新函数。源码的写法有些简略，因为直接通过箭头函数返回一个新函数，所以就直接省略了 `return` 和 `{}`。

实际等同于下面的写法：

{/* prettier-ignore */}

```ts
export const createDeepCompareEffect: CreateUpdateEffect = (hook) => {
  return (effect, deps) => {
    const ref = useRef<DependencyList>(undefined);
    const signalRef = useRef<number>(0);
    if (deps === undefined || !depsEqual(deps, ref.current)) {
      signalRef.current += 1;
    }
    ref.current = deps;
    hook(effect, [signalRef.current]);
  }
};
```

在解读 `createDeepCompareEffect` 函数之前，先来思考一个问题：如何实现一个可以自定义比较 `deps` 的 `useEffect` 的 `hook`？

首先肯定还是要在 `useEffect` 的基础上实现这个 `hook`。而由于 `useEffect` 只接受两个参数，第一个参数 `effect` 是回调函数，第二个参数 `deps` 是依赖数组。`effect` 肯定是不能变的，那就只能变 `deps` 了。那么可以将自定义比较的结果通过 `deps` 直接传给 `useEffect`，如果比较的结果为 `false` 时，那就触发 `effect`。

所以需要一个参数用来传给 `useEffect`，并且当比较结果为 `false` 时，这个参数能与上次的值不同。

那么简单点就是将这个参数设置为自增的，每当比较结果为 `false` 时，就自增 `1`。同时用 `useRef` 记录每次比较的结果。

而每次传入的 `deps` 同样也需要用 `useRef` 记录，用于每次比较时，判断 `deps` 是否发生变化。

所以，最后实现的代码如下：

{/* prettier-ignore */}

```ts
import { useEffect, useRef } from 'react';

export const useCustomCompareEffect = (effect, deps, isEqual = Object.is) => {
  const depsRef = useRef(undefined);
  const signalRef = useRef(0);
  if (deps === undefined || !isEqual(deps, depsRef.current)) {
    signalRef.current += 1;
  }
  depsRef.current = deps;
  useEffect(effect, [signalRef.current]);
};
```

`useCustomCompareEffect` 函数接收三个参数：`effect` 是回调函数，`deps` 是依赖数组，`isEqual` 是自定义比较函数。

如果 `isEqual` 未传入，则默认使用 `Object.is` 进行比较。并且当前的执行逻辑与 `useEffect` 一致。

函数内部将 `depsRef` 的初始值设置为 `undefined`，因为 `useEffect` 的 `deps` 是可选的。如果未传入，则需要每次渲染时都触发 `effect`。

再将 `signalRef` 的初始值设置为 `0`，用于后续自增。

接着判断 `deps` 是否为 `undefined`，或者是否与上次记录的 `deps` 不一致，如果不一致，则自增 `signalRef`。

然后更新 `depsRef` 的值为当前最新的 `deps`。

最后将 `signalRef` 的值作为 `deps` 传给 `useEffect`，用于触发 `effect`。

小测一下～

<ViewCode component={<ViewCodeActualComponent1 />} code={"'use client'\n\nimport { useEffect, useState, useRef } from 'react'\n\nexport const useCustomCompareEffect = (effect, deps, isEqual = Object.is) => {\n  const depsRef = useRef(undefined)\n  const signalRef = useRef(0)\n  if (deps === undefined || !isEqual(deps, depsRef.current)) {\n    signalRef.current += 1\n  }\n  depsRef.current = deps\n  useEffect(effect, [signalRef.current])\n}\n\nexport default function Demo() {\n  const [count, setCount] = useState(0)\n  const effectCountRef = useRef(0)\n  const customCompareCountRef = useRef(0)\n\n  useEffect(() => {\n    effectCountRef.current += 1\n  }, [{}])\n\n  useCustomCompareEffect(\n    () => {\n      customCompareCountRef.current += 1\n    },\n    [customCompareCountRef.current],\n    // 当大于等于 5 时，不再触发 effect\n    (newDeps, oldDeps) => {\n      return newDeps[0] >= 5\n    },\n  )\n\n  return (\n    <div>\n      <p>effectCount: {effectCountRef.current}</p>\n      <p>customCompareCount: {customCompareCountRef.current}</p>\n      <p>\n        <button type=\"button\" onClick={() => setCount(c => c + 1)}>\n          reRender\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

了解了 `useCustomCompareEffect` 的实现后，这时候再看 `createDeepCompareEffect` 的实现，一切都豁然开朗了。

无非就是在 `createDeepCompareEffect` 内部默认用 `react-fast-compare` 的 `isEqual` 来比较 `deps` 是否发生变化。其余部分与 `useCustomCompareEffect` 一致。

{/* prettier-ignore */}

```ts
export const createDeepCompareEffect: CreateUpdateEffect = (hook) => {
  return (effect, deps) => {
    const ref = useRef<DependencyList>(undefined);
    const signalRef = useRef<number>(0);
    if (deps === undefined || !depsEqual(deps, ref.current)) { // [!code highlight]
      signalRef.current += 1;
    }
    ref.current = deps;
    hook(effect, [signalRef.current]);
  }
};
```

关于 `react-fast-compare` 的性能，与其他常用库对比了一下：

<img alt="benchmark" src={__img0} placeholder="blur" />

在对比原始值时，`react-fast-compare` 的性能居末，但对比对象、数组时，性能位居前二。尤其是对象的比对，测了好几轮，一直是第一。可见其在 `React` 中用来对比 `deps`，还是很能打的。


# useDeepCompareLayoutEffect





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-deep-compare-layout-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDeepCompareLayoutEffect/index.tsx" text="源码" />

## 用法

用法与 `useLayoutEffect` 一致，不同的是，会深度比较依赖。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useLayoutEffect, useState, useRef } from 'react'\nimport { useDeepCompareLayoutEffect } from 'ahooks'\n\nexport default function Demo() {\n  const [, setCount] = useState(0)\n  const effectCountRef = useRef(0)\n  const deepCompareCountRef = useRef(0)\n\n  useLayoutEffect(() => {\n    effectCountRef.current += 1\n  }, [{}])\n\n  useDeepCompareLayoutEffect(() => {\n    deepCompareCountRef.current += 1\n    return () => {\n      // do something\n    }\n  }, [{}])\n\n  return (\n    <div>\n      <p>effectCount: {effectCountRef.current}</p>\n      <p>deepCompareCount: {deepCompareCountRef.current}</p>\n      <p>\n        <button type=\"button\" onClick={() => setCount(c => c + 1)}>\n          reRender\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="useDeepCompareLayoutEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="useDeepCompareLayoutEffect.ts">
      useDeepCompareLayoutEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="useDeepCompareLayoutEffect.ts">
    ```ts
    import { useLayoutEffect } from 'react';
    import { createDeepCompareEffect } from '../createDeepCompareEffect';

    export default createDeepCompareEffect(useLayoutEffect);
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="createDeepCompareEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="createDeepCompareEffect.ts">
      createDeepCompareEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="createDeepCompareEffect.ts">
    ```ts
    import { useRef } from 'react';
    import type { DependencyList, useEffect, useLayoutEffect } from 'react';
    import { depsEqual } from '../utils/depsEqual';

    type EffectHookType = typeof useEffect | typeof useLayoutEffect;

    type CreateUpdateEffect = (hook: EffectHookType) => EffectHookType;

    export const createDeepCompareEffect: CreateUpdateEffect = (hook) => (effect, deps) => {
      const ref = useRef<DependencyList>(undefined);
      const signalRef = useRef<number>(0);
      if (deps === undefined || !depsEqual(deps, ref.current)) {
        signalRef.current += 1;
      }
      ref.current = deps;
      hook(effect, [signalRef.current]);
    };
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="depsEqual.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="depsEqual.ts">
      depsEqual.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="depsEqual.ts">
    ```ts
    import type { DependencyList } from 'react';
    import isEqual from 'react-fast-compare';

    export const depsEqual = (aDeps: DependencyList = [], bDeps: DependencyList = []) =>
      isEqual(aDeps, bDeps);
    ```
  </CodeBlockTab>
</CodeBlockTabs>

## 解读

关于 `createDeepCompareEffect` 的解读，可以查看对应文档：[useDeepCompareEffect](../../effect/use-deep-compare-effect/#解读)。


# useInterval



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-interval" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useInterval/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useLockFn



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-lock-fn" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLockFn/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useRafInterval



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-raf-interval" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRafInterval/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useRafTimeout



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-raf-timeout" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRafTimeout/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useThrottleEffect





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-throttle-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useThrottleEffect/index.ts" text="源码" />

## 用法

用来处理节流副作用的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState } from 'react'\nimport { useThrottleEffect } from 'ahooks'\n\nexport default function Demo() {\n  const [value, setValue] = useState('hello')\n  const [records, setRecords] = useState<string[]>([])\n  useThrottleEffect(\n    () => {\n      setRecords(val => [...val, value])\n    },\n    [value],\n    {\n      wait: 1000,\n    },\n  )\n  return (\n    <div>\n      <input\n        value={value}\n        onChange={e => setValue(e.target.value)}\n        placeholder=\"Typed value\"\n        style={{ width: 280 }}\n      />\n      <p style={{ marginTop: 16 }}>\n        <ul>\n          {records.map((record, index) => (\n            <li key={index}>{record}</li>\n          ))}\n        </ul>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useThrottleEffect.ts"
import { useEffect, useState } from 'react';
import type { DependencyList, EffectCallback } from 'react';
import type { ThrottleOptions } from '../useThrottle/throttleOptions';
import useThrottleFn from '../useThrottleFn';
import useUpdateEffect from '../useUpdateEffect';

function useThrottleEffect(
  effect: EffectCallback,
  deps?: DependencyList,
  options?: ThrottleOptions,
) {
  const [flag, setFlag] = useState({});

  const { run } = useThrottleFn(() => {
    setFlag({});
  }, options);

  useEffect(() => {
    return run();
  }, deps);

  useUpdateEffect(effect, [flag]);
}

export default useThrottleEffect;
```

## 解读

<Callout>
  关于
  `useThrottleFn`、`useUpdateEffect`，可以查看对应文档：[useThrottleFn](../../effect/use-throttle-fn/)、[useUpdateEffect](../../effect/use-update-effect/)。
</Callout>

{/* prettier-ignore */}

```ts
function useThrottleEffect(
  effect: EffectCallback,
  deps?: DependencyList,
  options?: ThrottleOptions,
) { 
  // 1. 首先，使用 useState 定义了一个 flag 状态，用于记录依赖是否更新。
  const [flag, setFlag] = useState({});

  // 2. 然后，使用 useThrottleFn 来定义一个节流函数。
  const { run } = useThrottleFn(() => {
    setFlag({});
  }, options);

  // 3. 接着，使用 useEffect 来监听依赖的更新，并调用 run 函数执行节流函数。
  useEffect(() => {
    return run();
  }, deps);

  // 4. 最后，使用 useUpdateEffect 来监听 flag 的变化，并执行 effect。
  useUpdateEffect(effect, [flag]);
}
```


# useThrottleFn





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-throttle-fn" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useThrottleFn/index.ts" text="源码" />

## 用法

用来处理节流函数的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState } from 'react'\nimport { useThrottleFn } from 'ahooks'\n\nexport default function Demo() {\n  const [value, setValue] = useState(0)\n  const { run } = useThrottleFn(\n    () => {\n      setValue(value + 1)\n    },\n    { wait: 500 },\n  )\n\n  return (\n    <div>\n      <p style={{ marginTop: 16 }}> Clicked count: {value} </p>\n      <button type=\"button\" onClick={run}>\n        Click fast!\n      </button>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useThrottleFn.ts"
import throttle from 'lodash/throttle';
import { useMemo } from 'react';
import useLatest from '../useLatest';
import type { ThrottleOptions } from '../useThrottle/throttleOptions';
import useUnmount from '../useUnmount';
import { isFunction } from '../utils';
import isDev from '../utils/isDev';

type noop = (...args: any[]) => any;

function useThrottleFn<T extends noop>(fn: T, options?: ThrottleOptions) {
  if (isDev) {
    if (!isFunction(fn)) {
      console.error(`useThrottleFn expected parameter is a function, got ${typeof fn}`);
    }
  }

  const fnRef = useLatest(fn);

  const wait = options?.wait ?? 1000;

  const throttled = useMemo(
    () =>
      throttle(
        (...args: Parameters<T>): ReturnType<T> => {
          return fnRef.current(...args);
        },
        wait,
        options,
      ),
    [],
  );

  useUnmount(() => {
    throttled.cancel();
  });

  return {
    run: throttled,
    cancel: throttled.cancel,
    flush: throttled.flush,
  };
}

export default useThrottleFn;
```

## 解读

<Callout>
  关于
  `useLatest`、`useUnmount`，可以查看对应文档：[useLatest](../../advanced/use-latest/)、[useUnmount](../../life-cycle/use-unmount/)。
</Callout>

{/* prettier-ignore */}

```ts
function useThrottleFn<T extends noop>(fn: T, options?: ThrottleOptions) {
  // 1. 首先，使用 useLatest 来记录函数的最新值。
  const fnRef = useLatest(fn);

  // 2. 然后，使用 options 中的 wait 属性来设置节流时间，默认值为 1000ms。
  const wait = options?.wait ?? 1000;

  // 3. 接着，使用 useMemo 来缓存节流后的函数。节流后的函数内部会调用 fnRef 对象的值，并返回函数的执行结果。
  const throttled = useMemo(
    () =>
      // 使用 lodash 的 throttle 函数实现节流函数，参数配置也完全与 lodash 的 throttle 函数一致。
      throttle(
        (...args: Parameters<T>): ReturnType<T> => {
          return fnRef.current(...args);
        },
        wait,
        options,
      ),
    [],
  );

  // 4. 然后，使用 useUnmount 来卸载节流后的函数。
  useUnmount(() => {
    throttled.cancel();
  });

  // 5. 最后，返回节流后的函数，包括 run、cancel、flush 三个方法。
  return {
    run: throttled,
    cancel: throttled.cancel,
    flush: throttled.flush,
  };
}
```


# useTimeout



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-timeout" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useTimeout/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useUpdateEffect





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-update-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useUpdateEffect/index.ts" text="源码" />

## 用法

用法等同于 `useEffect`，但不同的是，会忽略首次执行，只在依赖更新时执行。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useEffect, useState } from 'react'\nimport { useUpdateEffect } from 'ahooks'\n\nexport default function Demo() {\n  const [count, setCount] = useState(0)\n  const [effectCount, setEffectCount] = useState(0)\n  const [updateEffectCount, setUpdateEffectCount] = useState(0)\n\n  useEffect(() => {\n    setEffectCount(c => c + 1)\n  }, [count])\n\n  useUpdateEffect(() => {\n    setUpdateEffectCount(c => c + 1)\n    return () => {\n      // do something\n    }\n  }, [count]) // you can include deps array if necessary\n\n  return (\n    <div>\n      <p>effectCount: {effectCount}</p>\n      <p>updateEffectCount: {updateEffectCount}</p>\n      <p>\n        <button type=\"button\" onClick={() => setCount(c => c + 1)}>\n          reRender\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="useUpdateEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="useUpdateEffect.ts">
      useUpdateEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="useUpdateEffect.ts">
    ```ts
    import { useEffect } from 'react';
    import { createUpdateEffect } from '../createUpdateEffect';

    export default createUpdateEffect(useEffect);
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="createUpdateEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="createUpdateEffect.ts">
      createUpdateEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="createUpdateEffect.ts">
    ```ts
    import { useRef } from 'react';
    import type { useEffect, useLayoutEffect } from 'react';

    type EffectHookType = typeof useEffect | typeof useLayoutEffect;

    export const createUpdateEffect: (hook: EffectHookType) => EffectHookType =
      (hook) => (effect, deps) => {
        const isMounted = useRef(false);

        // for react-refresh
        hook(() => {
          return () => {
            isMounted.current = false;
          };
        }, []);

        hook(() => {
          if (!isMounted.current) {
            isMounted.current = true;
          } else {
            return effect();
          }
        }, deps);
      };

    export default createUpdateEffect;
    ```
  </CodeBlockTab>
</CodeBlockTabs>

## 解读

首先，调用 `createUpdateEffect` 函数，传入 `useEffect` 函数。`createUpdateEffect` 函数接收一个函数作为参数，返回一个新函数。这样封装的目的是为了支持 `useLayoutEffect` 的用法。ahooks 中有很多类似的这种封装，因为需要同时支持 `useEffect` 和 `useLayoutEffect` 的用法。

直接把源码中的参数 `hook` 替换成 `useEffect`，再来看看实际的代码：

```ts
export const useUpdateEffect = (effect, deps) => {
  // 1. 使用 useRef 定义一个 ref 对象，用于记录组件是否已经挂载
  const isMounted = useRef(false)

  // 2. 使用 useEffect 监听组件的卸载，在组件卸载时，将 isMounted 的值设置为 false
  useEffect(() => {
    return () => {
      isMounted.current = false
    }
  }, [])

  // 3. 使用 useEffect 监听依赖的更新
  //    因为 useEffect 会在组件挂载时执行一次，但是由于 isMounted 的初始值为 false，所以会跳过这次 effect 的执行
  //    后续依赖更新时，才会执行 effect
  useEffect(() => {
    if (!isMounted.current) {
      isMounted.current = true
    } else {
      return effect()
    }
  }, deps)
}
```


# useUpdateLayoutEffect





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-update-layout-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useUpdateLayoutEffect/index.ts" text="源码" />

## 用法

用法与 `useLayoutEffect` 一致，不同的是，会忽略首次执行，只在依赖更新时执行。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useLayoutEffect, useState } from 'react'\nimport { useUpdateLayoutEffect } from 'ahooks'\n\nexport default function Demo() {\n  const [count, setCount] = useState(0)\n  const [layoutEffectCount, setLayoutEffectCount] = useState(0)\n  const [updateLayoutEffectCount, setUpdateLayoutEffectCount] = useState(0)\n\n  useLayoutEffect(() => {\n    setLayoutEffectCount(c => c + 1)\n  }, [count])\n\n  useUpdateLayoutEffect(() => {\n    setUpdateLayoutEffectCount(c => c + 1)\n    return () => {\n      // do something\n    }\n  }, [count]) // you can include deps array if necessary\n\n  return (\n    <div>\n      <p>layoutEffectCount: {layoutEffectCount}</p>\n      <p>updateLayoutEffectCount: {updateLayoutEffectCount}</p>\n      <p>\n        <button type=\"button\" onClick={() => setCount(c => c + 1)}>\n          reRender\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="useUpdateLayoutEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="useUpdateLayoutEffect.ts">
      useUpdateLayoutEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="useUpdateLayoutEffect.ts">
    ```ts
    import { useLayoutEffect } from 'react';
    import { createUpdateEffect } from '../createUpdateEffect';

    export default createUpdateEffect(useLayoutEffect);
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="createUpdateEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="createUpdateEffect.ts">
      createUpdateEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="createUpdateEffect.ts">
    ```ts
    import { useRef } from 'react';
    import type { useEffect, useLayoutEffect } from 'react';

    type EffectHookType = typeof useEffect | typeof useLayoutEffect;

    export const createUpdateEffect: (hook: EffectHookType) => EffectHookType =
      (hook) => (effect, deps) => {
        const isMounted = useRef(false);

        // for react-refresh
        hook(() => {
          return () => {
            isMounted.current = false;
          };
        }, []);

        hook(() => {
          if (!isMounted.current) {
            isMounted.current = true;
          } else {
            return effect();
          }
        }, deps);
      };

    export default createUpdateEffect;
    ```
  </CodeBlockTab>
</CodeBlockTabs>

## 解读

关于 `createUpdateEffect` 的解读，可以查看对应文档：[useUpdateEffect](../../effect/use-update-effect/#解读)。


# useUpdate





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-update" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useUpdate/index.ts" text="源码" />

## 用法

返回一个函数，调用该函数会强制组件重新渲染。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useUpdate } from 'ahooks'\n\nexport default function Demo() {\n  const update = useUpdate()\n\n  return (\n    <>\n      <div>Time: {new Date().toISOString()}</div>\n      <button type=\"button\" onClick={update} style={{ marginTop: 8 }}>\n        update\n      </button>\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useUpdate.ts"
import { useCallback, useState } from 'react';

const useUpdate = () => {
  const [, setState] = useState({});

  return useCallback(() => setState({}), []);
};

export default useUpdate;
```

## 解读

{/* prettier-ignore */}

```ts
function useUpdate() {
  // 1. 使用 useState 定义一个空对象，用于记录状态，只需要这个状态更新函数，不需要这个状态
  const [, setState] = useState({});

  // 2. 使用 useCallback 返回一个函数，调用该函数会执行 setState 函数，传入一个空对象，从而触发组件重新渲染
  return useCallback(() => setState({}), []);
}
```


# useAntdTable



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-antd-table" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useAntdTable/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useCountDown



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-count-down" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useCountDown/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useCounter



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-counter" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useCounter/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useDynamicList



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-dynamic-list" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDynamicList/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useFusionTable



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-fusion-table" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useFusionTable/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useHistoryTravel



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-history-travel" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useHistoryTravel/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useInfiniteScroll



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-infinite-scroll" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useInfiniteScroll/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useNetwork



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-network" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useNetwork/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# usePagination



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-pagination" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/usePagination/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useSelections



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-selections" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useSelections/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useTextSelection



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-text-selection" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useTextSelection/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useTheme



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-theme" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useTheme/index.ts" text="源码" />

## 用法

获取并设置当前主题，并将主题存储在 `localStorage` 中。

{/* FIXME ReferenceError: localStorage is not defined */}

{/* <ViewCode src="./use-theme/use-theme.tsx" /> */}

## 源码

{/* prettier-ignore */}

```ts title="useTheme.ts"
import { useEffect, useState } from 'react';
import useMemoizedFn from '../useMemoizedFn';
import isBrowser from '../utils/isBrowser';

export enum ThemeMode {
  LIGHT = 'light',
  DARK = 'dark',
  SYSTEM = 'system',
}

export type ThemeModeType = `${ThemeMode}`;

export type ThemeType = 'light' | 'dark';

const useCurrentTheme = () => {
  const matchMedia = isBrowser ? window.matchMedia('(prefers-color-scheme: dark)') : undefined;
  const [theme, setTheme] = useState<ThemeType>(() => {
    if (isBrowser) {
      return matchMedia?.matches ? ThemeMode.DARK : ThemeMode.LIGHT;
    } else {
      return ThemeMode.LIGHT;
    }
  });

  useEffect(() => {
    const onThemeChange: MediaQueryList['onchange'] = (event) => {
      if (event.matches) {
        setTheme(ThemeMode.DARK);
      } else {
        setTheme(ThemeMode.LIGHT);
      }
    };

    matchMedia?.addEventListener('change', onThemeChange);

    return () => {
      matchMedia?.removeEventListener('change', onThemeChange);
    };
  }, []);

  return theme;
};

type Options = {
  localStorageKey?: string;
};

export default function useTheme(options: Options = {}) {
  const { localStorageKey } = options;

  const [themeMode, setThemeMode] = useState<ThemeModeType>(() => {
    const preferredThemeMode =
      localStorageKey?.length && (localStorage.getItem(localStorageKey) as ThemeModeType | null);

    return preferredThemeMode || ThemeMode.SYSTEM;
  });

  const setThemeModeWithLocalStorage = (mode: ThemeModeType) => {
    setThemeMode(mode);

    if (localStorageKey?.length) {
      localStorage.setItem(localStorageKey, mode);
    }
  };

  const currentTheme = useCurrentTheme();
  const theme = themeMode === ThemeMode.SYSTEM ? currentTheme : themeMode;

  return {
    theme,
    themeMode,
    setThemeMode: useMemoizedFn(setThemeModeWithLocalStorage),
  };
}
```

## 解读

先看 `useCurrentTheme` 的实现，用来获取当前的主题 `light` 或 `dark`。

创建一个 `matchMedia` 对象，用来监听系统主题的变化。并用一个 `state` 记录当前的主题 `light` 或 `dark`。

{/* prettier-ignore */}

```ts
const useCurrentTheme = () => {
  const matchMedia = isBrowser ? window.matchMedia('(prefers-color-scheme: dark)') : undefined; // [!code focus:8]
  const [theme, setTheme] = useState<ThemeType>(() => {
    if (isBrowser) {
      return matchMedia?.matches ? ThemeMode.DARK : ThemeMode.LIGHT;
    } else {
      return ThemeMode.LIGHT;
    }
  });

  /* ... */
};
```

然后在 `useEffect` 中监听系统主题的变化，并更新 `theme`。最后返回 `theme`。

{/* prettier-ignore */}

```ts
const useCurrentTheme = () => {
  /* ... */

  useEffect(() => { // [!code focus:17]
    const onThemeChange: MediaQueryList['onchange'] = (event) => {
      if (event.matches) {
        setTheme(ThemeMode.DARK);
      } else {
        setTheme(ThemeMode.LIGHT);
      }
    };

    matchMedia?.addEventListener('change', onThemeChange);

    return () => {
      matchMedia?.removeEventListener('change', onThemeChange);
    };
  }, []);

  return theme;
};
```

接着看 `useTheme` 的实现。

从入参中获取 `localStorageKey`。

如果 `localStorageKey` 存在，则从 `localStorage` 中获取主题模式。否则使用默认值 `ThemeMode.SYSTEM`。

这里的 `themeMode` 是主题模式，可选值有：`light`、`dark`、`system`。

{/* prettier-ignore */}

```ts
export default function useTheme(options: Options = {}) {
  const { localStorageKey } = options; // [!code focus:8]

  const [themeMode, setThemeMode] = useState<ThemeModeType>(() => {
    const preferredThemeMode =
      localStorageKey?.length && (localStorage.getItem(localStorageKey) as ThemeModeType | null);

    return preferredThemeMode || ThemeMode.SYSTEM;
  });

  /* ... */
}
```

然后是定义 `setThemeModeWithLocalStorage` 函数，用来更新 `themeMode`，并将值存储到 `localStorage` 中。

{/* prettier-ignore */}

```ts
export default function useTheme(options: Options = {}) {
  /* ... */

  const setThemeModeWithLocalStorage = (mode: ThemeModeType) => { // [!code focus:7]
    setThemeMode(mode);

    if (localStorageKey?.length) {
      localStorage.setItem(localStorageKey, mode);
    }
  };

  /* ... */
}
```

最后，先是调用 `useCurrentTheme` 获取当前主题 `currentTheme`。

如果 `themeMode` 为 `system`，则使用 `currentTheme` 作为当前主题。否则使用 `themeMode` 作为当前主题。

最后返回 `theme`、`themeMode` 和 `setThemeMode` 函数。

<Callout>
  关于
  `useMemoizedFn`，可以查看对应文档：[useMemoizedFn](../../advanced/use-memoized-fn/)，用来缓存函数引用，避免重复创建函数。
</Callout>

{/* prettier-ignore */}

```ts
export default function useTheme(options: Options = {}) {
  /* ... */

  const currentTheme = useCurrentTheme(); // [!code focus:8]
  const theme = themeMode === ThemeMode.SYSTEM ? currentTheme : themeMode;

  return {
    theme,
    themeMode,
    setThemeMode: useMemoizedFn(setThemeModeWithLocalStorage),
  };
}
```


# useVirtualList



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-virtual-list" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useVirtualList/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useWebSocket



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-web-socket" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useWebSocket/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useBoolean





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-boolean#useboolean" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useBoolean/index.ts" text="源码" />

## 用法

用来管理布尔值的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useBoolean } from 'ahooks'\n\nexport default function Demo() {\n  const [state, { toggle, setTrue, setFalse }] = useBoolean(true)\n\n  return (\n    <div>\n      <p>Effects：{JSON.stringify(state)}</p>\n      <p>\n        <button type=\"button\" onClick={toggle}>\n          Toggle\n        </button>\n        <button type=\"button\" onClick={setFalse} style={{ margin: '0 16px' }}>\n          Set false\n        </button>\n        <button type=\"button\" onClick={setTrue}>\n          Set true\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useBoolean.ts"
import { useMemo } from 'react';
import useToggle from '../useToggle';

export interface Actions {
  setTrue: () => void;
  setFalse: () => void;
  set: (value: boolean) => void;
  toggle: () => void;
}

export default function useBoolean(defaultValue = false): [boolean, Actions] {
  const [state, { toggle, set }] = useToggle(!!defaultValue);

  const actions: Actions = useMemo(() => {
    const setTrue = () => set(true);
    const setFalse = () => set(false);
    return {
      toggle,
      set: (v) => set(!!v),
      setTrue,
      setFalse,
    };
  }, []);

  return [state, actions];
}
```

## 解读

*TODO*


# useCookieState



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-cookie-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useCookieState/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useDebounce





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-raf-state#userafstate" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDebounce/index.ts" text="源码" />

## 用法

用来处理防抖值的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState } from 'react'\nimport { useDebounce } from 'ahooks'\n\nexport default function Demo() {\n  const [value, setValue] = useState<string>()\n  const debouncedValue = useDebounce(value, { wait: 500 })\n\n  return (\n    <div>\n      <input\n        value={value}\n        onChange={e => setValue(e.target.value)}\n        placeholder=\"Typed value\"\n        style={{ width: 280 }}\n      />\n      <p style={{ marginTop: 16 }}>Value: {value}</p>\n      <p style={{ marginTop: 16 }}>DebouncedValue（延时 500ms 后更新）: {debouncedValue}</p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useDebounce.ts"
import { useEffect, useState } from 'react';
import useDebounceFn from '../useDebounceFn';
import type { DebounceOptions } from './debounceOptions';

function useDebounce<T>(value: T, options?: DebounceOptions) {
  const [debounced, setDebounced] = useState(value);

  const { run } = useDebounceFn(() => {
    setDebounced(value);
  }, options);

  useEffect(() => {
    run();
  }, [value]);

  return debounced;
}

export default useDebounce;
```

## 解读

<Callout>
  关于 `useDebounceFn`，可以查看对应文档：[useDebounceFn](../../effect/use-debounce-fn/)。
</Callout>

{/* prettier-ignore */}

```ts
function useDebounce<T>(value: T, options?: DebounceOptions) {
  // 1. 首先，使用 useState 定义了一个 debounced 状态，用于存储防抖后的值。
  const [debounced, setDebounced] = useState(value);

  // 2. 然后，使用 useDebounceFn 来定义一个防抖函数。
  const { run } = useDebounceFn(() => {
    setDebounced(value);
  }, options);

  // 3. 接着，使用 useEffect 来监听 value 的变化，并调用 run 函数执行防抖函数。
  useEffect(() => {
    run();
  }, [value]);

  // 4. 最后，返回防抖后的值。
  return debounced;
}
```


# useGetState



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-get-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useGetState/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useLocalStorageState



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-local-storage-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLocalStorageState/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useMap





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-map" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMap/index.ts" text="源码" />

## 用法

管理 `Map` 类型状态。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useMap } from 'ahooks'\n\nexport default function Demo() {\n  const [map, { set, setAll, remove, reset, get }] = useMap<string | number, string>([\n    ['msg', 'hello world'],\n    [123, 'number type'],\n  ])\n\n  return (\n    <div>\n      <button type=\"button\" onClick={() => set(String(Date.now()), new Date().toJSON())}>\n        Add\n      </button>\n      <button\n        type=\"button\"\n        onClick={() => setAll([['text', 'this is a new Map']])}\n        style={{ margin: '0 8px' }}\n      >\n        Set new Map\n      </button>\n      <button type=\"button\" onClick={() => remove('msg')} disabled={!get('msg')}>\n        Remove {'msg'}\n      </button>\n      <button type=\"button\" onClick={() => reset()} style={{ margin: '0 8px' }}>\n        Reset\n      </button>\n      <div style={{ marginTop: 16 }}>\n        <pre>{JSON.stringify(Array.from(map), null, 2)}</pre>\n      </div>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useMap.ts"
import { useState } from 'react';
import useMemoizedFn from '../useMemoizedFn';

function useMap<K, T>(initialValue?: Iterable<readonly [K, T]>) {
  const getInitValue = () => new Map(initialValue);
  const [map, setMap] = useState<Map<K, T>>(getInitValue);

  const set = (key: K, entry: T) => {
    setMap((prev) => {
      const temp = new Map(prev);
      temp.set(key, entry);
      return temp;
    });
  };

  const setAll = (newMap: Iterable<readonly [K, T]>) => {
    setMap(new Map(newMap));
  };

  const remove = (key: K) => {
    setMap((prev) => {
      const temp = new Map(prev);
      temp.delete(key);
      return temp;
    });
  };

  const reset = () => setMap(getInitValue());

  const get = (key: K) => map.get(key);

  return [
    map,
    {
      set: useMemoizedFn(set),
      setAll: useMemoizedFn(setAll),
      remove: useMemoizedFn(remove),
      reset: useMemoizedFn(reset),
      get: useMemoizedFn(get),
    },
  ] as const;
}

export default useMap;
```

## 解读

<Callout>
  关于 `useMemoizedFn`，可以查看对应文档：[useMemoizedFn](../../advanced/use-memoized-fn/)。
</Callout>

本质上 `useMap` 返回的就是一个普通 `Map` 类型的数据，而在更新时则传入一个新的 `Map` 对象，从而触发页面重新渲染。

{/* prettier-ignore */}

```ts
function useMap<K, V>(initialValue?: Iterable<[K, V]>) {
  // 1. 定义一个获取初始值的函数，方便后续 reset 函数内部调用
  const getInitValue = () => new Map(initialValue);
  // 2. 定义一个 `Map` 类型的状态，初始值为 `getInitValue` 函数的返回值
  const [map, setMap] = useState<Map<K, T>>(getInitValue);

  // 3. 定义一个更新 `Map` 内某个键值对的方法，传入一个键和值，更新时返回一个新的 `Map` 对象
  const set = useMemoizedFn((key: K, entry: T) => {
    setMap((prev) => {
      const temp = new Map(prev);
      temp.set(key, entry);
      return temp;
    });
  });

  // 4. 定义一个全量更新 `Map` 数据的方法，传入一个 `Map` 对象，全量更新时传入一个新的 `Map` 对象
  const setAll = (newMap: Iterable<readonly [K, T]>) => {
    setMap(new Map(newMap));
  };

  // 5. 定义一个删除 `Map` 内某个键值对的方法，传入一个键，删除时返回一个新的 `Map` 对象
  const remove = useMemoizedFn((key: K) => {
    setMap((prev) => {
      const temp = new Map(prev);
      temp.delete(key);
      return temp;
    });
  };

  // 6. 定义一个重置 `Map` 数据的方法，重置时传入 `getInitValue` 函数的返回值
  const reset = () => setMap(getInitValue());

  // 7. 定义一个获取 `Map` 内某个键值对的方法，传入一个键，获取时返回 `Map` 对象中对应键的值
  const get = (key: K) => map.get(key);

  // 8. 返回 `Map` 对象和更新 `Map` 数据的方法
  return [
    map,
    {
      set: useMemoizedFn(set),
      setAll: useMemoizedFn(setAll),
      remove: useMemoizedFn(remove),
      reset: useMemoizedFn(reset),
      get: useMemoizedFn(get),
    },
  ] as const;
}
```


# usePrevious





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-previous" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/usePrevious/index.ts" text="源码" />

## 用法

保存上一次状态的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { usePrevious } from 'ahooks'\nimport { useState } from 'react'\n\nexport default function Demo() {\n  const [count, setCount] = useState(0)\n  const previous = usePrevious(count)\n  return (\n    <>\n      <div>counter current value: {count}</div>\n      <div style={{ marginBottom: 8 }}>counter previous value: {previous}</div>\n      <button type=\"button\" onClick={() => setCount(c => c + 1)}>\n        increase\n      </button>\n      <button type=\"button\" style={{ marginLeft: 8 }} onClick={() => setCount(c => c - 1)}>\n        decrease\n      </button>\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="usePrevious.ts"
import { useRef } from 'react';

export type ShouldUpdateFunc<T> = (prev?: T, next?: T) => boolean;

const defaultShouldUpdate = <T>(a?: T, b?: T) => !Object.is(a, b);

function usePrevious<T>(
  state: T,
  shouldUpdate: ShouldUpdateFunc<T> = defaultShouldUpdate,
): T | undefined {
  const prevRef = useRef<T>(undefined);
  const curRef = useRef<T>(undefined);

  if (shouldUpdate(curRef.current, state)) {
    prevRef.current = curRef.current;
    curRef.current = state;
  }

  return prevRef.current;
}

export default usePrevious;
```

## 解读

在内部定义两个 `ref` 对象，分别用于存储上一次状态和当前状态，并在每次状态更新时，判断当前状态与上一次状态是否不同，如果不同，则更新上一次状态。

{/* prettier-ignore */}

```ts
function usePrevious<T>(
  state: T,
  shouldUpdate: ShouldUpdateFunc<T> = defaultShouldUpdate,
): T | undefined {
  // 1. 定义两个 ref 对象，分别用于存储上一次状态和当前状态
  const prevRef = useRef<T>(undefined);
  const curRef = useRef<T>(undefined);

  // 2. 如果当前状态与上一次状态不同
  if (shouldUpdate(curRef.current, state)) {
    // 2.1. 更新上一次状态
    prevRef.current = curRef.current;
    // 2.2. 更新当前状态
    curRef.current = state;
  }

  // 3. 返回上一次状态
  return prevRef.current;
}
```


# useRafState





{' '}

<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-raf-state#userafstate" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRafState/index.ts" text="源码" />

## 用法

在 `requestAnimationFrame` 中更新状态。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useRafState } from 'ahooks'\nimport { useEffect, useState } from 'react'\n\nconst WithUseState = function ({ times = 1 }) {\n  const [state, setState] = useState(0)\n  useEffect(() => {\n    const onScroll = () => {\n      for (let i = 0; i < times; i++) {\n        setState(prev => prev + 1)\n      }\n    }\n\n    window.addEventListener('scroll', onScroll)\n\n    return () => {\n      window.removeEventListener('scroll', onScroll)\n    }\n  }, [])\n\n  return (\n    <div style={{ color: '#F44336' }}>\n      [WithUseState] update state count: {state} / {times}\n    </div>\n  )\n}\n\nconst WithUseRafState = function ({ times = 1 }) {\n  const [state, setState] = useRafState(0)\n  useEffect(() => {\n    const onScroll = () => {\n      for (let i = 0; i < times; i++) {\n        setState(prev => prev + 1)\n      }\n    }\n\n    window.addEventListener('scroll', onScroll)\n\n    return () => {\n      window.removeEventListener('scroll', onScroll)\n    }\n  }, [])\n\n  return (\n    <div style={{ color: '#4CAF50' }}>\n      [WithUseRafState] update state count: {state} / {times}\n    </div>\n  )\n}\n\nexport default function Demo() {\n  return (\n    <div>\n      滚动页面，观察两个组件更新次数的差异\n      <WithUseState times={1} />\n      <WithUseRafState times={1} />\n      <hr />\n      <WithUseState times={10} />\n      <WithUseRafState times={10} />\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts [useRafState.ts]
import { useCallback, useRef, useState } from 'react';
import type { Dispatch, SetStateAction } from 'react';
import useUnmount from '../useUnmount';

function useRafState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];
function useRafState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];

function useRafState<S>(initialState?: S | (() => S)) {
  const ref = useRef(0);
  const [state, setState] = useState(initialState);

  const setRafState = useCallback((value: S | ((prevState: S) => S)) => {
    cancelAnimationFrame(ref.current);

    ref.current = requestAnimationFrame(() => {
      setState(value);
    });
  }, []);

  useUnmount(() => {
    cancelAnimationFrame(ref.current);
  });

  return [state, setRafState] as const;
}

export default useRafState;
```

## 解读

*TODO*

{/* 与 `useState` 相比，`useRafState` 会在 `requestAnimationFrame` 中更新状态，而不是在 `setState` 中更新状态。 */}


# useResetState



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-reset-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useResetState/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useSafeState





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-safe-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useSafeState/index.ts" text="源码" />

## 用法

组件卸载后，不再更新状态。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useEffect, useState } from 'react'\nimport { useSafeState } from 'ahooks'\n\nconst Child = function () {\n  const [value, setValue] = useSafeState<string>()\n\n  useEffect(() => {\n    setTimeout(() => {\n      setValue('data loaded from server')\n    }, 5000)\n  }, [])\n\n  const text = value || 'Loading...'\n\n  return <div>{text}</div>\n}\n\nexport default function Demo() {\n  const [visible, setVisible] = useState(true)\n\n  return (\n    <div>\n      <button onClick={() => setVisible(!visible)}>{visible ? 'Unmount' : 'Mount'}</button>\n      {visible && <Child />}\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useSafeState.ts"
import { useCallback, useState } from 'react';
import type { Dispatch, SetStateAction } from 'react';
import useUnmountedRef from '../useUnmountedRef';

function useSafeState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];

function useSafeState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];

function useSafeState<S>(initialState?: S | (() => S)) {
  const unmountedRef = useUnmountedRef();
  const [state, setState] = useState(initialState);
  const setCurrentState = useCallback((currentState: S) => {
    /** if component is unmounted, stop update */
    if (unmountedRef.current) {
      return;
    }
    setState(currentState);
  }, []);

  return [state, setCurrentState] as const;
}

export default useSafeState;
```

## 解读

<Callout>
  关于 `useUnmountedRef`，可以查看对应文档：[useUnmountedRef](../../life-cycle/use-unmounted-ref/)。
</Callout>

内部使用 `useUnmountedRef` 来判断组件是否已经卸载，如果已经卸载，则不进行更新。

{/* prettier-ignore */}

```ts
function useSafeState<S>(initialState?: S | (() => S)) {
  const unmountedRef = useUnmountedRef(); // [!code focus:1]
  const [state, setState] = useState(initialState);
  const setCurrentState = useCallback((currentState: S) => {
    /** if component is unmounted, stop update */
    if (unmountedRef.current) { // [!code focus:3]
      return;
    }
    setState(currentState);
  }, []);

  return [state, setCurrentState] as const;
}
```

内部定义 `setCurrentState` 作为更新函数，并使用 `useCallback` 缓存函数引用，避免重复创建函数，导致重渲染。

{/* prettier-ignore */}

```ts
function useSafeState<S>(initialState?: S | (() => S)) {
  const unmountedRef = useUnmountedRef();
  const [state, setState] = useState(initialState);
  const setCurrentState = useCallback((currentState: S) => { // [!code focus:7]
    /** if component is unmounted, stop update */
    if (unmountedRef.current) {
      return;
    }
    setState(currentState);
  }, []);

  return [state, setCurrentState] as const;
}
```

最后返回 `state` 和 `setCurrentState`。

{/* prettier-ignore */}

```ts
function useSafeState<S>(initialState?: S | (() => S)) {
  const unmountedRef = useUnmountedRef();
  const [state, setState] = useState(initialState);
  const setCurrentState = useCallback((currentState: S) => {
    /** if component is unmounted, stop update */
    if (unmountedRef.current) {
      return;
    }
    setState(currentState);
  }, []);

  return [state, setCurrentState] as const; // [!code focus:1]
}
```


# useSessionStorageState



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-session-storage-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useSessionStorageState/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useSetState





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-set-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useSetState/index.ts" text="源码" />

## 用法

用于更新对象状态，自动合并对象。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useSetState } from 'ahooks'\n\ninterface State {\n  hello: string\n  [key: string]: any\n}\n\nexport default function Demo() {\n  const [state, setState] = useSetState<State>({\n    hello: '',\n  })\n\n  return (\n    <div>\n      <pre>{JSON.stringify(state, null, 2)}</pre>\n      <p>\n        <button type=\"button\" onClick={() => setState({ hello: 'world' })}>\n          set hello\n        </button>\n        <button type=\"button\" onClick={() => setState({ foo: 'bar' })} style={{ margin: '0 8px' }}>\n          set foo\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useSetState.ts"
import { useState } from 'react';
import useMemoizedFn from '../useMemoizedFn';
import { isFunction } from '../utils';

export type SetState<S extends Record<string, any>> = <K extends keyof S>(
  state: Pick<S, K> | null | ((prevState: Readonly<S>) => Pick<S, K> | S | null),
) => void;

const useSetState = <S extends Record<string, any>>(
  initialState: S | (() => S),
): [S, SetState<S>] => {
  const [state, setState] = useState<S>(initialState);

  const setMergeState = useMemoizedFn((patch) => {
    setState((prevState) => {
      const newState = isFunction(patch) ? patch(prevState) : patch;
      return newState ? { ...prevState, ...newState } : prevState;
    });
  });

  return [state, setMergeState];
};

export default useSetState;
```

## 解读

重点就是 `setMergeState` 函数。

首先使用 `useMemoizedFn` 缓存函数引用，避免重复创建函数。

<Callout>
  关于 `useMemoizedFn`，可以查看对应文档：[useMemoizedFn](../../advanced/use-memoized-fn/)。
</Callout>

{/* prettier-ignore */}

```ts
const useSetState = <S extends Record<string, any>>(
  initialState: S | (() => S),
): [S, SetState<S>] => {
  const [state, setState] = useState<S>(initialState);

  const setMergeState = useMemoizedFn((patch) => { // [!code focus:6]
    setState((prevState) => {
      const newState = isFunction(patch) ? patch(prevState) : patch;
      return newState ? { ...prevState, ...newState } : prevState;
    });
  });

  return [state, setMergeState];
};
```

内部直接调用 `setState` 函数，并传入一个回调函数。

{/* prettier-ignore */}

```ts
const useSetState = <S extends Record<string, any>>(
  initialState: S | (() => S),
): [S, SetState<S>] => {
  const [state, setState] = useState<S>(initialState);

  const setMergeState = useMemoizedFn((patch) => { 
    setState((prevState) => { // [!code focus:4]
      const newState = isFunction(patch) ? patch(prevState) : patch;
      return newState ? { ...prevState, ...newState } : prevState;
    });
  });

  return [state, setMergeState];
};
```

如果 `patch` 是函数，则调用 `patch` 函数，并传入 `prevState` 参数，返回新的状态。否则，直接返回 `patch`。

最后，如果 `newState` 为 `Truthy` 值，则返回使用扩展运算符合并后的新对象。否则返回 `prevState`。

内部也没有对 `prevState` 和 `newState` 进行类型判断，而是直接使用扩展运算符合并。如果得到的是非 `object` 类型，则会报错。这个需要特别注意。


# useSet





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-set" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useSet/index.ts" text="源码" />

## 用法

管理 `Set` 类型状态。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useSet } from 'ahooks'\n\nexport default function Demo() {\n  const [set, { add, remove, reset }] = useSet(['Hello'])\n\n  return (\n    <div>\n      <button type=\"button\" onClick={() => add(String(Date.now()))}>\n        Add Timestamp\n      </button>\n      <button\n        type=\"button\"\n        onClick={() => remove('Hello')}\n        disabled={!set.has('Hello')}\n        style={{ margin: '0 8px' }}\n      >\n        Remove Hello\n      </button>\n      <button type=\"button\" onClick={() => reset()}>\n        Reset\n      </button>\n      <div style={{ marginTop: 16 }}>\n        <pre>{JSON.stringify(Array.from(set), null, 2)}</pre>\n      </div>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useSet.ts"
import { useState } from 'react';
import useMemoizedFn from '../useMemoizedFn';

function useSet<K>(initialValue?: Iterable<K>) {
  const getInitValue = () => new Set(initialValue);
  const [set, setSet] = useState<Set<K>>(getInitValue);

  const updateSet = (updater: (set: Set<K>) => Set<K>) => {
    setSet((prevSet) => updater(new Set(prevSet)));
  };

  const add = (key: K) => {
    if (set.has(key)) {
      return;
    }
    updateSet((newSet) => {
      newSet.add(key);
      return newSet;
    });
  };

  const remove = (key: K) => {
    if (!set.has(key)) {
      return;
    }
    updateSet((newSet) => {
      newSet.delete(key);
      return newSet;
    });
  };

  const reset = () => setSet(getInitValue());

  return [
    set,
    {
      add: useMemoizedFn(add),
      remove: useMemoizedFn(remove),
      reset: useMemoizedFn(reset),
    },
  ] as const;
}

export default useSet;
```

<Callout>
  关于 `useMemoizedFn`，可以查看对应文档：[useMemoizedFn](../../advanced/use-memoized-fn/)。
</Callout>

## 解读

在不了解 `useSet` 之前，如果使用 `useState` 初始化一个 `Set` 类型的值，更新时需要怎么做呢？

基于 `React` 的渲染逻辑，每次更新都需要传入一个新的 `Set` 对象，才能保证页面可以更新。

也即：

{/* {6,12} */}

```ts
const [set, setSet] = useState(new Set())

// add
setSet(prev => {
  prev.add('foo')
  return new Set(prev) // 返回一个新的 Set 对象
})

// remove
setSet(prev => {
  prev.delete('foo')
  return new Set(prev) // 返回一个新的 Set 对象
})
```

而 `useSet` 内部也是这样实现的，只不过为了调用方便，内部将 `add`、`remove` 和 `reset` 方法进行了封装。

在内部会定义一个 `getInitValue` 函数，函数的执行结果返回当前初始值，`reset` 方法内部就是调用 `getInitValue` 函数，对 `Set` 对象进行重置。

```ts
function useSet<K>(initialValue?: Iterable<K>) {
  const getInitValue = () => new Set(initialValue)
  const [set, setSet] = useState<Set<K>>(getInitValue)

  /* ... */

  const reset = () => setSet(getInitValue())

  /* ... */
}
```


# useThrottle





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-throttle#usethrottle" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useThrottle/index.ts" text="源码" />

## 用法

用来处理节流值的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState } from 'react'\nimport { useThrottle } from 'ahooks'\n\nexport default function Demo() {\n  const [value, setValue] = useState<string>()\n  const throttledValue = useThrottle(value, { wait: 500 })\n\n  return (\n    <div>\n      <input\n        value={value}\n        onChange={e => setValue(e.target.value)}\n        placeholder=\"Typed value\"\n        style={{ width: 280 }}\n      />\n      <p style={{ marginTop: 16 }}>throttledValue: {throttledValue}</p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useThrottle.ts"
import { useEffect, useState } from 'react';
import useThrottleFn from '../useThrottleFn';
import type { ThrottleOptions } from './throttleOptions';

function useThrottle<T>(value: T, options?: ThrottleOptions) {
  const [throttled, setThrottled] = useState(value);

  const { run } = useThrottleFn(() => {
    setThrottled(value);
  }, options);

  useEffect(() => {
    run();
  }, [value]);

  return throttled;
}

export default useThrottle;
```

## 解读

<Callout>
  关于 `useThrottleFn`，可以查看对应文档：[useThrottleFn](../../effect/use-throttle-fn/)。
</Callout>

{/* prettier-ignore */}

```ts
function useThrottle<T>(value: T, options?: ThrottleOptions) {
  // 1. 首先，使用 useState 定义了一个 throttled 状态，用于存储节流后的值。
  const [throttled, setThrottled] = useState(value);

  // 2. 然后，使用 useThrottleFn 来定义一个节流函数。
  const { run } = useThrottleFn(() => {
    setThrottled(value);
  }, options);

  // 3. 接着，使用 useEffect 来监听 value 的变化，并调用 run 函数执行节流函数。
  useEffect(() => {
    run();
  }, [value]);

  // 4. 最后，返回节流后的值。
  return throttled;
}
```


# useToggle





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-toggle#usetoggle" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useToggle/index.ts" text="源码" />

## 用法

用来管理开关状态的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useToggle } from 'ahooks'\n\nexport default function Demo() {\n  const [state, { toggle, setLeft, setRight }] = useToggle()\n\n  return (\n    <div>\n      <p>Effects：{`${state}`}</p>\n      <p>\n        <button type=\"button\" onClick={toggle}>\n          Toggle\n        </button>\n        <button type=\"button\" onClick={setLeft} style={{ margin: '0 8px' }}>\n          Toggle False\n        </button>\n        <button type=\"button\" onClick={setRight}>\n          Toggle True\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useToggle.ts"
import { useMemo, useState } from 'react';

export interface Actions<T> {
  setLeft: () => void;
  setRight: () => void;
  set: (value: T) => void;
  toggle: () => void;
}

function useToggle<T = boolean>(): [boolean, Actions<T>];

function useToggle<T>(defaultValue: T): [T, Actions<T>];

function useToggle<T, U>(defaultValue: T, reverseValue: U): [T | U, Actions<T | U>];

function useToggle<D, R>(defaultValue: D = false as unknown as D, reverseValue?: R) {
  const [state, setState] = useState<D | R>(defaultValue);

  const actions = useMemo(() => {
    const reverseValueOrigin = (reverseValue === undefined ? !defaultValue : reverseValue) as D | R;

    const toggle = () => setState((s) => (s === defaultValue ? reverseValueOrigin : defaultValue));
    const set = (value: D | R) => setState(value);
    const setLeft = () => setState(defaultValue);
    const setRight = () => setState(reverseValueOrigin);

    return {
      toggle,
      set,
      setLeft,
      setRight,
    };
    // useToggle ignore value change
    // }, [defaultValue, reverseValue]);
  }, []);

  return [state, actions];
}

export default useToggle;
```

## 解读

*TODO*


# useUrlState



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-url-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useUrlState/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useRequest





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-request" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/index.ts" text="源码" />

这里包含了 ahooks 中与网络请求相关的 Hook，特别是 useRequest。

## 用法

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useRequest } from 'ahooks'\n\nfunction getUsername(): Promise<string> {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(Math.random().toString())\n    }, 1000)\n  })\n}\n\nexport default function Demo() {\n  const { data, error, loading } = useRequest(getUsername)\n\n  if (error) {\n    return <div>failed to load</div>\n  }\n  if (loading) {\n    return <div>loading...</div>\n  }\n  return <div>Username: {data}</div>\n}\n"} />

## 源码

## 解读

*TODO*


# useConditionalEffect



```ts title="useConditionalEffect.ts"
function useConditionalEffect(effect: () => boolean | void | (() => void), deps: any[]) {
  const shouldRunRef = useRef(true)

  useEffect(() => {
    // 如果已经标记为不再执行，直接返回
    if (!shouldRunRef.current) {
      return
    }

    const cleanup = effect()

    // 如果 effect 返回 false，标记为不再执行
    if (cleanup === false) {
      shouldRunRef.current = false
    }

    // 如果返回的是清理函数，正常执行清理
    return typeof cleanup === 'function' ? cleanup : undefined
  }, deps)
}
```


# useEffect



# useEffect


# useImmer



# useImmer


# useRef



# useRef


# useState



# useState


# useWatch



# useWatch

```ts
function useWatch(source, callback, options = {}) {
  const { immediate = false } = options
  const isActive = useRef(true)
  const unwatch = useRef(() => {})

  useEffect(() => {
    if (!isActive.current) return

    let oldValue = source()

    // 立即执行一次
    if (immediate) {
      callback(oldValue, undefined)
    }

    const stop = () => {
      isActive.current = false
      unwatch.current?.()
    }

    unwatch.current = () => {
      isActive.current = false
    }

    return () => {
      if (isActive.current) {
        const newValue = source()
        if (newValue !== oldValue) {
          callback(newValue, oldValue)
        }
      }
    }
  }, [source, callback, immediate])

  return () => {
    isActive.current = false
    unwatch.current?.()
  }
}

// 使用示例
function MyComponent() {
  const [count, setCount] = useState(0)

  const stopWatch = useWatch(
    () => count, // 获取值函数
    (newVal, oldVal) => {
      console.log(`count 从 ${oldVal} 变为 ${newVal}`)
    },
    { immediate: true },
  )

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>增加</button>
      <button onClick={stopWatch}>停止监听</button>
    </div>
  )
}
```


# useControllableValue





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-controllable-value" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useControllableValue/index.ts" text="源码" />

## 用法

在某些组件开发时，我们需要组件的状态既可以自己管理，也可以被外部控制，`useControllableValue` 就是帮你管理这种状态的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState } from 'react'\nimport { useControllableValue } from 'ahooks'\n\nfunction Input(props: { value?: string; onChange?: (value: string) => void }) {\n  const [state, setState] = useControllableValue<string>(props, {\n    defaultValue: '',\n  })\n\n  return (\n    <>\n      <input value={state} onChange={e => setState(e.target.value)} style={{ width: 300 }} />\n      <button type=\"button\" onClick={() => setState('')} style={{ marginLeft: 8 }}>\n        Clear By Self\n      </button>\n    </>\n  )\n}\n\nexport default () => {\n  const [state, setState] = useState<string>('')\n  const clear = () => {\n    setState('')\n  }\n\n  return (\n    <div>\n      <div style={{ border: '1px dashed', padding: 10 }}>\n        <div>非受控组件</div>\n        <Input />\n      </div>\n      <div style={{ border: '1px dashed', padding: 10, marginTop: 10 }}>\n        <div>受控组件</div>\n        <Input value={state} onChange={setState} />\n        <button style={{ marginLeft: 10 }} onClick={clear}>\n          Clear By Parent\n        </button>\n      </div>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useControllableValue.ts"
import { useMemo, useRef } from 'react';
import type { SetStateAction } from 'react';
import { isFunction } from '../utils';
import useMemoizedFn from '../useMemoizedFn';
import useUpdate from '../useUpdate';

export interface Options<T> {
  defaultValue?: T;
  defaultValuePropName?: string;
  valuePropName?: string;
  trigger?: string;
}

export type Props = Record<string, any>;

export interface StandardProps<T> {
  value: T;
  defaultValue?: T;
  onChange: (val: T) => void;
}

function useControllableValue<T = any>(
  props: StandardProps<T>,
): [T, (v: SetStateAction<T>) => void];
function useControllableValue<T = any>(
  props?: Props,
  options?: Options<T>,
): [T, (v: SetStateAction<T>, ...args: any[]) => void];
function useControllableValue<T = any>(defaultProps?: Props, options: Options<T> = {}) {
  const props = defaultProps ?? {};

  const {
    defaultValue,
    defaultValuePropName = 'defaultValue',
    valuePropName = 'value',
    trigger = 'onChange',
  } = options;

  const value = props[valuePropName] as T;
  const isControlled = Object.prototype.hasOwnProperty.call(props, valuePropName);

  const initialValue = useMemo(() => {
    if (isControlled) {
      return value;
    }
    if (Object.prototype.hasOwnProperty.call(props, defaultValuePropName)) {
      return props[defaultValuePropName];
    }
    return defaultValue;
  }, []);

  const stateRef = useRef(initialValue);
  if (isControlled) {
    stateRef.current = value;
  }

  const update = useUpdate();

  function setState(v: SetStateAction<T>, ...args: any[]) {
    const r = isFunction(v) ? v(stateRef.current) : v;

    if (!isControlled) {
      stateRef.current = r;
      update();
    }
    if (props[trigger]) {
      props[trigger](r, ...args);
    }
  }

  return [stateRef.current, useMemoizedFn(setState)] as const;
}

export default useControllableValue;
```

## 解读

<Callout>
  关于
  `useMemoizedFn`、`useUpdate`，可以查看对应文档：[useMemoizedFn](../../advanced/use-memoized-fn/)、[useUpdate](../../effect/use-update/)。
</Callout>

*TODO*


# useCreation





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-creation#use-creation" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useCreation/index.ts" text="源码" />

## 用法

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState } from 'react'\nimport { useCreation } from 'ahooks'\n\nclass Foo {\n  constructor() {\n    this.data = Math.random()\n  }\n\n  data: number\n}\n\nexport default function Demo() {\n  const foo = useCreation(() => new Foo(), [])\n  const [, setFlag] = useState({})\n  return (\n    <>\n      <p>{foo.data}</p>\n      <button\n        type=\"button\"\n        onClick={() => {\n          setFlag({})\n        }}\n      >\n        Rerender\n      </button>\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="useCreation.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="useCreation.ts">
      useCreation.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="useCreation.ts">
    ```ts
    import type { DependencyList } from 'react';
    import { useRef } from 'react';
    import depsAreSame from '../utils/depsAreSame';

    const useCreation = <T>(factory: () => T, deps: DependencyList) => {
      const { current } = useRef({
        deps,
        obj: undefined as T,
        initialized: false,
      });
      if (current.initialized === false || !depsAreSame(current.deps, deps)) {
        current.deps = deps;
        current.obj = factory();
        current.initialized = true;
      }
      return current.obj;
    };

    export default useCreation;
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="depsAreSame.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="depsAreSame.ts">
      depsAreSame.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="depsAreSame.ts">
    ```ts
    import type { DependencyList } from 'react';

    function depsAreSame(oldDeps: DependencyList, deps: DependencyList): boolean {
      if (oldDeps === deps) {
        return true;
      }
      for (let i = 0; i < oldDeps.length; i++) {
        if (!Object.is(oldDeps[i], deps[i])) {
          return false;
        }
      }
      return true;
    }

    export default depsAreSame;
    ```
  </CodeBlockTab>
</CodeBlockTabs>

## 解读

先看 `depsAreSame` 函数，用于比较两个依赖数组是否相同，内部采用 `Object.is` 进行比较。

{/* prettier-ignore */}

```ts
function depsAreSame(oldDeps: DependencyList, deps: DependencyList): boolean {
  if (oldDeps === deps) {
    return true;
  }
  for (let i = 0; i < oldDeps.length; i++) {
    if (!Object.is(oldDeps[i], deps[i])) {
      return false;
    }
  }
  return true;
}
```

而 `useCreation` 函数则是在内部使用 `useRef` 定义了一个 `ref` 对象，用于存储依赖数组和计算结果。

{/* prettier-ignore */}

```ts title="useCreation.ts"
const useCreation = <T>(factory: () => T, deps: DependencyList) => {
  // 1. 定义一个 ref 对象，用于存储依赖数组和计算结果
  const { current } = useRef({
    deps,
    obj: undefined as T,
    initialized: false,
  });
  // 2. 如果依赖数组未初始化，或者依赖数组发生变化，则更新依赖数组并重新计算结果
  if (current.initialized === false || !depsAreSame(current.deps, deps)) {
    // 2.1. 更新依赖数组
    current.deps = deps;
    // 2.2. 重新计算结果
    current.obj = factory();
    // 2.3. 标记为已初始化
    current.initialized = true;
  }
  // 3. 返回计算结果
  return current.obj;
};
```


# useEventEmitter







<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-event-emitter" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useEventEmitter/index.ts" text="源码" />

## 用法

创建一个事件发射器，用于在组件之间传递事件。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useRef, FC } from 'react'\nimport { useEventEmitter } from 'ahooks'\nimport { EventEmitter } from 'ahooks/lib/useEventEmitter'\n\nconst MessageBox: FC<{\n  focus$: EventEmitter<void>\n}> = function (props) {\n  return (\n    <div style={{ paddingBottom: 24 }}>\n      <p>You received a message</p>\n      <button\n        type=\"button\"\n        onClick={() => {\n          props.focus$.emit()\n        }}\n      >\n        Reply\n      </button>\n    </div>\n  )\n}\n\nconst InputBox: FC<{\n  focus$: EventEmitter<void>\n}> = function (props) {\n  const inputRef = useRef<HTMLInputElement>(null)\n  props.focus$.useSubscription(() => {\n    inputRef.current.focus()\n  })\n  return (\n    <input ref={inputRef} placeholder=\"Enter reply\" style={{ width: '100%', padding: '4px' }} />\n  )\n}\n\nexport default function Demo() {\n  const focus$ = useEventEmitter()\n  return (\n    <>\n      <MessageBox focus$={focus$} />\n      <InputBox focus$={focus$} />\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts [useEventEmitter.ts]
import { useRef, useEffect } from 'react';

type Subscription<T> = (val: T) => void;

export class EventEmitter<T> {
  private subscriptions = new Set<Subscription<T>>();

  emit = (val: T) => {
    for (const subscription of this.subscriptions) {
      subscription(val);
    }
  };

  useSubscription = (callback: Subscription<T>) => {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const callbackRef = useRef<Subscription<T>>(undefined);
    callbackRef.current = callback;
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useEffect(() => {
      function subscription(val: T) {
        if (callbackRef.current) {
          callbackRef.current(val);
        }
      }
      this.subscriptions.add(subscription);
      return () => {
        this.subscriptions.delete(subscription);
      };
    }, []);
  };
}

function useEventEmitter<T = void>() {
  const ref = useRef<EventEmitter<T>>(undefined);
  if (!ref.current) {
    ref.current = new EventEmitter();
  }
  return ref.current;
}

export default useEventEmitter;
```

## 解读

先看 `EventEmitter` 类的实现。

{/* prettier-ignore */}

```ts
export class EventEmitter<T> {
  // 1. 使用 Set 存储订阅者
  private subscriptions = new Set<Subscription<T>>();

  // 2. 定义 emit 方法，用于触发事件
  emit = (val: T) => {
    // 2.1. 遍历订阅者，调用每个订阅者的回调函数
    for (const subscription of this.subscriptions) {
      subscription(val);
    }
  };

  // 3. 定义 useSubscription 方法，用于订阅事件
  useSubscription = (callback: Subscription<T>) => {
    // 3.1. 使用 useRef 存储订阅者回调函数
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const callbackRef = useRef<Subscription<T>>(undefined);
    callbackRef.current = callback;
    // 3.2. 使用 useEffect 订阅事件
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useEffect(() => {
      // 3.2.1. 定义订阅者回调函数
      function subscription(val: T) {
        // 3.2.2. 如果订阅者回调函数存在，则调用该回调函数
        if (callbackRef.current) {
          callbackRef.current(val);
        }
      }
      // 3.2.3. 将订阅者回调函数添加到订阅者集合中
      this.subscriptions.add(subscription);
      // 3.2.4. 返回一个清理函数，用于在组件卸载时清理订阅者
      return () => {
        this.subscriptions.delete(subscription);
      };
    }, []);
  };
}
```

再来看 `useEventEmitter` 函数的实现。

{/* prettier-ignore */}

```ts
function useEventEmitter<T = void>() {
  // 1. 使用 useRef 创建一个 ref 对象，用于存储 EventEmitter 实例
  const ref = useRef<EventEmitter<T>>(undefined);
  // 2. 如果 ref 对象不存在，则创建一个 EventEmitter 实例
  if (!ref.current) {
    // 2.1. 创建一个 EventEmitter 实例
    ref.current = new EventEmitter();
  }
  // 3. 返回 EventEmitter 实例
  return ref.current;
}
```

其实就是一个 `EventBus` 的 `hook` 版本，在 `EventBus` 的基础上，增加了当组件卸载时清理订阅者的功能。以及在组件的顶层调用订阅事件 `useSubscription`，因为对于一个组件来说，只需要订阅一次，也就是为什么订阅函数是一个 `hook`，而不是一个普通的函数，仅需要在顶层调用一次 `useSubscription` 即可。

而当前的 `EventEmitter` 仅支持发布者发布唯一事件，如果需要发布多个事件，那就需要创建多个 `EventEmitter` 实例了。其实根据简单改造一下就能支持多事件发布订阅。

<ViewCode component={<ViewCodeActualComponent1 />} code={"'use client'\n\nimport { useEffect, useRef, useState } from 'react'\n\ntype Subscription<T> = (val: T) => void\n\nclass MultiEventEmitter<T> {\n  private subscriptions = new Map<string, Set<Subscription<T>>>()\n\n  emit(eventName: string, val: T) {\n    if (!this.subscriptions.has(eventName)) {\n      return\n    }\n\n    const subscriptions = this.subscriptions.get(eventName)!\n    for (const subscription of subscriptions) {\n      subscription(val)\n    }\n  }\n\n  useSubscription(eventName: string, callback: Subscription<T>) {\n    const callbackRef = useRef<Subscription<T>>(undefined)\n    callbackRef.current = callback\n    useEffect(() => {\n      function subscription(val: T) {\n        if (callbackRef.current) {\n          callbackRef.current(val)\n        }\n      }\n      if (this.subscriptions.has(eventName)) {\n        this.subscriptions.get(eventName)!.add(subscription)\n      } else {\n        this.subscriptions.set(eventName, new Set([subscription]))\n      }\n      return () => {\n        this.subscriptions.get(eventName)?.delete(subscription)\n      }\n    }, [])\n  }\n}\n\nfunction useMultiEventEmitter<T>() {\n  const ref = useRef<MultiEventEmitter<T>>(undefined)\n  if (!ref.current) {\n    ref.current = new MultiEventEmitter()\n  }\n  return ref.current\n}\n\nfunction Child1({ multiEventEmitter }: { multiEventEmitter: MultiEventEmitter<string> }) {\n  const [inputMessage, setInputMessage] = useState<string>('')\n  const [messages, setMessages] = useState<string[]>([])\n  multiEventEmitter.useSubscription('chat-to-child1', message => {\n    setMessages(prev => [...prev, message])\n  })\n  return (\n    <div>\n      Child1\n      <div>\n        <input\n          style={{ width: '100%' }}\n          type=\"text\"\n          placeholder=\"Enter message to send to Child2\"\n          value={inputMessage}\n          onChange={e => setInputMessage(e.target.value)}\n          onKeyDown={e => {\n            if (e.key === 'Enter') {\n              multiEventEmitter.emit('chat-to-child2', `Child1: ${inputMessage}`)\n              setInputMessage('')\n            }\n          }}\n        />\n      </div>\n      <ul>\n        {messages.map((message, index) => (\n          <li key={index}>{message}</li>\n        ))}\n      </ul>\n    </div>\n  )\n}\n\nfunction Child2({ multiEventEmitter }: { multiEventEmitter: MultiEventEmitter<string> }) {\n  const [inputMessage, setInputMessage] = useState<string>('')\n  const [messages, setMessages] = useState<string[]>([])\n  multiEventEmitter.useSubscription('chat-to-child2', (message: string) => {\n    setMessages((prev: string[]) => [...prev, message])\n  })\n  return (\n    <div>\n      Child2\n      <div>\n        <input\n          type=\"text\"\n          style={{ width: '100%' }}\n          placeholder=\"Enter message to send to Child1\"\n          value={inputMessage}\n          onChange={e => setInputMessage(e.target.value)}\n          onKeyDown={e => {\n            if (e.key === 'Enter') {\n              multiEventEmitter.emit('chat-to-child1', `Child2: ${inputMessage}`)\n              setInputMessage('')\n            }\n          }}\n        />\n      </div>\n      <ul>\n        {messages.map((message, index) => (\n          <li key={index}>{message}</li>\n        ))}\n      </ul>\n    </div>\n  )\n}\n\nexport default function Demo() {\n  const multiEventEmitter = useMultiEventEmitter<string>()\n  return (\n    <div\n      style={{\n        display: 'grid',\n        gridTemplateColumns: '1fr 1fr',\n        gap: '20px',\n      }}\n    >\n      <Child1 multiEventEmitter={multiEventEmitter} />\n      <Child2 multiEventEmitter={multiEventEmitter} />\n    </div>\n  )\n}\n"} />


# useIsomorphicLayoutEffect



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-isomorphic-layout-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useIsomorphicLayoutEffect/index.ts" text="源码" />

## 用法

## 源码

{/* prettier-ignore */}

```ts title="useIsomorphicLayoutEffect.ts"
import { useEffect, useLayoutEffect } from 'react';
import isBrowser from '../utils/isBrowser';

const useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;

export default useIsomorphicLayoutEffect;
```

## 解读

在浏览器环境返回 `useLayoutEffect`，在非浏览器环境返回 `useEffect`。


# useLatest











<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-latest#uselatest" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLatest/index.ts" text="源码" />

## 用法

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState, useEffect } from 'react'\nimport { useLatest } from 'ahooks'\n\nexport default function UseLatestDemo() {\n  const [useLatestCount, setUseLatestCount] = useState(0)\n  const [defaultCount, setDefaultCount] = useState(0)\n\n  const latestCountRef = useLatest(useLatestCount)\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setUseLatestCount(latestCountRef.current + 1)\n    }, 1000)\n    return () => clearInterval(interval)\n  }, [])\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setDefaultCount(defaultCount + 1)\n    }, 1000)\n    return () => clearInterval(interval)\n  }, [])\n\n  return (\n    <>\n      <p>count(useLatest): {useLatestCount}</p>\n      <p>count(default): {defaultCount}</p>\n    </>\n  )\n}\n"} />

{' '}

为什么 `demo.tsx` 中为什么 `defaultCount` 没有更新？

这是一个典型的 React 闭包问题，由于 `useEffect` 在组件挂载后只会执行一次，且 `setInterval` 中的回调函数内部始终是对第一次初始化时的 `defaultCount` 进行引用，也就意味着 `setInterval` 的回调函数中获取到的 `defaultCount` 一直都是 `0`。

如果将 `setDefaultCount` 传入一个更新函数，那么就能解决这个问题。

```tsx title="demo.tsx"
import { useState, useEffect } from 'react'

export default () => {
  const [defaultCount, setDefaultCount] = useState(0)

  useEffect(() => {
    const interval = setInterval(() => {
      setDefaultCount(count => count + 1) // [!code highlight]
    }, 1000)
    return () => clearInterval(interval)
  }, [])

  return (
    <>
      <p>count(default): {defaultCount}</p>
    </>
  )
}
```

<ViewCode component={<ViewCodeActualComponent1 />} code={"'use client'\n\nimport { useState, useEffect } from 'react'\n\nexport default function Demo() {\n  const [defaultCount, setDefaultCount] = useState(0)\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setDefaultCount(count => count + 1)\n    }, 1000)\n    return () => clearInterval(interval)\n  }, [])\n\n  return (\n    <>\n      <p>count(default): {defaultCount}</p>\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useLatest.ts"
import { useRef } from 'react';

function useLatest<T>(value: T) {
  const ref = useRef(value);
  ref.current = value;

  return ref;
}

export default useLatest;
```

## 解读

使用 `useRef` 定义一个 `ref` 对象，将入参赋值给 `ref` 对象，然后返回这个 `ref` 对象。相较于 `useRef`，多了一行赋值的代码，确保每次获取的值都是最新的。

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="useLatest.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="useLatest.ts">
      useLatest.ts
    </CodeBlockTabsTrigger>

    <CodeBlockTabsTrigger value="demo.tsx">
      demo.tsx
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="useLatest.ts">
    ```ts
    import { useRef } from 'react';

    function useLatest<T>(value: T) {
      const ref = useRef(value);
      ref.current = value; // [!code highlight]

      return ref;
    }

    export default useLatest;
    ```
  </CodeBlockTab>

  <CodeBlockTab value="demo.tsx">
    ```tsx
    import { useState, useEffect, useRef } from 'react'
    import { useLatest } from 'ahooks'

    export default () => {
      const [useLatestCount, setUseLatestCount] = useState(0)
      const [defaultCount, setDefaultCount] = useState(0)

      const latestCountRef = useLatest(useLatestCount)

      useEffect(() => {
        const interval = setInterval(() => {
          setUseLatestCount(latestCountRef.current + 1)
        }, 1000)
        return () => clearInterval(interval)
      }, [])

      useEffect(() => {
        const interval = setInterval(() => {
          setDefaultCount(defaultCount + 1)
        }, 1000)
        return () => clearInterval(interval)
      }, [])

      return (
        <>
          <p>count(useLatest): {useLatestCount}</p>
          <p>count(default): {defaultCount}</p>
        </>
      )
    }
    ```
  </CodeBlockTab>
</CodeBlockTabs>

因为使用 `useRef` 定义的变量，React 会记录在当前组件内部，在组件重新渲染时，不会再被初始化，而是使用当前组件内部记录的值。

而每次重新渲染时，当前组件内部上下文中拿到的都是每个 `state` 最新的值，`useLatest` 相当于更新了一下 `useRef` 定义的值，保证当前 `ref` 对象是最新的值。

<ThemeImage light={ThemeImage_light_0.src} dark={ThemeImage_dark_1.src} alt="demo.tsx 更新流程" />


# useMemoizedFn





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-memoized-fn" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMemoizedFn/index.ts" text="源码" />

## 用法

持久化 `function` 的引用，保证函数引用保持不变，避免重复创建函数。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState, useCallback } from 'react'\nimport { useMemoizedFn } from 'ahooks'\n\nexport default function Demo() {\n  const [count, setCount] = useState(0)\n\n  const callbackFn = useCallback(() => {\n    console.log(`Current count is ${count}`)\n  }, [count])\n\n  const memoizedFn = useMemoizedFn(() => {\n    console.log(`Current count is ${count}`)\n  })\n\n  return (\n    <>\n      <p>count: {count}</p>\n      <button\n        type=\"button\"\n        onClick={() => {\n          setCount(c => c + 1)\n        }}\n      >\n        Add Count\n      </button>\n      <div style={{ marginTop: 16 }}>\n        <button type=\"button\" onClick={callbackFn}>\n          call callbackFn\n        </button>\n        <button type=\"button\" onClick={memoizedFn} style={{ marginLeft: 8 }}>\n          call memoizedFn\n        </button>\n      </div>\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useMemoizedFn.ts"
import { useMemo, useRef } from 'react';
import { isFunction } from '../utils';
import isDev from '../utils/isDev';

type noop = (this: any, ...args: any[]) => any;

type PickFunction<T extends noop> = (
  this: ThisParameterType<T>,
  ...args: Parameters<T>
) => ReturnType<T>;

const useMemoizedFn = <T extends noop>(fn: T) => {
  if (isDev) {
    if (!isFunction(fn)) {
      console.error(`useMemoizedFn expected parameter is a function, got ${typeof fn}`);
    }
  }

  const fnRef = useRef<T>(fn);

  // why not write `fnRef.current = fn`?
  // https://github.com/alibaba/hooks/issues/728
  fnRef.current = useMemo<T>(() => fn, [fn]);

  const memoizedFn = useRef<PickFunction<T>>(undefined);

  if (!memoizedFn.current) {
    memoizedFn.current = function (this, ...args) {
      return fnRef.current.apply(this, args);
    };
  }

  return memoizedFn.current;
};

export default useMemoizedFn;
```

## 解读

先是环境判断，开发模式下传入参数的类型不为 `Function` 时，输出错误日志。

{/* prettier-ignore */}

```tsx
const useMemoizedFn = <T extends noop>(fn: T) => {
  if (isDev) { // [!code focus:5]
    if (!isFunction(fn)) {
      console.error(`useMemoizedFn expected parameter is a function, got ${typeof fn}`);
    }
  }

  /* ... */
}
```

然后使用 `useRef` 定义了一个 `fnRef` 对象，用于存储传入的函数。并且当传入的 `fn` 发生变化时，更新 `fnRef` 对象的值。

<Callout>
  关于为什么使用 `useMemo` 包裹，可以查看对应
  issue：[#728](https://github.com/alibaba/hooks/issues/728)。
</Callout>

{/* prettier-ignore */}

```tsx
const useMemoizedFn = <T extends noop>(fn: T) => {
  /* ... */

  const fnRef = useRef<T>(fn); // [!code focus:5]

  // why not write `fnRef.current = fn`?
  // https://github.com/alibaba/hooks/issues/728
  fnRef.current = useMemo<T>(() => fn, [fn]);
}
```

接着使用 `useRef` 定义了一个 `memoizedFn` 对象，初始值为 `undefined`，用来记录新函数。

首次执行时，会更新 `memoizedFn` 对象的值，赋值一个新函数，新函数内部会修改 `this` 指向后直接调用 `fnRef` 对象的值，并返回函数的执行结果。

首次更新 `memoizedFn` 对象的值后，后续便不再更新，这也是 `useMemoizedFn` 为什么能保证函数引用保持不变的原因。

最后返回 `memoizedFn` 对象中记录的这个新函数。

{/* prettier-ignore */}

```tsx
const useMemoizedFn = <T extends noop>(fn: T) => {
  /* ... */

  const memoizedFn = useRef<PickFunction<T>>(undefined); // [!code focus:9]

  if (!memoizedFn.current) {
    memoizedFn.current = function (this, ...args) {
      return fnRef.current.apply(this, args);
    };
  }

  return memoizedFn.current;
}
```

综上，简单来说，`useMemoizedFn` 就是在内部创建了一个新函数，新函数内部执行传入的函数 `fn`，将 `fn` 的执行结果作为新函数的返回值，最后返回这个新函数，来保证函数的引用一直不变。通过 `useRef` 和 `useMemo` 来保证新函数内部执行的 `fn` 函数始终是最新的 `fn` 。


# useReactive





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-reactive" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useReactive/index.ts" text="源码" />

## 用法

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useReactive } from 'ahooks'\n\nexport default function Demo() {\n  const state = useReactive({\n    count: 0,\n    inputVal: '',\n    obj: {\n      value: '',\n    },\n  })\n\n  return (\n    <div>\n      <p> state.count：{state.count}</p>\n\n      <button style={{ marginRight: 8 }} onClick={() => state.count++}>\n        state.count++\n      </button>\n      <button onClick={() => state.count--}>state.count--</button>\n\n      <p style={{ marginTop: 20 }}> state.inputVal: {state.inputVal}</p>\n      <input onChange={e => (state.inputVal = e.target.value)} />\n\n      <p style={{ marginTop: 20 }}> state.obj.value: {state.obj.value}</p>\n      <input onChange={e => (state.obj.value = e.target.value)} />\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useReactive.ts"
import { useRef } from 'react';
import isPlainObject from 'lodash/isPlainObject';
import useCreation from '../useCreation';
import useUpdate from '../useUpdate';

// k:v 原对象:代理过的对象
const proxyMap = new WeakMap();
// k:v 代理过的对象:原对象
const rawMap = new WeakMap();

function observer<T extends Record<string, any>>(initialVal: T, cb: () => void): T {
  const existingProxy = proxyMap.get(initialVal);

  // 添加缓存 防止重新构建proxy
  if (existingProxy) {
    return existingProxy;
  }

  // 防止代理已经代理过的对象
  // https://github.com/alibaba/hooks/issues/839
  if (rawMap.has(initialVal)) {
    return initialVal;
  }

  const proxy = new Proxy<T>(initialVal, {
    get(target, key, receiver) {
      const res = Reflect.get(target, key, receiver);

      // https://github.com/alibaba/hooks/issues/1317
      const descriptor = Reflect.getOwnPropertyDescriptor(target, key);
      if (!descriptor?.configurable && !descriptor?.writable) {
        return res;
      }

      // Only proxy plain object or array,
      // otherwise it will cause: https://github.com/alibaba/hooks/issues/2080
      return isPlainObject(res) || Array.isArray(res) ? observer(res, cb) : res;
    },
    set(target, key, val) {
      const ret = Reflect.set(target, key, val);
      cb();
      return ret;
    },
    deleteProperty(target, key) {
      const ret = Reflect.deleteProperty(target, key);
      cb();
      return ret;
    },
  });

  proxyMap.set(initialVal, proxy);
  rawMap.set(proxy, initialVal);

  return proxy;
}

function useReactive<S extends Record<string, any>>(initialState: S): S {
  const update = useUpdate();
  const stateRef = useRef<S>(initialState);

  const state = useCreation(() => {
    return observer(stateRef.current, () => {
      update();
    });
  }, []);

  return state;
}

export default useReactive;
```

## 解读

<Callout>
  关于
  `useCreation`、`useUpdate`，可以查看对应文档：[useCreation](../../advanced/use-creation/)、[useUpdate](../../effect/use-update/)。
</Callout>

先看 `observer` 函数，用于深度代理一个对象。

{/* prettier-ignore */}

```ts
// k:v 原对象:代理过的对象
const proxyMap = new WeakMap();
// k:v 代理过的对象:原对象
const rawMap = new WeakMap();

function observer<T extends Record<string, any>>(initialVal: T, cb: () => void): T {
  // 1. 在 proxyMap 中查找当前对象是否已经代理过
  const existingProxy = proxyMap.get(initialVal);

  // 添加缓存 防止重新构建proxy
  // 2. 如果已经代理过，则直接返回代理过的对象
  if (existingProxy) {
    return existingProxy;
  }

  // 防止代理已经代理过的对象
  // https://github.com/alibaba/hooks/issues/839
  // 3. 如果当前对象是个已经代理过的对象，则直接返回该对象
  if (rawMap.has(initialVal)) {
    return initialVal;
  }

  // 4. 构建代理对象
  const proxy = new Proxy<T>(initialVal, {
    get(target, key, receiver) {
      // 4.1. 通过 Reflect.get 获取当前对象的属性值，可确保 this 指向的正确性
      const res = Reflect.get(target, key, receiver);

      // https://github.com/alibaba/hooks/issues/1317
      // 4.2. 获取当前对象的属性描述符，如果属性描述符不可配置且不可写，则直接返回该属性
      const descriptor = Reflect.getOwnPropertyDescriptor(target, key);
      if (!descriptor?.configurable && !descriptor?.writable) {
        return res;
      }

      // Only proxy plain object or array,
      // otherwise it will cause: https://github.com/alibaba/hooks/issues/2080
      // 4.3. 如果当前对象是普通对象或数组，则递归代理该对象
      return isPlainObject(res) || Array.isArray(res) ? observer(res, cb) : res;
    },
    set(target, key, val) {
      // 4.4. 通过 Reflect.set 设置当前对象的属性值，并触发回调
      const ret = Reflect.set(target, key, val);
      cb();
      return ret;
    },
    deleteProperty(target, key) {
      // 4.5. 通过 Reflect.deleteProperty 删除当前对象的属性，并触发回调
      const ret = Reflect.deleteProperty(target, key);
      cb();
      return ret;
    },
  });

  // 5. 将原对象和代理对象分别缓存到 proxyMap 和 rawMap 中
  proxyMap.set(initialVal, proxy);
  rawMap.set(proxy, initialVal);

  // 6. 返回代理对象
  return proxy;
}
```

再来看看 `useReactive` 函数的实现。

{/* prettier-ignore */}

```ts
function useReactive<S extends Record<string, any>>(initialState: S): S {
  // 1. 使用 useUpdate 获取更新函数，调用 update 会触发组件重新渲染
  const update = useUpdate();
  // 2. 使用 useRef 创建一个 ref 对象，用于存储初始状态
  const stateRef = useRef<S>(initialState);

  // 3. 使用 useCreation 创建一个响应式对象
  const state = useCreation(() => {
    // 3.1. 调用 observer 函数，深度代理初始状态
    return observer(stateRef.current, () => {
      // 3.2. 当对象的属性发生变化时，触发 update 函数，从而触发组件重新渲染
      update();
    });
  }, []);

  // 4. 返回响应式对象
  return state;
}
```


# useTrackedEffect



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-tracked-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useTrackedEffect/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useWhyDidYouUpdate



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-why-did-you-update" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useWhyDidYouUpdate/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useClickAway



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-click-away" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useClickAway/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useDocumentVisibility



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-document-visibility" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDocumentVisibility/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useDrag



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-drag" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDrag/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useDrop



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-drop" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDrop/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useEventListener





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-event-listener#useeventlistener" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useEventListener/index.ts" text="源码" />

## 用法

监听事件。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState, useRef } from 'react'\nimport { useEventListener } from 'ahooks'\n\nexport default function UseEventListenerDemo() {\n  const [value, setValue] = useState(0)\n  const ref = useRef(null)\n\n  useEventListener(\n    'click',\n    () => {\n      setValue(value + 1)\n    },\n    { target: ref },\n  )\n\n  return (\n    <button ref={ref} type=\"button\">\n      You click {value} times\n    </button>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useEventListener.ts"
import useLatest from '../useLatest';
import type { BasicTarget } from '../utils/domTarget';
import { getTargetElement } from '../utils/domTarget';
import useEffectWithTarget from '../utils/useEffectWithTarget';

type noop = (...p: any) => void;

export type Target = BasicTarget<HTMLElement | Element | Window | Document>;

type Options<T extends Target = Target> = {
  target?: T;
  capture?: boolean;
  once?: boolean;
  passive?: boolean;
  enable?: boolean;
};

function useEventListener<K extends keyof HTMLElementEventMap>(
  eventName: K,
  handler: (ev: HTMLElementEventMap[K]) => void,
  options?: Options<HTMLElement>,
): void;
function useEventListener<K extends keyof ElementEventMap>(
  eventName: K,
  handler: (ev: ElementEventMap[K]) => void,
  options?: Options<Element>,
): void;
function useEventListener<K extends keyof DocumentEventMap>(
  eventName: K,
  handler: (ev: DocumentEventMap[K]) => void,
  options?: Options<Document>,
): void;
function useEventListener<K extends keyof WindowEventMap>(
  eventName: K,
  handler: (ev: WindowEventMap[K]) => void,
  options?: Options<Window>,
): void;
function useEventListener(
  eventName: string | string[],
  handler: (event: Event) => void,
  options?: Options<Window>,
): void;
function useEventListener(eventName: string | string[], handler: noop, options: Options): void;

function useEventListener(eventName: string | string[], handler: noop, options: Options = {}) {
  const { enable = true } = options;

  const handlerRef = useLatest(handler);

  useEffectWithTarget(
    () => {
      if (!enable) {
        return;
      }

      const targetElement = getTargetElement(options.target, window);
      if (!targetElement?.addEventListener) {
        return;
      }

      const eventListener = (event: Event) => {
        return handlerRef.current(event);
      };

      const eventNameArray = Array.isArray(eventName) ? eventName : [eventName];

      eventNameArray.forEach((event) => {
        targetElement.addEventListener(event, eventListener, {
          capture: options.capture,
          once: options.once,
          passive: options.passive,
        });
      });

      return () => {
        eventNameArray.forEach((event) => {
          targetElement.removeEventListener(event, eventListener, {
            capture: options.capture,
          });
        });
      };
    },
    [eventName, options.capture, options.once, options.passive, enable],
    options.target,
  );
}

export default useEventListener;
```

## 解读

*TODO*


# useEventTarget



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-event-target" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useEventTarget/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useExternal



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-external" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useExternal/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useFavicon



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-favicon" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useFavicon/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useFocusWithin



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-focus-within" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useFocusWithin/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useFullscreen



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-fullscreen" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useFullscreen/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useHover





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-hover#usehover" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useHover/index.ts" text="源码" />

## 用法

监听元素的悬停状态。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useRef } from 'react'\nimport { useHover } from 'ahooks'\n\nexport default function Demo() {\n  const ref = useRef(null)\n  const isHovering = useHover(ref)\n  return <div ref={ref}>{isHovering ? 'hover' : 'leaveHover'}</div>\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useHover.ts"
import useBoolean from '../useBoolean';
import useEventListener from '../useEventListener';
import type { BasicTarget } from '../utils/domTarget';

export interface Options {
  onEnter?: () => void;
  onLeave?: () => void;
  onChange?: (isHovering: boolean) => void;
}

export default (target: BasicTarget, options?: Options): boolean => {
  const { onEnter, onLeave, onChange } = options || {};

  const [state, { setTrue, setFalse }] = useBoolean(false);

  useEventListener(
    'mouseenter',
    () => {
      onEnter?.();
      setTrue();
      onChange?.(true);
    },
    {
      target,
    },
  );

  useEventListener(
    'mouseleave',
    () => {
      onLeave?.();
      setFalse();
      onChange?.(false);
    },
    {
      target,
    },
  );

  return state;
};
```

## 解读

*TODO*


# useInViewport



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-in-viewport" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useInViewport/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useKeyPress



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-key-press" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useKeyPress/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useLongPress



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-long-press" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLongPress/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useMouse



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-mouse" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMouse/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useMutationObserver



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-mutation-observer" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMutationObserver/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useResponsive



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-responsive" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useResponsive/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useScroll





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-scroll#usescroll" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useScroll/index.ts" text="源码" />

## 用法

监听元素的滚动事件。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useRef } from 'react'\nimport { useScroll } from 'ahooks'\n\nexport default function Demo() {\n  const ref = useRef(null)\n  const scroll = useScroll(ref)\n  return (\n    <>\n      <p>{JSON.stringify(scroll)}</p>\n      <div\n        style={{\n          height: '160px',\n          width: '160px',\n          border: 'solid 1px #000',\n          overflow: 'scroll',\n          whiteSpace: 'nowrap',\n          fontSize: '32px',\n        }}\n        ref={ref}\n      >\n        <div>\n          Lorem ipsum dolor sit amet, consectetur adipisicing elit. A aspernatur atque, debitis ex\n          excepturi explicabo iste iure labore molestiae neque optio perspiciatis\n        </div>\n        <div>\n          Aspernatur cupiditate, deleniti id incidunt mollitia omnis! A aspernatur assumenda\n          consequuntur culpa cumque dignissimos enim eos, et fugit natus nemo nesciunt\n        </div>\n        <div>\n          Alias aut deserunt expedita, inventore maiores minima officia porro rem. Accusamus ducimus\n          magni modi mollitia nihil nisi provident\n        </div>\n        <div>\n          Alias aut autem consequuntur doloremque esse facilis id molestiae neque officia placeat,\n          quia quisquam repellendus reprehenderit.\n        </div>\n        <div>\n          Adipisci blanditiis facere nam perspiciatis sit soluta ullam! Architecto aut blanditiis,\n          consectetur corporis cum deserunt distinctio dolore eius est exercitationem\n        </div>\n        <div>Ab aliquid asperiores assumenda corporis cumque dolorum expedita</div>\n        <div>\n          Culpa cumque eveniet natus totam! Adipisci, animi at commodi delectus distinctio dolore\n          earum, eum expedita facilis\n        </div>\n        <div>\n          Quod sit, temporibus! Amet animi fugit officiis perspiciatis, quis unde. Cumque\n          dignissimos distinctio, dolor eaque est fugit nisi non pariatur porro possimus, quas quasi\n        </div>\n      </div>\n    </>\n  )\n}\n"} />

## 源码

```ts title="useScroll.ts"
import { useEffect, useRef } from 'react'

const useScroll = () => {
  const ref = useRef(null)
  useEffect(() => {
    const handleScroll = () => {
      console.log('scroll')
    }
    ref.current.addEventListener('scroll', handleScroll)
    return () => {
      ref.current.removeEventListener('scroll', handleScroll)
    }
  }, [])
  return ref
}

export default useScroll
```

## 解读

*TODO*


# useSize



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-size" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useSize/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useTitle



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-title" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useTitle/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useMount





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-mount#usemount" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMount/index.ts" text="源码" />

## 用法

组件挂载时执行。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport React from 'react'\nimport { useMount, useBoolean } from 'ahooks'\n\nconst MyComponent = () => {\n  useMount(() => {\n    console.log('mount')\n  })\n\n  return <div>Hello World</div>\n}\n\nexport default function Demo() {\n  const [state, { toggle }] = useBoolean(false)\n\n  return (\n    <>\n      <button type=\"button\" onClick={toggle}>\n        {state ? 'unmount' : 'mount'}\n      </button>\n      {state && <MyComponent />}\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useMount.ts"
import { useEffect } from 'react';
import { type EffectCallback } from 'react';
import { isFunction } from '../utils';
import isDev from '../utils/isDev';

const useMount = (fn: EffectCallback) => {
  if (isDev) {
    if (!isFunction(fn)) {
      console.error(
        `useMount: parameter \`fn\` expected to be a function, but got "${typeof fn}".`
      );
    }
  }

  useEffect(() => {
    return fn?.();
  }, []);
};

export default useMount;
```

## 解读

先是环境判断，开发模式下传入参数的类型不为 `Function` 时，输出错误日志。

然后，主要逻辑就是上面高亮的 `15-17` 行，用 `useEffect` 包了一层，然后再将入参函数的执行结果返回。


# useUnmount





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-unmount#useunmount" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useUnmount/index.ts" text="源码" />

## 用法

组件卸载时执行。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useUnmount, useBoolean } from 'ahooks'\n\nconst MyComponent = () => {\n  useUnmount(() => {\n    console.log('mount')\n  })\n\n  return <div>Hello World</div>\n}\n\nexport default function Demo() {\n  const [state, { toggle }] = useBoolean(false)\n\n  return (\n    <>\n      <button type=\"button\" onClick={toggle}>\n        {state ? 'unmount' : 'mount'}\n      </button>\n      {state && <MyComponent />}\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useUnMount.ts"
import { useEffect } from 'react';
import useLatest from '../useLatest';
import { isFunction } from '../utils';
import isDev from '../utils/isDev';

const useUnmount = (fn: () => void) => {
  if (isDev) {
    if (!isFunction(fn)) {
      console.error(`useUnmount expected parameter is a function, got ${typeof fn}`);
    }
  }

  const fnRef = useLatest(fn);

  useEffect(
    () => () => {
      fnRef.current();
    },
    [],
  );
};

export default useUnmount;
```

<Callout>
  关于 `useLatest`，可以查看对应文档：[useLatest](../../advanced/use-latest/)，用来返回最新的值。
</Callout>

## 解读

先是环境判断，开发模式下传入参数的类型不为 `Function` 时，输出错误日志。

然后，主要逻辑就是上面高亮的 `15-17` 行，用 `useEffect` 包了一层，然后再将入参函数的执行结果返回。


# useUnmountedRef





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-unmounted-ref#useunmountedref" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useUnmountedRef/index.tsx" text="源码" />

## 用法

当前组件是否已经卸载。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useEffect, useState } from 'react'\nimport { useUnmountedRef } from 'ahooks'\n\nconst MyComponent = () => {\n  const unmountedRef = useUnmountedRef()\n  useEffect(() => {\n    setTimeout(() => {\n      if (!unmountedRef.current) {\n        console.log('component is alive')\n      } else {\n        console.log('component is unmounted')\n      }\n    }, 3000)\n  }, [])\n\n  return <p>Hello World!</p>\n}\n\nexport default function Demo() {\n  const [state, setState] = useState(true)\n\n  return (\n    <>\n      <button type=\"button\" onClick={() => setState(!state)}>\n        {state ? 'unmount' : 'mount'}\n      </button>\n      {state && <MyComponent />}\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```tsx title="useUnmountedRef.tsx"
import { useEffect, useRef } from 'react';

const useUnmountedRef = () => {
  const unmountedRef = useRef(false);
  useEffect(() => {
    unmountedRef.current = false;
    return () => {
      unmountedRef.current = true;
    };
  }, []);
  return unmountedRef;
};

export default useUnmountedRef;
```

## 解读

使用 `useRef` 记录当前组件的卸载状态，初始值为 `false`，挂载时赋值为 `false`，卸载时赋值为 `true`，最后返回当前 `ref` 对象，用于判断组件是否已经卸载。


# useAsyncEffect



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-async-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useAsyncEffect/index.ts" text="源码" />

## 用法

## 源码

## 解读


# useDebounceEffect



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-debounce-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDebounceEffect/index.ts" text="源码" />

## 用法

{/* prettier-ignore */}

```ts title="useDebounceEffect.ts"
import { useEffect, useState } from 'react';
import type { DependencyList, EffectCallback } from 'react';
import type { DebounceOptions } from '../useDebounce/debounceOptions';
import useDebounceFn from '../useDebounceFn';
import useUpdateEffect from '../useUpdateEffect';

function useDebounceEffect(
  effect: EffectCallback,
  deps?: DependencyList,
  options?: DebounceOptions,
) {
  const [flag, setFlag] = useState({});

  const { run } = useDebounceFn(() => {
    setFlag({});
  }, options);

  useEffect(() => {
    return run();
  }, deps);

  useUpdateEffect(effect, [flag]);
}

export default useDebounceEffect;
```

## 解读

<Callout>
  关于
  `useDebounceFn`、`useUpdateEffect`，可以查看对应文档：[useDebounceFn](../../effect/use-debounce-fn/)、[useUpdateEffect](../../effect/use-update-effect/)。
</Callout>

{/* prettier-ignore */}

```ts
function useDebounceEffect(
  effect: EffectCallback,
  deps?: DependencyList,
  options?: DebounceOptions,
) {
  // 1. 首先，使用 useState 定义了一个 flag 状态，用于记录依赖是否更新。
  const [flag, setFlag] = useState({});

  // 2. 然后，使用 useDebounceFn 来处理防抖值。
  const { run } = useDebounceFn(() => {
    setFlag({});
  }, options);

  // 3. 接着，使用 useEffect 来监听依赖的更新，并调用 run 函数来更新防抖值。
  useEffect(() => {
    return run();
  }, deps);

  // 4. 最后，使用 useUpdateEffect 来监听 flag 的变化，并执行 effect。
  useUpdateEffect(effect, [flag]);
}
```

执行流程：`deps` 更新 -> 执行 `run` 函数 -> `flag` 更新 -> 执行 `effect`。

由于 `useUpdateEffect` 会忽略首次执行，如果需要首次执行，可以通过 `useDebounceFn` 的 `options` 参数来设置。

```ts
const { run } = useDebounceFn(
  () => {
    setFlag({})
  },
  {
    wait: 1000,
    // 设置为 true，表示在延迟开始前调用
    leading: true, // [!code highlight]
  },
)
```


# useDebounceFn







<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-debounce-fn" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDebounceFn/index.ts" text="源码" />

## 用法

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useDebounceFn } from 'ahooks'\nimport { useState } from 'react'\n\nexport default function Demo() {\n  const [value, setValue] = useState(0)\n  const { run } = useDebounceFn(\n    () => {\n      setValue(value + 1)\n    },\n    {\n      wait: 500,\n    },\n  )\n\n  return (\n    <div>\n      <p style={{ marginTop: 16 }}> Clicked count: {value} </p>\n      <button type=\"button\" onClick={run}>\n        Click fast!\n      </button>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useDebounceFn.ts"
import { debounce } from '../utils/lodash-polyfill';
import { useMemo } from 'react';
import type { DebounceOptions } from '../useDebounce/debounceOptions';
import useLatest from '../useLatest';
import useUnmount from '../useUnmount';
import { isFunction } from '../utils';
import isDev from '../utils/isDev';

type noop = (...args: any[]) => any;

function useDebounceFn<T extends noop>(fn: T, options?: DebounceOptions) {
  if (isDev) {
    if (!isFunction(fn)) {
      console.error(`useDebounceFn expected parameter is a function, got ${typeof fn}`);
    }
  }

  const fnRef = useLatest(fn);

  const wait = options?.wait ?? 1000;

  const debounced = useMemo(
    () =>
      debounce(
        (...args: Parameters<T>): ReturnType<T> => {
          return fnRef.current(...args);
        },
        wait,
        options,
      ),
    [],
  );

  useUnmount(() => {
    debounced.cancel();
  });

  return {
    run: debounced,
    cancel: debounced.cancel,
    flush: debounced.flush,
  };
}

export default useDebounceFn;
```

## 解读

<Callout>
  关于
  `useLatest`、`useUnmount`，可以查看对应文档：[useLatest](../../advanced/use-latest/)、[useUnmount](../../life-cycle/use-unmount/)。
</Callout>

{/* prettier-ignore */}

```ts
function useDebounceFn<T extends noop>(fn: T, options?: DebounceOptions) {
  // 1. 首先，使用 useLatest 来记录函数的最新值。
  const fnRef = useLatest(fn);

  // 2. 然后，使用 options 中的 wait 属性来设置防抖时间，默认值为 1000ms。
  const wait = options?.wait ?? 1000;

  // 3. 接着，使用 useMemo 来缓存防抖后的函数。防抖后的函数内部会调用 fnRef 对象的值，并返回函数的执行结果。
  const debounced = useMemo(
    () =>
      // 使用 lodash 的 debounce 函数实现防抖函数，参数配置也完全与 lodash 的 debounce 函数一致。
      debounce(
        (...args: Parameters<T>): ReturnType<T> => {
          return fnRef.current(...args);
        },
        wait,
        options,
      ),
    [],
  );

  // 4. 然后，使用 useUnmount 来卸载防抖后的函数。
  useUnmount(() => {
    debounced.cancel();
  });

  // 5. 最后，返回防抖后的函数，包括 run、cancel、flush 三个方法。
  return {
    run: debounced,
    cancel: debounced.cancel,
    flush: debounced.flush,
  };
}
```

本质上就是利用 `debounce` 来延时更新 `state` 的值，完全可以利用 `setTimeout` 来实现一个简易的版本。

<ViewCode component={<ViewCodeActualComponent1 />} code={"'use client'\n\nimport { useState, useEffect } from 'react'\n\nfunction useDebounce<T>(value: T, options?: { wait: number }) {\n  const wait = options?.wait ?? 1000\n  const [debouncedValue, setDebouncedValue] = useState(value)\n  let timer: NodeJS.Timeout\n  useEffect(() => {\n    if (timer) {\n      clearTimeout(timer)\n    }\n    timer = setTimeout(() => {\n      setDebouncedValue(value)\n    }, wait)\n    return () => {\n      if (timer) {\n        clearTimeout(timer)\n      }\n    }\n  }, [value, wait])\n  return debouncedValue\n}\n\nexport default function Demo() {\n  const [value, setValue] = useState<string>()\n  const debouncedValue = useDebounce(value, { wait: 500 })\n\n  return (\n    <div>\n      <input\n        value={value}\n        onChange={e => setValue(e.target.value)}\n        placeholder=\"Typed value\"\n        style={{ width: 280 }}\n      />\n      <p style={{ marginTop: 16 }}>Value: {value}</p>\n      <p style={{ marginTop: 16 }}>DebouncedValue（延时 500ms 后更新）: {debouncedValue}</p>\n    </div>\n  )\n}\n"} />


# useDeepCompareEffect









<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-deep-compare-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDeepCompareEffect/index.tsx" text="源码" />

## 用法

用法与 `useEffect` 一致，不同的是，会深度比较依赖。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useEffect, useState, useRef } from 'react'\nimport { useDeepCompareEffect } from 'ahooks'\n\nexport default function Demo() {\n  const [count, setCount] = useState(0)\n  const effectCountRef = useRef(0)\n  const deepCompareCountRef = useRef(0)\n\n  useEffect(() => {\n    effectCountRef.current += 1\n  }, [{}])\n\n  useDeepCompareEffect(() => {\n    deepCompareCountRef.current += 1\n    return () => {\n      // do something\n    }\n  }, [{}])\n\n  return (\n    <div>\n      <p>effectCount: {effectCountRef.current}</p>\n      <p>deepCompareCount: {deepCompareCountRef.current}</p>\n      <p>\n        <button type=\"button\" onClick={() => setCount(c => c + 1)}>\n          reRender\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="useDeepCompareEffect.tsx">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="useDeepCompareEffect.tsx">
      useDeepCompareEffect.tsx
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="useDeepCompareEffect.tsx">
    ```tsx
    import { useEffect } from 'react';
    import { createDeepCompareEffect } from '../createDeepCompareEffect';

    export default createDeepCompareEffect(useEffect);
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="createDeepCompareEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="createDeepCompareEffect.ts">
      createDeepCompareEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="createDeepCompareEffect.ts">
    ```ts
    import { useRef } from 'react';
    import type { DependencyList, useEffect, useLayoutEffect } from 'react';
    import { depsEqual } from '../utils/depsEqual';

    type EffectHookType = typeof useEffect | typeof useLayoutEffect;

    type CreateUpdateEffect = (hook: EffectHookType) => EffectHookType;

    export const createDeepCompareEffect: CreateUpdateEffect = (hook) => (effect, deps) => {
      const ref = useRef<DependencyList>(undefined);
      const signalRef = useRef<number>(0);
      if (deps === undefined || !depsEqual(deps, ref.current)) {
        signalRef.current += 1;
      }
      ref.current = deps;
      hook(effect, [signalRef.current]);
    };
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="depsEqual.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="depsEqual.ts">
      depsEqual.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="depsEqual.ts">
    ```ts
    import type { DependencyList } from 'react';
    import isEqual from 'react-fast-compare';

    export const depsEqual = (aDeps: DependencyList = [], bDeps: DependencyList = []) =>
      isEqual(aDeps, bDeps);
    ```
  </CodeBlockTab>
</CodeBlockTabs>

## 解读

首先调用 `createDeepCompareEffect` 函数，传入 `useEffect` 函数。

`createDeepCompareEffect` 执行后返回一个新函数。源码的写法有些简略，因为直接通过箭头函数返回一个新函数，所以就直接省略了 `return` 和 `{}`。

实际等同于下面的写法：

{/* prettier-ignore */}

```ts
export const createDeepCompareEffect: CreateUpdateEffect = (hook) => {
  return (effect, deps) => {
    const ref = useRef<DependencyList>(undefined);
    const signalRef = useRef<number>(0);
    if (deps === undefined || !depsEqual(deps, ref.current)) {
      signalRef.current += 1;
    }
    ref.current = deps;
    hook(effect, [signalRef.current]);
  }
};
```

在解读 `createDeepCompareEffect` 函数之前，先来思考一个问题：如何实现一个可以自定义比较 `deps` 的 `useEffect` 的 `hook`？

首先肯定还是要在 `useEffect` 的基础上实现这个 `hook`。而由于 `useEffect` 只接受两个参数，第一个参数 `effect` 是回调函数，第二个参数 `deps` 是依赖数组。`effect` 肯定是不能变的，那就只能变 `deps` 了。那么可以将自定义比较的结果通过 `deps` 直接传给 `useEffect`，如果比较的结果为 `false` 时，那就触发 `effect`。

所以需要一个参数用来传给 `useEffect`，并且当比较结果为 `false` 时，这个参数能与上次的值不同。

那么简单点就是将这个参数设置为自增的，每当比较结果为 `false` 时，就自增 `1`。同时用 `useRef` 记录每次比较的结果。

而每次传入的 `deps` 同样也需要用 `useRef` 记录，用于每次比较时，判断 `deps` 是否发生变化。

所以，最后实现的代码如下：

{/* prettier-ignore */}

```ts
import { useEffect, useRef } from 'react';

export const useCustomCompareEffect = (effect, deps, isEqual = Object.is) => {
  const depsRef = useRef(undefined);
  const signalRef = useRef(0);
  if (deps === undefined || !isEqual(deps, depsRef.current)) {
    signalRef.current += 1;
  }
  depsRef.current = deps;
  useEffect(effect, [signalRef.current]);
};
```

`useCustomCompareEffect` 函数接收三个参数：`effect` 是回调函数，`deps` 是依赖数组，`isEqual` 是自定义比较函数。

如果 `isEqual` 未传入，则默认使用 `Object.is` 进行比较。并且当前的执行逻辑与 `useEffect` 一致。

函数内部将 `depsRef` 的初始值设置为 `undefined`，因为 `useEffect` 的 `deps` 是可选的。如果未传入，则需要每次渲染时都触发 `effect`。

再将 `signalRef` 的初始值设置为 `0`，用于后续自增。

接着判断 `deps` 是否为 `undefined`，或者是否与上次记录的 `deps` 不一致，如果不一致，则自增 `signalRef`。

然后更新 `depsRef` 的值为当前最新的 `deps`。

最后将 `signalRef` 的值作为 `deps` 传给 `useEffect`，用于触发 `effect`。

小测一下～

<ViewCode component={<ViewCodeActualComponent1 />} code={"'use client'\n\nimport { useEffect, useState, useRef } from 'react'\n\nexport const useCustomCompareEffect = (effect, deps, isEqual = Object.is) => {\n  const depsRef = useRef(undefined)\n  const signalRef = useRef(0)\n  if (deps === undefined || !isEqual(deps, depsRef.current)) {\n    signalRef.current += 1\n  }\n  depsRef.current = deps\n  useEffect(effect, [signalRef.current])\n}\n\nexport default function Demo() {\n  const [count, setCount] = useState(0)\n  const effectCountRef = useRef(0)\n  const customCompareCountRef = useRef(0)\n\n  useEffect(() => {\n    effectCountRef.current += 1\n  }, [{}])\n\n  useCustomCompareEffect(\n    () => {\n      customCompareCountRef.current += 1\n    },\n    [customCompareCountRef.current],\n    // 当大于等于 5 时，不再触发 effect\n    (newDeps, oldDeps) => {\n      return newDeps[0] >= 5\n    },\n  )\n\n  return (\n    <div>\n      <p>effectCount: {effectCountRef.current}</p>\n      <p>customCompareCount: {customCompareCountRef.current}</p>\n      <p>\n        <button type=\"button\" onClick={() => setCount(c => c + 1)}>\n          reRender\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

了解了 `useCustomCompareEffect` 的实现后，这时候再看 `createDeepCompareEffect` 的实现，一切都豁然开朗了。

无非就是在 `createDeepCompareEffect` 内部默认用 `react-fast-compare` 的 `isEqual` 来比较 `deps` 是否发生变化。其余部分与 `useCustomCompareEffect` 一致。

{/* prettier-ignore */}

```ts
export const createDeepCompareEffect: CreateUpdateEffect = (hook) => {
  return (effect, deps) => {
    const ref = useRef<DependencyList>(undefined);
    const signalRef = useRef<number>(0);
    if (deps === undefined || !depsEqual(deps, ref.current)) { // [!code highlight]
      signalRef.current += 1;
    }
    ref.current = deps;
    hook(effect, [signalRef.current]);
  }
};
```

关于 `react-fast-compare` 的性能，与其他常用库对比了一下：

<img alt="benchmark" src={__img0} placeholder="blur" />

在对比原始值时，`react-fast-compare` 的性能居末，但对比对象、数组时，性能位居前二。尤其是对象的比对，测了好几轮，一直是第一。可见其在 `React` 中用来对比 `deps`，还是很能打的。


# useDeepCompareLayoutEffect





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-deep-compare-layout-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDeepCompareLayoutEffect/index.tsx" text="源码" />

## 用法

用法与 `useLayoutEffect` 一致，不同的是，会深度比较依赖。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useLayoutEffect, useState, useRef } from 'react'\nimport { useDeepCompareLayoutEffect } from 'ahooks'\n\nexport default function Demo() {\n  const [, setCount] = useState(0)\n  const effectCountRef = useRef(0)\n  const deepCompareCountRef = useRef(0)\n\n  useLayoutEffect(() => {\n    effectCountRef.current += 1\n  }, [{}])\n\n  useDeepCompareLayoutEffect(() => {\n    deepCompareCountRef.current += 1\n    return () => {\n      // do something\n    }\n  }, [{}])\n\n  return (\n    <div>\n      <p>effectCount: {effectCountRef.current}</p>\n      <p>deepCompareCount: {deepCompareCountRef.current}</p>\n      <p>\n        <button type=\"button\" onClick={() => setCount(c => c + 1)}>\n          reRender\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="useDeepCompareLayoutEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="useDeepCompareLayoutEffect.ts">
      useDeepCompareLayoutEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="useDeepCompareLayoutEffect.ts">
    ```ts
    import { useLayoutEffect } from 'react';
    import { createDeepCompareEffect } from '../createDeepCompareEffect';

    export default createDeepCompareEffect(useLayoutEffect);
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="createDeepCompareEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="createDeepCompareEffect.ts">
      createDeepCompareEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="createDeepCompareEffect.ts">
    ```ts
    import { useRef } from 'react';
    import type { DependencyList, useEffect, useLayoutEffect } from 'react';
    import { depsEqual } from '../utils/depsEqual';

    type EffectHookType = typeof useEffect | typeof useLayoutEffect;

    type CreateUpdateEffect = (hook: EffectHookType) => EffectHookType;

    export const createDeepCompareEffect: CreateUpdateEffect = (hook) => (effect, deps) => {
      const ref = useRef<DependencyList>(undefined);
      const signalRef = useRef<number>(0);
      if (deps === undefined || !depsEqual(deps, ref.current)) {
        signalRef.current += 1;
      }
      ref.current = deps;
      hook(effect, [signalRef.current]);
    };
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="depsEqual.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="depsEqual.ts">
      depsEqual.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="depsEqual.ts">
    ```ts
    import type { DependencyList } from 'react';
    import isEqual from 'react-fast-compare';

    export const depsEqual = (aDeps: DependencyList = [], bDeps: DependencyList = []) =>
      isEqual(aDeps, bDeps);
    ```
  </CodeBlockTab>
</CodeBlockTabs>

## 解读

关于 `createDeepCompareEffect` 的解读，可以查看对应文档：[useDeepCompareEffect](../../effect/use-deep-compare-effect/#解读)。


# useInterval



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-interval" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useInterval/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useLockFn



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-lock-fn" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLockFn/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useRafInterval



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-raf-interval" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRafInterval/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useRafTimeout



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-raf-timeout" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRafTimeout/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useThrottleEffect





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-throttle-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useThrottleEffect/index.ts" text="源码" />

## 用法

用来处理节流副作用的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState } from 'react'\nimport { useThrottleEffect } from 'ahooks'\n\nexport default function Demo() {\n  const [value, setValue] = useState('hello')\n  const [records, setRecords] = useState<string[]>([])\n  useThrottleEffect(\n    () => {\n      setRecords(val => [...val, value])\n    },\n    [value],\n    {\n      wait: 1000,\n    },\n  )\n  return (\n    <div>\n      <input\n        value={value}\n        onChange={e => setValue(e.target.value)}\n        placeholder=\"Typed value\"\n        style={{ width: 280 }}\n      />\n      <p style={{ marginTop: 16 }}>\n        <ul>\n          {records.map((record, index) => (\n            <li key={index}>{record}</li>\n          ))}\n        </ul>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useThrottleEffect.ts"
import { useEffect, useState } from 'react';
import type { DependencyList, EffectCallback } from 'react';
import type { ThrottleOptions } from '../useThrottle/throttleOptions';
import useThrottleFn from '../useThrottleFn';
import useUpdateEffect from '../useUpdateEffect';

function useThrottleEffect(
  effect: EffectCallback,
  deps?: DependencyList,
  options?: ThrottleOptions,
) {
  const [flag, setFlag] = useState({});

  const { run } = useThrottleFn(() => {
    setFlag({});
  }, options);

  useEffect(() => {
    return run();
  }, deps);

  useUpdateEffect(effect, [flag]);
}

export default useThrottleEffect;
```

## 解读

<Callout>
  关于
  `useThrottleFn`、`useUpdateEffect`，可以查看对应文档：[useThrottleFn](../../effect/use-throttle-fn/)、[useUpdateEffect](../../effect/use-update-effect/)。
</Callout>

{/* prettier-ignore */}

```ts
function useThrottleEffect(
  effect: EffectCallback,
  deps?: DependencyList,
  options?: ThrottleOptions,
) { 
  // 1. 首先，使用 useState 定义了一个 flag 状态，用于记录依赖是否更新。
  const [flag, setFlag] = useState({});

  // 2. 然后，使用 useThrottleFn 来定义一个节流函数。
  const { run } = useThrottleFn(() => {
    setFlag({});
  }, options);

  // 3. 接着，使用 useEffect 来监听依赖的更新，并调用 run 函数执行节流函数。
  useEffect(() => {
    return run();
  }, deps);

  // 4. 最后，使用 useUpdateEffect 来监听 flag 的变化，并执行 effect。
  useUpdateEffect(effect, [flag]);
}
```


# useThrottleFn





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-throttle-fn" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useThrottleFn/index.ts" text="源码" />

## 用法

用来处理节流函数的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState } from 'react'\nimport { useThrottleFn } from 'ahooks'\n\nexport default function Demo() {\n  const [value, setValue] = useState(0)\n  const { run } = useThrottleFn(\n    () => {\n      setValue(value + 1)\n    },\n    { wait: 500 },\n  )\n\n  return (\n    <div>\n      <p style={{ marginTop: 16 }}> Clicked count: {value} </p>\n      <button type=\"button\" onClick={run}>\n        Click fast!\n      </button>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useThrottleFn.ts"
import throttle from 'lodash/throttle';
import { useMemo } from 'react';
import useLatest from '../useLatest';
import type { ThrottleOptions } from '../useThrottle/throttleOptions';
import useUnmount from '../useUnmount';
import { isFunction } from '../utils';
import isDev from '../utils/isDev';

type noop = (...args: any[]) => any;

function useThrottleFn<T extends noop>(fn: T, options?: ThrottleOptions) {
  if (isDev) {
    if (!isFunction(fn)) {
      console.error(`useThrottleFn expected parameter is a function, got ${typeof fn}`);
    }
  }

  const fnRef = useLatest(fn);

  const wait = options?.wait ?? 1000;

  const throttled = useMemo(
    () =>
      throttle(
        (...args: Parameters<T>): ReturnType<T> => {
          return fnRef.current(...args);
        },
        wait,
        options,
      ),
    [],
  );

  useUnmount(() => {
    throttled.cancel();
  });

  return {
    run: throttled,
    cancel: throttled.cancel,
    flush: throttled.flush,
  };
}

export default useThrottleFn;
```

## 解读

<Callout>
  关于
  `useLatest`、`useUnmount`，可以查看对应文档：[useLatest](../../advanced/use-latest/)、[useUnmount](../../life-cycle/use-unmount/)。
</Callout>

{/* prettier-ignore */}

```ts
function useThrottleFn<T extends noop>(fn: T, options?: ThrottleOptions) {
  // 1. 首先，使用 useLatest 来记录函数的最新值。
  const fnRef = useLatest(fn);

  // 2. 然后，使用 options 中的 wait 属性来设置节流时间，默认值为 1000ms。
  const wait = options?.wait ?? 1000;

  // 3. 接着，使用 useMemo 来缓存节流后的函数。节流后的函数内部会调用 fnRef 对象的值，并返回函数的执行结果。
  const throttled = useMemo(
    () =>
      // 使用 lodash 的 throttle 函数实现节流函数，参数配置也完全与 lodash 的 throttle 函数一致。
      throttle(
        (...args: Parameters<T>): ReturnType<T> => {
          return fnRef.current(...args);
        },
        wait,
        options,
      ),
    [],
  );

  // 4. 然后，使用 useUnmount 来卸载节流后的函数。
  useUnmount(() => {
    throttled.cancel();
  });

  // 5. 最后，返回节流后的函数，包括 run、cancel、flush 三个方法。
  return {
    run: throttled,
    cancel: throttled.cancel,
    flush: throttled.flush,
  };
}
```


# useTimeout



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-timeout" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useTimeout/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useUpdateEffect





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-update-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useUpdateEffect/index.ts" text="源码" />

## 用法

用法等同于 `useEffect`，但不同的是，会忽略首次执行，只在依赖更新时执行。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useEffect, useState } from 'react'\nimport { useUpdateEffect } from 'ahooks'\n\nexport default function Demo() {\n  const [count, setCount] = useState(0)\n  const [effectCount, setEffectCount] = useState(0)\n  const [updateEffectCount, setUpdateEffectCount] = useState(0)\n\n  useEffect(() => {\n    setEffectCount(c => c + 1)\n  }, [count])\n\n  useUpdateEffect(() => {\n    setUpdateEffectCount(c => c + 1)\n    return () => {\n      // do something\n    }\n  }, [count]) // you can include deps array if necessary\n\n  return (\n    <div>\n      <p>effectCount: {effectCount}</p>\n      <p>updateEffectCount: {updateEffectCount}</p>\n      <p>\n        <button type=\"button\" onClick={() => setCount(c => c + 1)}>\n          reRender\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="useUpdateEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="useUpdateEffect.ts">
      useUpdateEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="useUpdateEffect.ts">
    ```ts
    import { useEffect } from 'react';
    import { createUpdateEffect } from '../createUpdateEffect';

    export default createUpdateEffect(useEffect);
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="createUpdateEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="createUpdateEffect.ts">
      createUpdateEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="createUpdateEffect.ts">
    ```ts
    import { useRef } from 'react';
    import type { useEffect, useLayoutEffect } from 'react';

    type EffectHookType = typeof useEffect | typeof useLayoutEffect;

    export const createUpdateEffect: (hook: EffectHookType) => EffectHookType =
      (hook) => (effect, deps) => {
        const isMounted = useRef(false);

        // for react-refresh
        hook(() => {
          return () => {
            isMounted.current = false;
          };
        }, []);

        hook(() => {
          if (!isMounted.current) {
            isMounted.current = true;
          } else {
            return effect();
          }
        }, deps);
      };

    export default createUpdateEffect;
    ```
  </CodeBlockTab>
</CodeBlockTabs>

## 解读

首先，调用 `createUpdateEffect` 函数，传入 `useEffect` 函数。`createUpdateEffect` 函数接收一个函数作为参数，返回一个新函数。这样封装的目的是为了支持 `useLayoutEffect` 的用法。ahooks 中有很多类似的这种封装，因为需要同时支持 `useEffect` 和 `useLayoutEffect` 的用法。

直接把源码中的参数 `hook` 替换成 `useEffect`，再来看看实际的代码：

```ts
export const useUpdateEffect = (effect, deps) => {
  // 1. 使用 useRef 定义一个 ref 对象，用于记录组件是否已经挂载
  const isMounted = useRef(false)

  // 2. 使用 useEffect 监听组件的卸载，在组件卸载时，将 isMounted 的值设置为 false
  useEffect(() => {
    return () => {
      isMounted.current = false
    }
  }, [])

  // 3. 使用 useEffect 监听依赖的更新
  //    因为 useEffect 会在组件挂载时执行一次，但是由于 isMounted 的初始值为 false，所以会跳过这次 effect 的执行
  //    后续依赖更新时，才会执行 effect
  useEffect(() => {
    if (!isMounted.current) {
      isMounted.current = true
    } else {
      return effect()
    }
  }, deps)
}
```


# useUpdateLayoutEffect





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-update-layout-effect" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useUpdateLayoutEffect/index.ts" text="源码" />

## 用法

用法与 `useLayoutEffect` 一致，不同的是，会忽略首次执行，只在依赖更新时执行。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useLayoutEffect, useState } from 'react'\nimport { useUpdateLayoutEffect } from 'ahooks'\n\nexport default function Demo() {\n  const [count, setCount] = useState(0)\n  const [layoutEffectCount, setLayoutEffectCount] = useState(0)\n  const [updateLayoutEffectCount, setUpdateLayoutEffectCount] = useState(0)\n\n  useLayoutEffect(() => {\n    setLayoutEffectCount(c => c + 1)\n  }, [count])\n\n  useUpdateLayoutEffect(() => {\n    setUpdateLayoutEffectCount(c => c + 1)\n    return () => {\n      // do something\n    }\n  }, [count]) // you can include deps array if necessary\n\n  return (\n    <div>\n      <p>layoutEffectCount: {layoutEffectCount}</p>\n      <p>updateLayoutEffectCount: {updateLayoutEffectCount}</p>\n      <p>\n        <button type=\"button\" onClick={() => setCount(c => c + 1)}>\n          reRender\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="useUpdateLayoutEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="useUpdateLayoutEffect.ts">
      useUpdateLayoutEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="useUpdateLayoutEffect.ts">
    ```ts
    import { useLayoutEffect } from 'react';
    import { createUpdateEffect } from '../createUpdateEffect';

    export default createUpdateEffect(useLayoutEffect);
    ```
  </CodeBlockTab>
</CodeBlockTabs>

{/* prettier-ignore */}

<CodeBlockTabs defaultValue="createUpdateEffect.ts">
  <CodeBlockTabsList>
    <CodeBlockTabsTrigger value="createUpdateEffect.ts">
      createUpdateEffect.ts
    </CodeBlockTabsTrigger>
  </CodeBlockTabsList>

  <CodeBlockTab value="createUpdateEffect.ts">
    ```ts
    import { useRef } from 'react';
    import type { useEffect, useLayoutEffect } from 'react';

    type EffectHookType = typeof useEffect | typeof useLayoutEffect;

    export const createUpdateEffect: (hook: EffectHookType) => EffectHookType =
      (hook) => (effect, deps) => {
        const isMounted = useRef(false);

        // for react-refresh
        hook(() => {
          return () => {
            isMounted.current = false;
          };
        }, []);

        hook(() => {
          if (!isMounted.current) {
            isMounted.current = true;
          } else {
            return effect();
          }
        }, deps);
      };

    export default createUpdateEffect;
    ```
  </CodeBlockTab>
</CodeBlockTabs>

## 解读

关于 `createUpdateEffect` 的解读，可以查看对应文档：[useUpdateEffect](../../effect/use-update-effect/#解读)。


# useUpdate





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-update" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useUpdate/index.ts" text="源码" />

## 用法

返回一个函数，调用该函数会强制组件重新渲染。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useUpdate } from 'ahooks'\n\nexport default function Demo() {\n  const update = useUpdate()\n\n  return (\n    <>\n      <div>Time: {new Date().toISOString()}</div>\n      <button type=\"button\" onClick={update} style={{ marginTop: 8 }}>\n        update\n      </button>\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useUpdate.ts"
import { useCallback, useState } from 'react';

const useUpdate = () => {
  const [, setState] = useState({});

  return useCallback(() => setState({}), []);
};

export default useUpdate;
```

## 解读

{/* prettier-ignore */}

```ts
function useUpdate() {
  // 1. 使用 useState 定义一个空对象，用于记录状态，只需要这个状态更新函数，不需要这个状态
  const [, setState] = useState({});

  // 2. 使用 useCallback 返回一个函数，调用该函数会执行 setState 函数，传入一个空对象，从而触发组件重新渲染
  return useCallback(() => setState({}), []);
}
```


# useAntdTable



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-antd-table" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useAntdTable/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useCountDown



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-count-down" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useCountDown/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useCounter



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-counter" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useCounter/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useDynamicList



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-dynamic-list" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDynamicList/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useFusionTable



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-fusion-table" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useFusionTable/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useHistoryTravel



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-history-travel" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useHistoryTravel/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useInfiniteScroll



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-infinite-scroll" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useInfiniteScroll/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useNetwork



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-network" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useNetwork/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# usePagination



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-pagination" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/usePagination/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useSelections



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-selections" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useSelections/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useTextSelection



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-text-selection" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useTextSelection/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useTheme



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-theme" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useTheme/index.ts" text="源码" />

## 用法

获取并设置当前主题，并将主题存储在 `localStorage` 中。

{/* FIXME ReferenceError: localStorage is not defined */}

{/* <ViewCode src="./use-theme/use-theme.tsx" /> */}

## 源码

{/* prettier-ignore */}

```ts title="useTheme.ts"
import { useEffect, useState } from 'react';
import useMemoizedFn from '../useMemoizedFn';
import isBrowser from '../utils/isBrowser';

export enum ThemeMode {
  LIGHT = 'light',
  DARK = 'dark',
  SYSTEM = 'system',
}

export type ThemeModeType = `${ThemeMode}`;

export type ThemeType = 'light' | 'dark';

const useCurrentTheme = () => {
  const matchMedia = isBrowser ? window.matchMedia('(prefers-color-scheme: dark)') : undefined;
  const [theme, setTheme] = useState<ThemeType>(() => {
    if (isBrowser) {
      return matchMedia?.matches ? ThemeMode.DARK : ThemeMode.LIGHT;
    } else {
      return ThemeMode.LIGHT;
    }
  });

  useEffect(() => {
    const onThemeChange: MediaQueryList['onchange'] = (event) => {
      if (event.matches) {
        setTheme(ThemeMode.DARK);
      } else {
        setTheme(ThemeMode.LIGHT);
      }
    };

    matchMedia?.addEventListener('change', onThemeChange);

    return () => {
      matchMedia?.removeEventListener('change', onThemeChange);
    };
  }, []);

  return theme;
};

type Options = {
  localStorageKey?: string;
};

export default function useTheme(options: Options = {}) {
  const { localStorageKey } = options;

  const [themeMode, setThemeMode] = useState<ThemeModeType>(() => {
    const preferredThemeMode =
      localStorageKey?.length && (localStorage.getItem(localStorageKey) as ThemeModeType | null);

    return preferredThemeMode || ThemeMode.SYSTEM;
  });

  const setThemeModeWithLocalStorage = (mode: ThemeModeType) => {
    setThemeMode(mode);

    if (localStorageKey?.length) {
      localStorage.setItem(localStorageKey, mode);
    }
  };

  const currentTheme = useCurrentTheme();
  const theme = themeMode === ThemeMode.SYSTEM ? currentTheme : themeMode;

  return {
    theme,
    themeMode,
    setThemeMode: useMemoizedFn(setThemeModeWithLocalStorage),
  };
}
```

## 解读

先看 `useCurrentTheme` 的实现，用来获取当前的主题 `light` 或 `dark`。

创建一个 `matchMedia` 对象，用来监听系统主题的变化。并用一个 `state` 记录当前的主题 `light` 或 `dark`。

{/* prettier-ignore */}

```ts
const useCurrentTheme = () => {
  const matchMedia = isBrowser ? window.matchMedia('(prefers-color-scheme: dark)') : undefined; // [!code focus:8]
  const [theme, setTheme] = useState<ThemeType>(() => {
    if (isBrowser) {
      return matchMedia?.matches ? ThemeMode.DARK : ThemeMode.LIGHT;
    } else {
      return ThemeMode.LIGHT;
    }
  });

  /* ... */
};
```

然后在 `useEffect` 中监听系统主题的变化，并更新 `theme`。最后返回 `theme`。

{/* prettier-ignore */}

```ts
const useCurrentTheme = () => {
  /* ... */

  useEffect(() => { // [!code focus:17]
    const onThemeChange: MediaQueryList['onchange'] = (event) => {
      if (event.matches) {
        setTheme(ThemeMode.DARK);
      } else {
        setTheme(ThemeMode.LIGHT);
      }
    };

    matchMedia?.addEventListener('change', onThemeChange);

    return () => {
      matchMedia?.removeEventListener('change', onThemeChange);
    };
  }, []);

  return theme;
};
```

接着看 `useTheme` 的实现。

从入参中获取 `localStorageKey`。

如果 `localStorageKey` 存在，则从 `localStorage` 中获取主题模式。否则使用默认值 `ThemeMode.SYSTEM`。

这里的 `themeMode` 是主题模式，可选值有：`light`、`dark`、`system`。

{/* prettier-ignore */}

```ts
export default function useTheme(options: Options = {}) {
  const { localStorageKey } = options; // [!code focus:8]

  const [themeMode, setThemeMode] = useState<ThemeModeType>(() => {
    const preferredThemeMode =
      localStorageKey?.length && (localStorage.getItem(localStorageKey) as ThemeModeType | null);

    return preferredThemeMode || ThemeMode.SYSTEM;
  });

  /* ... */
}
```

然后是定义 `setThemeModeWithLocalStorage` 函数，用来更新 `themeMode`，并将值存储到 `localStorage` 中。

{/* prettier-ignore */}

```ts
export default function useTheme(options: Options = {}) {
  /* ... */

  const setThemeModeWithLocalStorage = (mode: ThemeModeType) => { // [!code focus:7]
    setThemeMode(mode);

    if (localStorageKey?.length) {
      localStorage.setItem(localStorageKey, mode);
    }
  };

  /* ... */
}
```

最后，先是调用 `useCurrentTheme` 获取当前主题 `currentTheme`。

如果 `themeMode` 为 `system`，则使用 `currentTheme` 作为当前主题。否则使用 `themeMode` 作为当前主题。

最后返回 `theme`、`themeMode` 和 `setThemeMode` 函数。

<Callout>
  关于
  `useMemoizedFn`，可以查看对应文档：[useMemoizedFn](../../advanced/use-memoized-fn/)，用来缓存函数引用，避免重复创建函数。
</Callout>

{/* prettier-ignore */}

```ts
export default function useTheme(options: Options = {}) {
  /* ... */

  const currentTheme = useCurrentTheme(); // [!code focus:8]
  const theme = themeMode === ThemeMode.SYSTEM ? currentTheme : themeMode;

  return {
    theme,
    themeMode,
    setThemeMode: useMemoizedFn(setThemeModeWithLocalStorage),
  };
}
```


# useVirtualList



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-virtual-list" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useVirtualList/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useWebSocket



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-web-socket" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useWebSocket/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useBoolean





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-boolean#useboolean" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useBoolean/index.ts" text="源码" />

## 用法

用来管理布尔值的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useBoolean } from 'ahooks'\n\nexport default function Demo() {\n  const [state, { toggle, setTrue, setFalse }] = useBoolean(true)\n\n  return (\n    <div>\n      <p>Effects：{JSON.stringify(state)}</p>\n      <p>\n        <button type=\"button\" onClick={toggle}>\n          Toggle\n        </button>\n        <button type=\"button\" onClick={setFalse} style={{ margin: '0 16px' }}>\n          Set false\n        </button>\n        <button type=\"button\" onClick={setTrue}>\n          Set true\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useBoolean.ts"
import { useMemo } from 'react';
import useToggle from '../useToggle';

export interface Actions {
  setTrue: () => void;
  setFalse: () => void;
  set: (value: boolean) => void;
  toggle: () => void;
}

export default function useBoolean(defaultValue = false): [boolean, Actions] {
  const [state, { toggle, set }] = useToggle(!!defaultValue);

  const actions: Actions = useMemo(() => {
    const setTrue = () => set(true);
    const setFalse = () => set(false);
    return {
      toggle,
      set: (v) => set(!!v),
      setTrue,
      setFalse,
    };
  }, []);

  return [state, actions];
}
```

## 解读

*TODO*


# useCookieState



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-cookie-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useCookieState/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useDebounce





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-raf-state#userafstate" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useDebounce/index.ts" text="源码" />

## 用法

用来处理防抖值的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState } from 'react'\nimport { useDebounce } from 'ahooks'\n\nexport default function Demo() {\n  const [value, setValue] = useState<string>()\n  const debouncedValue = useDebounce(value, { wait: 500 })\n\n  return (\n    <div>\n      <input\n        value={value}\n        onChange={e => setValue(e.target.value)}\n        placeholder=\"Typed value\"\n        style={{ width: 280 }}\n      />\n      <p style={{ marginTop: 16 }}>Value: {value}</p>\n      <p style={{ marginTop: 16 }}>DebouncedValue（延时 500ms 后更新）: {debouncedValue}</p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useDebounce.ts"
import { useEffect, useState } from 'react';
import useDebounceFn from '../useDebounceFn';
import type { DebounceOptions } from './debounceOptions';

function useDebounce<T>(value: T, options?: DebounceOptions) {
  const [debounced, setDebounced] = useState(value);

  const { run } = useDebounceFn(() => {
    setDebounced(value);
  }, options);

  useEffect(() => {
    run();
  }, [value]);

  return debounced;
}

export default useDebounce;
```

## 解读

<Callout>
  关于 `useDebounceFn`，可以查看对应文档：[useDebounceFn](../../effect/use-debounce-fn/)。
</Callout>

{/* prettier-ignore */}

```ts
function useDebounce<T>(value: T, options?: DebounceOptions) {
  // 1. 首先，使用 useState 定义了一个 debounced 状态，用于存储防抖后的值。
  const [debounced, setDebounced] = useState(value);

  // 2. 然后，使用 useDebounceFn 来定义一个防抖函数。
  const { run } = useDebounceFn(() => {
    setDebounced(value);
  }, options);

  // 3. 接着，使用 useEffect 来监听 value 的变化，并调用 run 函数执行防抖函数。
  useEffect(() => {
    run();
  }, [value]);

  // 4. 最后，返回防抖后的值。
  return debounced;
}
```


# useGetState



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-get-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useGetState/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useLocalStorageState



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-local-storage-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLocalStorageState/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useMap





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-map" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMap/index.ts" text="源码" />

## 用法

管理 `Map` 类型状态。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useMap } from 'ahooks'\n\nexport default function Demo() {\n  const [map, { set, setAll, remove, reset, get }] = useMap<string | number, string>([\n    ['msg', 'hello world'],\n    [123, 'number type'],\n  ])\n\n  return (\n    <div>\n      <button type=\"button\" onClick={() => set(String(Date.now()), new Date().toJSON())}>\n        Add\n      </button>\n      <button\n        type=\"button\"\n        onClick={() => setAll([['text', 'this is a new Map']])}\n        style={{ margin: '0 8px' }}\n      >\n        Set new Map\n      </button>\n      <button type=\"button\" onClick={() => remove('msg')} disabled={!get('msg')}>\n        Remove {'msg'}\n      </button>\n      <button type=\"button\" onClick={() => reset()} style={{ margin: '0 8px' }}>\n        Reset\n      </button>\n      <div style={{ marginTop: 16 }}>\n        <pre>{JSON.stringify(Array.from(map), null, 2)}</pre>\n      </div>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useMap.ts"
import { useState } from 'react';
import useMemoizedFn from '../useMemoizedFn';

function useMap<K, T>(initialValue?: Iterable<readonly [K, T]>) {
  const getInitValue = () => new Map(initialValue);
  const [map, setMap] = useState<Map<K, T>>(getInitValue);

  const set = (key: K, entry: T) => {
    setMap((prev) => {
      const temp = new Map(prev);
      temp.set(key, entry);
      return temp;
    });
  };

  const setAll = (newMap: Iterable<readonly [K, T]>) => {
    setMap(new Map(newMap));
  };

  const remove = (key: K) => {
    setMap((prev) => {
      const temp = new Map(prev);
      temp.delete(key);
      return temp;
    });
  };

  const reset = () => setMap(getInitValue());

  const get = (key: K) => map.get(key);

  return [
    map,
    {
      set: useMemoizedFn(set),
      setAll: useMemoizedFn(setAll),
      remove: useMemoizedFn(remove),
      reset: useMemoizedFn(reset),
      get: useMemoizedFn(get),
    },
  ] as const;
}

export default useMap;
```

## 解读

<Callout>
  关于 `useMemoizedFn`，可以查看对应文档：[useMemoizedFn](../../advanced/use-memoized-fn/)。
</Callout>

本质上 `useMap` 返回的就是一个普通 `Map` 类型的数据，而在更新时则传入一个新的 `Map` 对象，从而触发页面重新渲染。

{/* prettier-ignore */}

```ts
function useMap<K, V>(initialValue?: Iterable<[K, V]>) {
  // 1. 定义一个获取初始值的函数，方便后续 reset 函数内部调用
  const getInitValue = () => new Map(initialValue);
  // 2. 定义一个 `Map` 类型的状态，初始值为 `getInitValue` 函数的返回值
  const [map, setMap] = useState<Map<K, T>>(getInitValue);

  // 3. 定义一个更新 `Map` 内某个键值对的方法，传入一个键和值，更新时返回一个新的 `Map` 对象
  const set = useMemoizedFn((key: K, entry: T) => {
    setMap((prev) => {
      const temp = new Map(prev);
      temp.set(key, entry);
      return temp;
    });
  });

  // 4. 定义一个全量更新 `Map` 数据的方法，传入一个 `Map` 对象，全量更新时传入一个新的 `Map` 对象
  const setAll = (newMap: Iterable<readonly [K, T]>) => {
    setMap(new Map(newMap));
  };

  // 5. 定义一个删除 `Map` 内某个键值对的方法，传入一个键，删除时返回一个新的 `Map` 对象
  const remove = useMemoizedFn((key: K) => {
    setMap((prev) => {
      const temp = new Map(prev);
      temp.delete(key);
      return temp;
    });
  };

  // 6. 定义一个重置 `Map` 数据的方法，重置时传入 `getInitValue` 函数的返回值
  const reset = () => setMap(getInitValue());

  // 7. 定义一个获取 `Map` 内某个键值对的方法，传入一个键，获取时返回 `Map` 对象中对应键的值
  const get = (key: K) => map.get(key);

  // 8. 返回 `Map` 对象和更新 `Map` 数据的方法
  return [
    map,
    {
      set: useMemoizedFn(set),
      setAll: useMemoizedFn(setAll),
      remove: useMemoizedFn(remove),
      reset: useMemoizedFn(reset),
      get: useMemoizedFn(get),
    },
  ] as const;
}
```


# usePrevious





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-previous" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/usePrevious/index.ts" text="源码" />

## 用法

保存上一次状态的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { usePrevious } from 'ahooks'\nimport { useState } from 'react'\n\nexport default function Demo() {\n  const [count, setCount] = useState(0)\n  const previous = usePrevious(count)\n  return (\n    <>\n      <div>counter current value: {count}</div>\n      <div style={{ marginBottom: 8 }}>counter previous value: {previous}</div>\n      <button type=\"button\" onClick={() => setCount(c => c + 1)}>\n        increase\n      </button>\n      <button type=\"button\" style={{ marginLeft: 8 }} onClick={() => setCount(c => c - 1)}>\n        decrease\n      </button>\n    </>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="usePrevious.ts"
import { useRef } from 'react';

export type ShouldUpdateFunc<T> = (prev?: T, next?: T) => boolean;

const defaultShouldUpdate = <T>(a?: T, b?: T) => !Object.is(a, b);

function usePrevious<T>(
  state: T,
  shouldUpdate: ShouldUpdateFunc<T> = defaultShouldUpdate,
): T | undefined {
  const prevRef = useRef<T>(undefined);
  const curRef = useRef<T>(undefined);

  if (shouldUpdate(curRef.current, state)) {
    prevRef.current = curRef.current;
    curRef.current = state;
  }

  return prevRef.current;
}

export default usePrevious;
```

## 解读

在内部定义两个 `ref` 对象，分别用于存储上一次状态和当前状态，并在每次状态更新时，判断当前状态与上一次状态是否不同，如果不同，则更新上一次状态。

{/* prettier-ignore */}

```ts
function usePrevious<T>(
  state: T,
  shouldUpdate: ShouldUpdateFunc<T> = defaultShouldUpdate,
): T | undefined {
  // 1. 定义两个 ref 对象，分别用于存储上一次状态和当前状态
  const prevRef = useRef<T>(undefined);
  const curRef = useRef<T>(undefined);

  // 2. 如果当前状态与上一次状态不同
  if (shouldUpdate(curRef.current, state)) {
    // 2.1. 更新上一次状态
    prevRef.current = curRef.current;
    // 2.2. 更新当前状态
    curRef.current = state;
  }

  // 3. 返回上一次状态
  return prevRef.current;
}
```


# useRafState





{' '}

<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-raf-state#userafstate" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRafState/index.ts" text="源码" />

## 用法

在 `requestAnimationFrame` 中更新状态。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useRafState } from 'ahooks'\nimport { useEffect, useState } from 'react'\n\nconst WithUseState = function ({ times = 1 }) {\n  const [state, setState] = useState(0)\n  useEffect(() => {\n    const onScroll = () => {\n      for (let i = 0; i < times; i++) {\n        setState(prev => prev + 1)\n      }\n    }\n\n    window.addEventListener('scroll', onScroll)\n\n    return () => {\n      window.removeEventListener('scroll', onScroll)\n    }\n  }, [])\n\n  return (\n    <div style={{ color: '#F44336' }}>\n      [WithUseState] update state count: {state} / {times}\n    </div>\n  )\n}\n\nconst WithUseRafState = function ({ times = 1 }) {\n  const [state, setState] = useRafState(0)\n  useEffect(() => {\n    const onScroll = () => {\n      for (let i = 0; i < times; i++) {\n        setState(prev => prev + 1)\n      }\n    }\n\n    window.addEventListener('scroll', onScroll)\n\n    return () => {\n      window.removeEventListener('scroll', onScroll)\n    }\n  }, [])\n\n  return (\n    <div style={{ color: '#4CAF50' }}>\n      [WithUseRafState] update state count: {state} / {times}\n    </div>\n  )\n}\n\nexport default function Demo() {\n  return (\n    <div>\n      滚动页面，观察两个组件更新次数的差异\n      <WithUseState times={1} />\n      <WithUseRafState times={1} />\n      <hr />\n      <WithUseState times={10} />\n      <WithUseRafState times={10} />\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts [useRafState.ts]
import { useCallback, useRef, useState } from 'react';
import type { Dispatch, SetStateAction } from 'react';
import useUnmount from '../useUnmount';

function useRafState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];
function useRafState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];

function useRafState<S>(initialState?: S | (() => S)) {
  const ref = useRef(0);
  const [state, setState] = useState(initialState);

  const setRafState = useCallback((value: S | ((prevState: S) => S)) => {
    cancelAnimationFrame(ref.current);

    ref.current = requestAnimationFrame(() => {
      setState(value);
    });
  }, []);

  useUnmount(() => {
    cancelAnimationFrame(ref.current);
  });

  return [state, setRafState] as const;
}

export default useRafState;
```

## 解读

*TODO*

{/* 与 `useState` 相比，`useRafState` 会在 `requestAnimationFrame` 中更新状态，而不是在 `setState` 中更新状态。 */}


# useResetState



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-reset-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useResetState/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useSafeState





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-safe-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useSafeState/index.ts" text="源码" />

## 用法

组件卸载后，不再更新状态。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useEffect, useState } from 'react'\nimport { useSafeState } from 'ahooks'\n\nconst Child = function () {\n  const [value, setValue] = useSafeState<string>()\n\n  useEffect(() => {\n    setTimeout(() => {\n      setValue('data loaded from server')\n    }, 5000)\n  }, [])\n\n  const text = value || 'Loading...'\n\n  return <div>{text}</div>\n}\n\nexport default function Demo() {\n  const [visible, setVisible] = useState(true)\n\n  return (\n    <div>\n      <button onClick={() => setVisible(!visible)}>{visible ? 'Unmount' : 'Mount'}</button>\n      {visible && <Child />}\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useSafeState.ts"
import { useCallback, useState } from 'react';
import type { Dispatch, SetStateAction } from 'react';
import useUnmountedRef from '../useUnmountedRef';

function useSafeState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];

function useSafeState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];

function useSafeState<S>(initialState?: S | (() => S)) {
  const unmountedRef = useUnmountedRef();
  const [state, setState] = useState(initialState);
  const setCurrentState = useCallback((currentState: S) => {
    /** if component is unmounted, stop update */
    if (unmountedRef.current) {
      return;
    }
    setState(currentState);
  }, []);

  return [state, setCurrentState] as const;
}

export default useSafeState;
```

## 解读

<Callout>
  关于 `useUnmountedRef`，可以查看对应文档：[useUnmountedRef](../../life-cycle/use-unmounted-ref/)。
</Callout>

内部使用 `useUnmountedRef` 来判断组件是否已经卸载，如果已经卸载，则不进行更新。

{/* prettier-ignore */}

```ts
function useSafeState<S>(initialState?: S | (() => S)) {
  const unmountedRef = useUnmountedRef(); // [!code focus:1]
  const [state, setState] = useState(initialState);
  const setCurrentState = useCallback((currentState: S) => {
    /** if component is unmounted, stop update */
    if (unmountedRef.current) { // [!code focus:3]
      return;
    }
    setState(currentState);
  }, []);

  return [state, setCurrentState] as const;
}
```

内部定义 `setCurrentState` 作为更新函数，并使用 `useCallback` 缓存函数引用，避免重复创建函数，导致重渲染。

{/* prettier-ignore */}

```ts
function useSafeState<S>(initialState?: S | (() => S)) {
  const unmountedRef = useUnmountedRef();
  const [state, setState] = useState(initialState);
  const setCurrentState = useCallback((currentState: S) => { // [!code focus:7]
    /** if component is unmounted, stop update */
    if (unmountedRef.current) {
      return;
    }
    setState(currentState);
  }, []);

  return [state, setCurrentState] as const;
}
```

最后返回 `state` 和 `setCurrentState`。

{/* prettier-ignore */}

```ts
function useSafeState<S>(initialState?: S | (() => S)) {
  const unmountedRef = useUnmountedRef();
  const [state, setState] = useState(initialState);
  const setCurrentState = useCallback((currentState: S) => {
    /** if component is unmounted, stop update */
    if (unmountedRef.current) {
      return;
    }
    setState(currentState);
  }, []);

  return [state, setCurrentState] as const; // [!code focus:1]
}
```


# useSessionStorageState



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-session-storage-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useSessionStorageState/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*


# useSetState





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-set-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useSetState/index.ts" text="源码" />

## 用法

用于更新对象状态，自动合并对象。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useSetState } from 'ahooks'\n\ninterface State {\n  hello: string\n  [key: string]: any\n}\n\nexport default function Demo() {\n  const [state, setState] = useSetState<State>({\n    hello: '',\n  })\n\n  return (\n    <div>\n      <pre>{JSON.stringify(state, null, 2)}</pre>\n      <p>\n        <button type=\"button\" onClick={() => setState({ hello: 'world' })}>\n          set hello\n        </button>\n        <button type=\"button\" onClick={() => setState({ foo: 'bar' })} style={{ margin: '0 8px' }}>\n          set foo\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useSetState.ts"
import { useState } from 'react';
import useMemoizedFn from '../useMemoizedFn';
import { isFunction } from '../utils';

export type SetState<S extends Record<string, any>> = <K extends keyof S>(
  state: Pick<S, K> | null | ((prevState: Readonly<S>) => Pick<S, K> | S | null),
) => void;

const useSetState = <S extends Record<string, any>>(
  initialState: S | (() => S),
): [S, SetState<S>] => {
  const [state, setState] = useState<S>(initialState);

  const setMergeState = useMemoizedFn((patch) => {
    setState((prevState) => {
      const newState = isFunction(patch) ? patch(prevState) : patch;
      return newState ? { ...prevState, ...newState } : prevState;
    });
  });

  return [state, setMergeState];
};

export default useSetState;
```

## 解读

重点就是 `setMergeState` 函数。

首先使用 `useMemoizedFn` 缓存函数引用，避免重复创建函数。

<Callout>
  关于 `useMemoizedFn`，可以查看对应文档：[useMemoizedFn](../../advanced/use-memoized-fn/)。
</Callout>

{/* prettier-ignore */}

```ts
const useSetState = <S extends Record<string, any>>(
  initialState: S | (() => S),
): [S, SetState<S>] => {
  const [state, setState] = useState<S>(initialState);

  const setMergeState = useMemoizedFn((patch) => { // [!code focus:6]
    setState((prevState) => {
      const newState = isFunction(patch) ? patch(prevState) : patch;
      return newState ? { ...prevState, ...newState } : prevState;
    });
  });

  return [state, setMergeState];
};
```

内部直接调用 `setState` 函数，并传入一个回调函数。

{/* prettier-ignore */}

```ts
const useSetState = <S extends Record<string, any>>(
  initialState: S | (() => S),
): [S, SetState<S>] => {
  const [state, setState] = useState<S>(initialState);

  const setMergeState = useMemoizedFn((patch) => { 
    setState((prevState) => { // [!code focus:4]
      const newState = isFunction(patch) ? patch(prevState) : patch;
      return newState ? { ...prevState, ...newState } : prevState;
    });
  });

  return [state, setMergeState];
};
```

如果 `patch` 是函数，则调用 `patch` 函数，并传入 `prevState` 参数，返回新的状态。否则，直接返回 `patch`。

最后，如果 `newState` 为 `Truthy` 值，则返回使用扩展运算符合并后的新对象。否则返回 `prevState`。

内部也没有对 `prevState` 和 `newState` 进行类型判断，而是直接使用扩展运算符合并。如果得到的是非 `object` 类型，则会报错。这个需要特别注意。


# useSet





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-set" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useSet/index.ts" text="源码" />

## 用法

管理 `Set` 类型状态。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useSet } from 'ahooks'\n\nexport default function Demo() {\n  const [set, { add, remove, reset }] = useSet(['Hello'])\n\n  return (\n    <div>\n      <button type=\"button\" onClick={() => add(String(Date.now()))}>\n        Add Timestamp\n      </button>\n      <button\n        type=\"button\"\n        onClick={() => remove('Hello')}\n        disabled={!set.has('Hello')}\n        style={{ margin: '0 8px' }}\n      >\n        Remove Hello\n      </button>\n      <button type=\"button\" onClick={() => reset()}>\n        Reset\n      </button>\n      <div style={{ marginTop: 16 }}>\n        <pre>{JSON.stringify(Array.from(set), null, 2)}</pre>\n      </div>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useSet.ts"
import { useState } from 'react';
import useMemoizedFn from '../useMemoizedFn';

function useSet<K>(initialValue?: Iterable<K>) {
  const getInitValue = () => new Set(initialValue);
  const [set, setSet] = useState<Set<K>>(getInitValue);

  const updateSet = (updater: (set: Set<K>) => Set<K>) => {
    setSet((prevSet) => updater(new Set(prevSet)));
  };

  const add = (key: K) => {
    if (set.has(key)) {
      return;
    }
    updateSet((newSet) => {
      newSet.add(key);
      return newSet;
    });
  };

  const remove = (key: K) => {
    if (!set.has(key)) {
      return;
    }
    updateSet((newSet) => {
      newSet.delete(key);
      return newSet;
    });
  };

  const reset = () => setSet(getInitValue());

  return [
    set,
    {
      add: useMemoizedFn(add),
      remove: useMemoizedFn(remove),
      reset: useMemoizedFn(reset),
    },
  ] as const;
}

export default useSet;
```

<Callout>
  关于 `useMemoizedFn`，可以查看对应文档：[useMemoizedFn](../../advanced/use-memoized-fn/)。
</Callout>

## 解读

在不了解 `useSet` 之前，如果使用 `useState` 初始化一个 `Set` 类型的值，更新时需要怎么做呢？

基于 `React` 的渲染逻辑，每次更新都需要传入一个新的 `Set` 对象，才能保证页面可以更新。

也即：

{/* {6,12} */}

```ts
const [set, setSet] = useState(new Set())

// add
setSet(prev => {
  prev.add('foo')
  return new Set(prev) // 返回一个新的 Set 对象
})

// remove
setSet(prev => {
  prev.delete('foo')
  return new Set(prev) // 返回一个新的 Set 对象
})
```

而 `useSet` 内部也是这样实现的，只不过为了调用方便，内部将 `add`、`remove` 和 `reset` 方法进行了封装。

在内部会定义一个 `getInitValue` 函数，函数的执行结果返回当前初始值，`reset` 方法内部就是调用 `getInitValue` 函数，对 `Set` 对象进行重置。

```ts
function useSet<K>(initialValue?: Iterable<K>) {
  const getInitValue = () => new Set(initialValue)
  const [set, setSet] = useState<Set<K>>(getInitValue)

  /* ... */

  const reset = () => setSet(getInitValue())

  /* ... */
}
```


# useThrottle





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-throttle#usethrottle" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useThrottle/index.ts" text="源码" />

## 用法

用来处理节流值的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useState } from 'react'\nimport { useThrottle } from 'ahooks'\n\nexport default function Demo() {\n  const [value, setValue] = useState<string>()\n  const throttledValue = useThrottle(value, { wait: 500 })\n\n  return (\n    <div>\n      <input\n        value={value}\n        onChange={e => setValue(e.target.value)}\n        placeholder=\"Typed value\"\n        style={{ width: 280 }}\n      />\n      <p style={{ marginTop: 16 }}>throttledValue: {throttledValue}</p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useThrottle.ts"
import { useEffect, useState } from 'react';
import useThrottleFn from '../useThrottleFn';
import type { ThrottleOptions } from './throttleOptions';

function useThrottle<T>(value: T, options?: ThrottleOptions) {
  const [throttled, setThrottled] = useState(value);

  const { run } = useThrottleFn(() => {
    setThrottled(value);
  }, options);

  useEffect(() => {
    run();
  }, [value]);

  return throttled;
}

export default useThrottle;
```

## 解读

<Callout>
  关于 `useThrottleFn`，可以查看对应文档：[useThrottleFn](../../effect/use-throttle-fn/)。
</Callout>

{/* prettier-ignore */}

```ts
function useThrottle<T>(value: T, options?: ThrottleOptions) {
  // 1. 首先，使用 useState 定义了一个 throttled 状态，用于存储节流后的值。
  const [throttled, setThrottled] = useState(value);

  // 2. 然后，使用 useThrottleFn 来定义一个节流函数。
  const { run } = useThrottleFn(() => {
    setThrottled(value);
  }, options);

  // 3. 接着，使用 useEffect 来监听 value 的变化，并调用 run 函数执行节流函数。
  useEffect(() => {
    run();
  }, [value]);

  // 4. 最后，返回节流后的值。
  return throttled;
}
```


# useToggle





<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-toggle#usetoggle" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useToggle/index.ts" text="源码" />

## 用法

用来管理开关状态的 Hook。

<ViewCode component={<ViewCodeActualComponent0 />} code={"'use client'\n\nimport { useToggle } from 'ahooks'\n\nexport default function Demo() {\n  const [state, { toggle, setLeft, setRight }] = useToggle()\n\n  return (\n    <div>\n      <p>Effects：{`${state}`}</p>\n      <p>\n        <button type=\"button\" onClick={toggle}>\n          Toggle\n        </button>\n        <button type=\"button\" onClick={setLeft} style={{ margin: '0 8px' }}>\n          Toggle False\n        </button>\n        <button type=\"button\" onClick={setRight}>\n          Toggle True\n        </button>\n      </p>\n    </div>\n  )\n}\n"} />

## 源码

{/* prettier-ignore */}

```ts title="useToggle.ts"
import { useMemo, useState } from 'react';

export interface Actions<T> {
  setLeft: () => void;
  setRight: () => void;
  set: (value: T) => void;
  toggle: () => void;
}

function useToggle<T = boolean>(): [boolean, Actions<T>];

function useToggle<T>(defaultValue: T): [T, Actions<T>];

function useToggle<T, U>(defaultValue: T, reverseValue: U): [T | U, Actions<T | U>];

function useToggle<D, R>(defaultValue: D = false as unknown as D, reverseValue?: R) {
  const [state, setState] = useState<D | R>(defaultValue);

  const actions = useMemo(() => {
    const reverseValueOrigin = (reverseValue === undefined ? !defaultValue : reverseValue) as D | R;

    const toggle = () => setState((s) => (s === defaultValue ? reverseValueOrigin : defaultValue));
    const set = (value: D | R) => setState(value);
    const setLeft = () => setState(defaultValue);
    const setRight = () => setState(reverseValueOrigin);

    return {
      toggle,
      set,
      setLeft,
      setRight,
    };
    // useToggle ignore value change
    // }, [defaultValue, reverseValue]);
  }, []);

  return [state, actions];
}

export default useToggle;
```

## 解读

*TODO*


# useUrlState



<LinkButton url="https://ahooks.js.org/zh-CN/hooks/use-url-state" text="ahooks 文档" />

<LinkButton url="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useUrlState/index.ts" text="源码" />

## 用法

*TODO*

## 源码

## 解读

*TODO*
